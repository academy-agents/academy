{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Academy: Federated Actors and Agents","text":"<p>Academy is a modular and extensible middleware for building and deploying stateful actors and autonomous agents across distributed systems and federated research infrastructure. In Academy, you can:</p> <ul> <li>\u2699\ufe0f  Express agent behavior and state in code</li> <li>\ud83d\udceb Manage inter-agent coordination and asynchronous communication</li> <li>\ud83c\udf10 Deploy agents across distributed, federated, and heterogeneous resources</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Academy is available on PyPI.</p> <pre><code>pip install academy-py\n</code></pre>"},{"location":"#example","title":"Example","text":"<p>Agents in Academy are defined by an <code>Agent</code> class containing <code>@action</code>-decorated methods that can be invoked by users or peer agents and <code>@loop</code>-decorated methods that execute the autonomous control loops of the agent.</p> <p>The below sensor monitoring agent periodically reads a sensor in the <code>monitor()</code> loop and processes the reading if a threshold is met. Users or agents can invoke the <code>get_last_reading()</code> and <code>set_process_threshold()</code> actions remotely to interact with the monitor agent.</p> <pre><code>import asyncio\nfrom academy.agent import Agent, action, loop\n\nclass SensorMonitorAgent(Agent):\n    def __init__(self) -&gt; None:\n        super().__init__()\n        self.last_reading: float | None = None\n        self.process_threshold: float = 1.0\n\n    @action\n    async def get_last_reading(self) -&gt; float | None:\n        return self.last_reading\n\n    @action\n    async def set_process_threshold(self, value: float) -&gt; None:\n        self.process_threshold = value\n\n    @loop\n    async def monitor(self, shutdown: asyncio.Event) -&gt; None:\n        while not shutdown.is_set():\n            value = await read_sensor_data()\n            self.last_reading = value:\n            if value &gt;= self.process_threshold:\n                await process_reading(value)\n            await asyncio.sleep(1)\n</code></pre> <p>Users and agents communicate asynchronously through handles, sending messages to and receiving messages from a mailbox managed by an exchange. The manager abstracts the remote execution and management of agents using executors.</p> <pre><code>from academy.exchange import LocalExchangeFactory\nfrom academy.manager import Manager\nfrom concurrent.futures import ThreadPoolExecutor\n\nasync with await Manager.from_exchange_factory(\n    factory=LocalExchangeFactory(),  # Replace with other implementations\n    executors=ThreadPoolExecutor(),  # for distributed deployments\n) as manager:\n    agent_handle = await manager.launch(SensorMonitorAgent)\n\n    await agent_handle.set_process_threshold(2.0)\n    await asyncio.sleep(5)\n    value = await agent_handle.get_last_reading()\n    print(value)\n\n    await manager.shutdown(agent_handle, blocking=True)\n</code></pre> <p>Learn more about Academy in Getting Started.</p>"},{"location":"#what-can-be-an-agent","title":"What can be an agent?","text":"<p>In Academy, an agent is a primitive entity that (1) has internal state, (2) performs actions, and (3) communicates with other agents.</p> <p>This allows for range of agent implementations\u2014Academy agents are building blocks for constructing more complex agent-based systems.</p> <p>For example, Academy can be use to create the following:</p> <ul> <li>Stateful Actors: Actors manage their own data and respond to requests in a distributed system.</li> <li>LLM Agents: Integrate LLM-based reasoning and tool calling.</li> <li>Embodied Agents: The \"brain\" controlling a robot or simulated entity where action are translated into motor commands or environment manipulations.</li> <li>Computational Units: Encapsulate a specific computational task, like running a simulation, processing data, or training a machine learning model.</li> <li>Orchestrators: Manage or coordinate the activities of other agents, distributing tasks and monitoring progress.</li> <li>Data Interfaces: Interact with external data sources, such as databases, file systems, or sensors, providing a consistent interface for data access and manipulation.</li> </ul>"},{"location":"#why-academy","title":"Why Academy?","text":"<p>Academy offers a powerful and flexible framework for building sophisticated, distributed agent-based systems, particularly well-suited for the complexities of scientific applications. Here's what makes Academy valuable:</p> <ul> <li>Stateful Agents: Academy enables agents to maintain state, which is crucial for managing long-running processes, tracking context across steps, and implementing agents that need to \"remember\" information.</li> <li>Agent Autonomy: Academy allows agents to have autonomous control loops, empowering them to make decisions, react to events, and execute tasks independently.</li> <li>Flexible Deployment: Academy provides tools for managing agent deployment, communication, and coordination in complex environments such that applications can leverage heterogeneous, distributed, and federated resources.</li> <li>Foundation for Sophisticated Applications: Academy primitives offer a strong foundation for building highly specialized and sophisticated agent-based systems that go beyond standard LLM use cases, allowing for fine-grained control and optimization tailored to specific scientific applications.</li> </ul>"},{"location":"#citation","title":"Citation","text":"<p>The Academy preprint is available on arXiv.</p> <pre><code>@misc{pauloski2025academy,\n    title = {{E}mpowering {S}cientific {W}orkflows with {F}ederated {A}gents},\n    author = {J. Gregory Pauloski and Yadu Babuji and Ryan Chard and Mansi Sakarvadia and Kyle Chard and Ian Foster},\n    archivePrefix = {arXiv},\n    eprint = {2505.05428},\n    primaryClass = {cs.MA},\n    url = {https://arxiv.org/abs/2505.05428},\n    year = {2025},\n}\n</code></pre>"},{"location":"best-practices/","title":"Best Practices","text":""},{"location":"best-practices/#avoid-blocking-calls-in-async-agent-methods","title":"Avoid blocking calls in async agent methods","text":"<p>When writing methods on an <code>Agent</code> that use <code>async def</code>, such as <code>@action</code> and <code>@loop</code> methods, avoid calling long-running or blocking synchronous functions directly. Doing so will block the entire asyncio event loop, degrading the responsiveness and concurrency of your agent.</p> <p>To safely run synchronous (blocking) code inside async methods, use <code>Agent.agent_run_sync()</code> which runs the function in a separate thread, keeping the event loop free to do other work. <pre><code>@action\nasync def do_work(self) -&gt; None:\n    result = await self.agent_run_sync(expensive_sync_func)\n    ...\n</code></pre></p>"},{"location":"best-practices/#avoid-communication-operations-during-agent-initialization","title":"Avoid communication operations during agent initialization","text":"<p>The <code>__init__</code> method of an <code>Agent</code> is called in one of two places:</p> <ol> <li>On the client when submitting an agent to be executed.</li> <li>On the worker when agent instantiation is deferred.</li> </ol> <p>In both scenarios, it is unsafe to perform communication operations (i.e., invoking an action on a remote agent) in <code>__init__</code> because connection resources and background tasks have not yet been initialized.</p> <p>The <code>Agent.agent_on_startup()</code> callback can be used instead to perform communication once the agent is in a running state.</p> <p>Warning</p> <p>Be careful when invoking actions on remote agents from the on startup callback. An agent will not process incoming action requests until after <code>Agent.agent_on_startup()</code> has completed. This can cause deadlocks when Agent A's startup callback makes a request to Agent B and then Agent B makes a request back to Agent A.</p>"},{"location":"contributing/","title":"Contributing","text":"<p>We welcome contributions to Academy! This guide covers all of the basics required to get started contributing to the project.</p>"},{"location":"contributing/#issues","title":"Issues","text":"<p>We use GitHub issues to report problems, request and track changes, and discuss future ideas. Please use the Issue Tracker and follow the template.</p>"},{"location":"contributing/#pull-requests","title":"Pull Requests","text":"<p>Please create an issue to discuss changes before creating pull requests, unless the change is for something trivial like a typo or docs change.</p> <p>We use the standard GitHub contribution cycle where all contributions are made via pull requests (including code owners!).</p> <ol> <li>Fork the repository and clone to your local machine.</li> <li>Create a branch for your changes using a descriptive name for the change, such as the issue being addressed.    <pre><code>git checkout -b {user}-issue-{xx}\n</code></pre></li> <li>Create your changes.<ul> <li>Changes should conform to the style and testing guidelines, described below.</li> <li>Keep commits focused and use clear messages.</li> <li>Avoid committing unrelated changes in the same PR.</li> </ul> </li> <li>Test your changes.</li> <li>Commit your changes and push your branch.</li> <li>Open a pull request in this repository, fill out the PR template, and link any relevant issues.</li> </ol>"},{"location":"contributing/#developing","title":"Developing","text":""},{"location":"contributing/#installation-and-setup","title":"Installation and Setup","text":"<p>You will need a supported version of Python and git to get started for local development.</p> <p>First, fork the repository on GitHub and clone your fork locally. <pre><code>$ git clone https://github.com/&lt;USER&gt;/academy\n$ cd academy\n</code></pre></p> <p>Then, create a virtual environment and install the development and documentation dependencies. <pre><code>$ python -m venv venv\n$ . venv/bin/activate\n$ pip install -e .[dev,docs]\n</code></pre></p>"},{"location":"contributing/#linting-and-type-checking","title":"Linting and Type Checking","text":"<p>We use pre-commit to run linters and static type checkers. Install the pre-commit hook and run against files: <pre><code>$ pre-commit install\n$ pre-commit run --all-files\n</code></pre></p>"},{"location":"contributing/#testing","title":"Testing","text":"<p>The entire CI workflow can be run with <code>$ tox</code>. This will test against multiple versions of Python and can be slow.</p> <p>Module-level unit-test are located in the <code>tests/unit</code> directory and its structure is intended to match that of <code>academy/</code>. E.g. the tests for <code>academy/x/y.py</code> are located in <code>tests/unit/x/y_test.py</code>; however, additional test files can be added as needed. Tests should be narrowly focused and target a single aspect of the code's functionality, tests should not test internal implementation details of the code, and tests should not be dependent on the order in which they are run.</p> <pre><code># Run all unit tests\n$ tox -e py313\n# Run a specific unit test\n$ tox -e py313 -- tests/unit/x/y_test.py::test_z\n</code></pre> <p>Code that is useful for building tests but is not a test itself belongs in the <code>testing/</code> directory.</p> <p>Integration tests are located in <code>tests/integration</code>, and each file contains one integration test.</p> <pre><code># Run all integration testts\n$ tox -e py313-integration\n</code></pre>"},{"location":"contributing/#docs","title":"Docs","text":"<p>If code changes require an update to the documentation (e.g., for function signature changes, new modules, etc.), the documentation can be built using MKDocs.</p> <pre><code># Manually\n$ pip install -e .[docs] # If you skipped this step earlier\n$ mkdocs build --strict  # Build only to site/index.html\n$ mkdocs serve           # Serve locally\n\n# With tox (will only build, does not serve)\n$ tox -e docs\n</code></pre>"},{"location":"contributing/#style-guide","title":"Style Guide","text":"<p>The Python code and docstring format mostly follows Google's Python Style Guide, but the pre-commit config is the authoritative source for code format compliance.</p> <p>Tips:</p> <ul> <li>Avoid redundant comments---write why and not what.</li> <li>Keep comments and docstrings up-to-date when changing functions and classes.</li> <li>Don't include unrelated formatting or refactors in a feature PR.</li> <li>Prefer pure functions where possible.</li> <li>Define all class attributes inside <code>__init__</code> so all attributes are visible in one place.   Attributes that are defined later can be set as <code>None</code> as a placeholder.</li> <li>Prefer f-strings (<code>f'name: {name}</code>) over string format (<code>'name: {}'.format(name)</code>).   Never use the <code>%</code> operator.</li> <li>Prefer typing.NamedTuple over collections.namedtuple.</li> <li>Use sentence case for error and log messages, but only include punctuation for errors.   <pre><code>logger.info(f'new connection opened to {address}')\nraise ValueError('Name must contain alphanumeric characters only.')\n</code></pre></li> <li>Document all exceptions that may be raised by a function in the docstring.</li> </ul>"},{"location":"faq/","title":"Frequently Asked Questions","text":"<p>Open a new issue if you have a question not answered in the docs.</p>"},{"location":"faq/#logging","title":"Logging","text":""},{"location":"faq/#how-to-enable-agent-logging-in-the-manager","title":"How to enable agent logging in the Manager?","text":"<p>The <code>Manager</code> does not configure logging when an agent starts on a worker within an executor. We recommend using the worker initialization features of executors to configure logging, such as by calling <code>init_logging()</code> or <code>logging.basicConfig()</code>. For example, use the <code>initializer</code> argument when using a <code>ProcessPoolExecutor</code>.</p> <pre><code>import logging\nimport multiprocessing\nfrom concurrent.futures import ProcessPoolExecutor\nfrom academy.logging import init_logging\nfrom academy.manager import Manager\n\nmp_context = multiprocessing.get_context('spawn')\nexecutor = ProcessPoolExecutor(\n    max_workers=3,\n    initializer=init_logging,\n    initargs=(logging.INFO,),\n    mp_context=mp_context,\n)\n\nasync with await Manager(..., executors=executor) as manager:\n    ...\n</code></pre>"},{"location":"get-started/","title":"Getting Started","text":""},{"location":"get-started/#installation","title":"Installation","text":"<p>You can install Academy with <code>pip</code> or from source. We suggest installing within a virtual environment (e.g., <code>venv</code> or Conda). <pre><code>python -m venv venv\n. venv/bin/activate\n</code></pre></p> <p>Option 1: Install from PyPI: <pre><code>pip install academy-py\n</code></pre></p> <p>Option 2: Install from source: <pre><code>git clone git@github.com:academy-agents/academy\ncd academy\npip install -e .  # -e for editable mode\n</code></pre></p>"},{"location":"get-started/#a-basic-example","title":"A Basic Example","text":"<p>The following script defines, initializes, and launches a simple agent that performs a single action. Click on the plus (<code>+</code>) signs to learn more.</p> example.py<pre><code>import asyncio\nfrom concurrent.futures import ThreadPoolExecutor\nfrom academy.agent import Agent, action\nfrom academy.exchange import LocalExchangeFactory\nfrom academy.logging import init_logging\nfrom academy.manager import Manager\n\nclass ExampleAgent(Agent):  # (1)!\n    @action  # (2)!\n    async def square(self, value: float) -&gt; float:\n        return value * value\n\nasync def main() -&gt; None:\n    init_logging('INFO')\n\n    async with await Manager.from_exchange_factory(  # (3)!\n        factory=LocalExchangeFactory(),  # (4)!\n        executors=ThreadPoolExecutor(),  # (5)!\n    ) as manager:\n        agent_handle = await manager.launch(ExampleAgent())  # (6)!\n\n        result = await agent_handle.square(2)  # (7)!\n        assert result == 4\n\n        await agent_handle.shutdown()  # (8)!\n\nif __name__ == '__main__':\n    asyncio.run(main())\n</code></pre> <ol> <li>Agents are with derived classes of <code>Agent</code>.</li> <li>Async agent methods decorated with <code>@action</code> can be invoked remotely by user programs and other agents. An agent can call action methods on itself as normal methods.</li> <li>The <code>Manager</code> is a high-level interface that reduces boilerplate code when launching and managing agents. It will also manage clean up of resources and shutting down agents when the context manager exits.</li> <li>The local exchange manages message passing between users and agents running in a single process. Factories are used to create clients to the exchange.</li> <li>The manager uses an <code>Executor</code> to run agents concurrently across parallel/distributed resources. Here, a <code>ThreadPoolExecutor</code> runs agents in different threads of the main process.</li> <li>An instantiated agent (here, <code>ExampleAgent</code>) can be launched with <code>Manager.launch()</code>, returning a handle to the remote agent.</li> <li>Interact with running agents via a <code>Handle</code>. Invoking an action returns the result.</li> <li>Agents can be shutdown via a handle or the manager.</li> </ol> <p>Running this script with logging enabled produces the following output: <pre><code>$ python example.py\nINFO (root) Configured logger (stdout-level=INFO, logfile=None, logfile-level=None)\nINFO (academy.manager) Initialized manager (UserId&lt;6e890226&gt;; ThreadExchange&lt;4401447664&gt;)\nINFO (academy.manager) Launched agent (AgentID&lt;ad6faf7e&gt;; Agent&lt;ExampleAgent&gt;)\nINFO (academy.runtime) Running agent (AgentID&lt;ad6faf7e&gt;; Agent&lt;ExampleAgent&gt;)\nINFO (academy.runtime) Shutdown agent (AgentID&lt;ad6faf7e&gt;; Agent&lt;ExampleAgent&gt;)\nINFO (academy.manager) Closed manager (UserId&lt;6e890226&gt;)\n</code></pre></p>"},{"location":"get-started/#control-loops","title":"Control Loops","text":"<p>Control loops define the autonomous behavior of a running agent and are created by decorating a method with <code>@loop</code>.</p> <pre><code>from academy.agent import loop\n\nclass ExampleAgent(Agent):\n    @loop\n    async def counter(self, shutdown: asyncio.Event) -&gt; None:\n        count = 0\n        while not shutdown.is_set():\n            print(f'Count: {count}')\n            count += 1\n            await asyncio.sleep(1)\n</code></pre> <p>All control loops are started in separate tasks in the event loop when an agent is executed, and run until the control loop exits or the agent is shut down, as indicated by the <code>shutdown</code> event. If an agent shuts down before the control loops exit, the corresponding task will be cancelled.</p>"},{"location":"get-started/#agent-to-agent-interaction","title":"Agent to Agent Interaction","text":"<p>Agent handles can be passed to other agents to facilitate agent-to-agent interaction. Here, a <code>Coordinator</code> is initialized with handles to two other agents implementing the <code>Lowerer</code> and <code>Reverser</code> agents, respectively.</p> <pre><code>from academy.agent import action\nfrom academy.agent import Agent\nfrom academy.handle import Handle\n\nclass Coordinator(Agent):\n    def __init__(\n        self,\n        lowerer: Handle[Lowerer],\n        reverser: Handle[Reverser],\n    ) -&gt; None:\n        super().__init__()\n        self.lowerer = lowerer\n        self.reverser = reverser\n\n    @action\n    async def process(self, text: str) -&gt; str:\n        text = await self.lowerer.lower(text)\n        text = await self.reverser.reverse(text)\n        return text\n\n\nclass Lowerer(Agent):\n    @action\n    async def lower(self, text: str) -&gt; str:\n        return text.lower()\n\n\nclass Reverser(Agent):\n    @action\n    async def reverse(self, text: str) -&gt; str:\n        return text[::-1]\n</code></pre> <p>After launching the <code>Lowerer</code> and <code>Reverser</code>, the respective handles can be used to initialize the <code>Coordinator</code> before launching it.</p> <pre><code>import asyncio\nfrom concurrent.futures import ThreadPoolExecutor\nfrom academy.agent import Agent, action\nfrom academy.exchange import LocalExchangeFactory\nfrom academy.logging import init_logging\nfrom academy.manager import Manager\n\nasync def main() -&gt; None:\n    init_logging(logging.INFO)\n\n    async with await Manager.from_exchange_factory(\n        factory=LocalExchangeFactory(),\n        executors=ThreadPoolExecutor(),\n    ) as manager:\n        lowerer = await manager.launch(Lowerer)\n        reverser = await manager.launch(Reverser)\n        coordinator = await manager.launch(\n            Coordinator,\n            args=(lowerer, reverser),\n        )\n\n        text = 'DEADBEEF'\n        expected = 'feebdaed'\n\n        logger.info('Invoking process(\"%s\") on %s', text, coordinator.agent_id)\n        result = await coordinator.process(text)\n        assert result == expected\n        logger.info('Received result: \"%s\"', result)\n\nif __name__ == '__main__':\n    asyncio.run(main())\n</code></pre>"},{"location":"get-started/#distributed-execution","title":"Distributed Execution","text":"<p>The prior examples have launched agent in threads of the main process, but in practice agents are launched in different processes, possibly on the same node or remote nodes. The prior example can be executed in a distributed fashion by changing the executor and exchange to implementations which support distributed execution. Below, a Redis server server (via the redis exchange) is used to support messaging between distributed agents executed with a <code>ProcessPoolExecutor</code>.</p> <pre><code>from concurrent.futures import ProcessPoolExecutor\nfrom academy.exchange import RedisExchangeFactory\n\nasync def main() -&gt; None:\n    async with Manager.from_exchange_factory(\n        exchange=RedisExchangeFactory('&lt;REDIS HOST&gt;', port=6379),\n        executors=ProcessPoolExecutor(max_processes=4),\n    ) as manager:\n        ...\n</code></pre>"},{"location":"migration/","title":"Migration Guide","text":"<p>This guide helps users adapt to breaking changes introduced during the v0.X development cycle, such as:</p> <ul> <li>Changes to APIs, behavior, or configuration that require user action</li> <li>Deprecated or removed features</li> <li>Recommended steps for upgrading between versions</li> </ul> <p>We provide migration notes for each v0.X release to make upgrades easier during this early phase of development. After v1.0, this guide will be retired. All future changes\u2014including breaking changes and deprecations\u2014will be documented in the project changelog.</p> <p>Please refer to our Version Policy for more details on when we make breaking changes.</p>"},{"location":"migration/#academy-v03","title":"Academy v0.3","text":""},{"location":"migration/#handle-types-have-been-simplified","title":"Handle types have been simplified","text":"<p>The <code>Handle</code> protocol and <code>UnboundRemoteHandle</code> types have been removed. <code>RemoteHandle</code> has been renamed <code>Handle</code> and is the only handle type used in typical Academy applications. <code>ProxyHandle</code>, useful when writing agent unit tests, is now a subclass of <code>Handle</code>.</p>"},{"location":"migration/#handles-are-now-free-from-exchange-clients","title":"Handles are now free from exchange clients","text":"<p>Previously, handles were bound to a specific <code>ExchangeClient</code>, which was used for sending and receiving messages. This required handles to be re-bound to the appropriate exchange client based on the context. Thus, when an agent started it would search the instance attributes of the agent for all handles and replace them at runtime with new handles bound to the agent's exchange client. This approach resulted in many edge cases where handles would not be discovered and replaced appropriately.</p> <p>Now, a <code>Handle</code> determines the correct <code>ExchangeClient</code> from context variables. This exchange context variable is set when running an agent, or on the user-side when using the <code>Manager</code> or <code>ExchangeClient</code> context managers. As a result, it is now safe to instantiate new handles directly inside an agent using only the ID of the peer agent. <pre><code>from academy.agent import Agent, action\nfrom academy.handle import Handle\n\nclass MyAgent(Agent):\n    @action\n    async def dispatch(self) -&gt; None:\n        handle = Handle(peer_agent_id)\n        await handle.do_work()\n</code></pre></p> <p>It is highly recommended to use the <code>Manager</code> and <code>ExchangeClient</code> as context managers, otherwise <code>Handle</code> operations will raise <code>ExchangeClientNotFoundError</code>. Alternatively, a default exchange client can be explicitly set: <code>Handle(agent_id, exchange=&lt;exchange_client&gt;)</code>. In very specific cases, <code>ignore_context=True</code> can be used to force the handle to use the provided exchange client, entirely ignoring the client configured for the current context.</p>"},{"location":"migration/#handle-actions-are-blocking-by-default","title":"Handle actions are blocking by default","text":"<p>Previously, invoking an action on a <code>Handle</code> returned a <code>Future</code> to the result. This resulted in verbose syntax when the result was immediately needed: <pre><code>future = await handle.get_count()\nresult = await future\n# or\nresult = await (await handle.get_count())\n</code></pre></p> <p>Now, action requests block and return the final result of the action: <pre><code>result = await handle.get_count()\n</code></pre> Code that wants to submit the request and later block on it can create a <code>Task</code>. <pre><code>task = asyncio.create_task(handle.get_count())\n# ... do other work ...\nawait task\nprint(task.result())\n</code></pre> Using tasks is especially useful when launching multiple long-running actions concurrently and waiting for them in a flexible manner. For example, instead of waiting for each action sequentially, you can start them all at once and then wait for them to complete using <code>asyncio.wait()</code> or <code>asyncio.as_completed()</code>.</p>"},{"location":"migration/#exchange-implementation-re-exports","title":"Exchange implementation re-exports","text":"<p>All of the <code>ExchangeFactory</code> and <code>ExchangeTransport</code> implementations have been re-exported from <code>academy.exchange</code>. <code>spawn_http_exchange</code> has been re-exported from <code>academy.exchange.cloud</code>.</p>"},{"location":"migration/#academy-v02","title":"Academy v0.2","text":""},{"location":"migration/#academy-is-now-async-first","title":"Academy is now async-first","text":"<p>Academy is now an async-first library. The asyncio model is better aligned with the highly asynchronous programming model of Academy. Agent actions and control loops are now executed in the event loop of the main thread, rather than in separate threads. All exchanges and the manager are async now.</p>"},{"location":"migration/#renamed-components","title":"Renamed components","text":"<p>Entities are now referred to as agents and users (previously, clients). Agents are now derived from <code>Agent</code> (previously, <code>Behavior</code>) and run using a <code>Runtime</code> (previously, <code>Agent</code>).</p> <p>Summary:</p> <ul> <li><code>academy.agent.Agent</code> is renamed <code>academy.runtime.Runtime</code>.</li> <li><code>academy.behavior.Behavior</code> is renamed <code>academy.agent.Agent</code>.</li> <li><code>academy.identifier.ClientId</code> is renamed <code>academy.identifier.UserId</code>.</li> </ul>"},{"location":"migration/#changes-to-agents","title":"Changes to agents","text":"<p>All special methods provided by <code>Agent</code> are named <code>agent_.*</code>. For example, the startup and shutdown callbacks have been renamed:</p> <ul> <li><code>Agent.on_setup</code> is renamed <code>Agent.agent_on_startup</code></li> <li><code>Agent.on_shutdown</code> is renamed <code>Agent.agent_on_shutdown</code></li> </ul> <p>Runtime context is now available via additional methods.</p>"},{"location":"migration/#changes-to-exchanges","title":"Changes to exchanges","text":"<p>The <code>Exchange</code> and <code>Mailbox</code> protocols have been merged into a single <code>ExchangeClient</code> which comes in two forms:</p> <ul> <li><code>AgentExchangeClient</code></li> <li><code>UserExchangeClient</code></li> </ul> <p>Thus, an <code>ExchangeClient</code> has a 1:1 relationship with the mailbox of a single entity. Each <code>ExchangeClient</code> is initialized using a <code>ExchangeTransport</code>. This protocol defines low-level client interaction with the exchange. Some of the exchange operations have have been changed:</p> <ul> <li><code>register_client()</code> has been removed</li> <li><code>send()</code> no longer takes a <code>dest</code> parameter</li> <li><code>status()</code> has been added</li> </ul> <p>Exchange clients are created using a factory pattern:</p> <ul> <li><code>ExchangeFactory.create_agent_client()</code></li> <li><code>ExchangeFactory.create_user_client()</code></li> </ul> <p>All exchange implementations have been updated to provide a custom transport and factory implementation. The \"thread\" exchange has been renamed to \"local\" now that Academy is async.</p> <p>All exchange related errors derive from <code>ExchangeError</code>. <code>MailboxClosedError</code> is renamed <code>MailboxTerminatedError</code> with derived types for <code>AgentTerminatedError</code> and <code>UserTerminatedError</code>.</p>"},{"location":"migration/#changes-to-the-manager-and-launchers","title":"Changes to the manager and launchers","text":"<p>The <code>Launcher</code> protocol and implementations have been removed, with their functionality incorporated directly into the <code>Manager</code>.</p> <p>Summary:</p> <ul> <li><code>Manager</code> is now initialized with one or more <code>Executors</code>.</li> <li>Added the <code>Manager.from_exchange_factory()</code> class method.</li> <li><code>Manager.set_default_launcher()</code> and <code>Manager.add_launcher()</code> are renamed <code>set_default_executor()</code> and <code>add_executor()</code>, respectively.</li> <li><code>Manager</code> exposes <code>get_handle()</code> and <code>register_agent()</code>.</li> <li><code>Manager.launch()</code> now optionally takes an <code>Agent</code> type and args/kwargs and will defer agent initialization to on worker.</li> <li><code>Manager.wait()</code> now takes an iterable of agent IDs or handles.</li> </ul>"},{"location":"version-policy/","title":"Version Policy","text":"<p>We follow Semantic Versioning (SemVer), with adjustments for pre-1.0 development. Documentation is versioned to match the software and help users find information relevant to the version they are using.</p>"},{"location":"version-policy/#versioning-rules","title":"Versioning Rules","text":"<ul> <li><code>MAJOR.MINOR.PATCH</code> format</li> <li>While the project is in major version 0, breaking changes may occur in minor releases</li> <li>After 1.0, breaking changes will only occur in MAJOR versions</li> </ul>"},{"location":"version-policy/#documentation-versions","title":"Documentation Versions","text":"<p>Documentation is published under version-specific URLs such as:</p> <ul> <li><code>/latest</code> and <code>/main</code> \u2013 Tracks the main branch with unreleased changes</li> <li><code>/stable</code> \u2013 Tracks the most recent release version (default redirect)</li> <li><code>/0.2.0</code> \u2013 Previous release version</li> </ul>"},{"location":"version-policy/#deprecation-policy","title":"Deprecation Policy","text":"<p>We aim to provide advance notice before removing or changing functionality that may impact users.</p> <p>Before 1.0: Because the project is in active development, features may be changed or removed in any minor release without formal deprecation.</p> <p>After 1.0: Features will be marked as deprecated at least one MINOR version before being removed in a future MAJOR release. Deprecations will be noted in the documentation and changelog. Where applicable, documentation will offer guidance for migration or alternatives. Deprecation warnings may be included in the user interface, API responses, logs, or CLI output depending on the component.</p>"},{"location":"api/","title":"academy","text":"<code>academy/__init__.py</code>"},{"location":"api/SUMMARY/","title":"SUMMARY","text":"<ul> <li>academy</li> <li>academy.agent</li> <li>academy.context</li> <li>academy.debug</li> <li>academy.event</li> <li>academy.exception</li> <li>academy.exchange<ul> <li>client</li> <li>cloud<ul> <li>app</li> <li>authenticate</li> <li>backend</li> <li>client</li> <li>client_info</li> <li>config</li> <li>globus</li> <li>login</li> <li>scopes</li> <li>token_store</li> </ul> </li> <li>factory</li> <li>hybrid</li> <li>local</li> <li>proxystore</li> <li>redis</li> <li>transport</li> </ul> </li> <li>academy.handle</li> <li>academy.identifier</li> <li>academy.logging</li> <li>academy.manager</li> <li>academy.message</li> <li>academy.mypy_plugin</li> <li>academy.runtime</li> <li>academy.serialize</li> <li>academy.socket</li> <li>academy.state</li> <li>academy.task</li> </ul>"},{"location":"api/agent/","title":"academy.agent","text":"<code>academy/agent.py</code>"},{"location":"api/agent/#academy.agent.AgentT","title":"AgentT  <code>module-attribute</code>","text":"<pre><code>AgentT = TypeVar('AgentT', bound='Agent')\n</code></pre> <p>Type variable bound to <code>Agent</code>.</p>"},{"location":"api/agent/#academy.agent.ActionDescription","title":"ActionDescription  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Typed description of an action.</p> <p>Fields:</p> <ul> <li> <code>name</code>                 (<code>str</code>)             </li> <li> <code>type_signature</code>                 (<code>dict[str, str]</code>)             </li> <li> <code>doc</code>                 (<code>str</code>)             </li> </ul>"},{"location":"api/agent/#academy.agent.AgentDescription","title":"AgentDescription  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Typed description of an Agent.</p> <p>Fields:</p> <ul> <li> <code>description</code>                 (<code>str</code>)             </li> <li> <code>actions</code>                 (<code>dict[str, ActionDescription]</code>)             </li> </ul>"},{"location":"api/agent/#academy.agent.Action","title":"Action","text":"<p>               Bases: <code>Generic[P, R_co]</code>, <code>Protocol</code></p> <p>Action method protocol.</p>"},{"location":"api/agent/#academy.agent.Action.__call__","title":"__call__  <code>async</code>","text":"<pre><code>__call__(*arg: args, **kwargs: kwargs) -&gt; R_co\n</code></pre> <p>Expected signature of methods decorated as an action.</p> <p>In general, action methods can implement any signature.</p> Source code in <code>academy/agent.py</code> <pre><code>async def __call__(self, *arg: P.args, **kwargs: P.kwargs) -&gt; R_co:\n    \"\"\"Expected signature of methods decorated as an action.\n\n    In general, action methods can implement any signature.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/agent/#academy.agent.ControlLoop","title":"ControlLoop","text":"<p>               Bases: <code>Protocol</code></p> <p>Control loop method protocol.</p>"},{"location":"api/agent/#academy.agent.ControlLoop.__call__","title":"__call__  <code>async</code>","text":"<pre><code>__call__(shutdown: Event) -&gt; None\n</code></pre> <p>Expected signature of methods decorated as a control loop.</p> <p>Parameters:</p> <ul> <li> <code>shutdown</code>               (<code>Event</code>)           \u2013            <p>Event indicating that the agent has been instructed to shutdown and all control loops should exit.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>Control loops should not return anything.</p> </li> </ul> Source code in <code>academy/agent.py</code> <pre><code>async def __call__(self, shutdown: asyncio.Event) -&gt; None:\n    \"\"\"Expected signature of methods decorated as a control loop.\n\n    Args:\n        shutdown: Event indicating that the agent has been instructed to\n            shutdown and all control loops should exit.\n\n    Returns:\n        Control loops should not return anything.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/agent/#academy.agent.Agent","title":"Agent","text":"<pre><code>Agent()\n</code></pre> <p>Agent base class.</p> <p>An agent is composed of three parts:</p> <ol> <li>The <code>agent_on_startup()</code> and    <code>agent_on_shutdown()</code> methods    define callbacks that are invoked once at the start and end of an    agent's execution, respectively. The methods should be used to    initialize and cleanup stateful resources. Resource initialization    should not be performed in <code>__init__</code>.</li> <li>Action methods annotated with <code>@action</code>    are methods that other agents can invoke on this agent. An agent    may also call it's own action methods as normal methods.</li> <li>Control loop methods annotated with <code>@loop</code>    are executed in separate threads when the agent is executed.</li> </ol> <p>The <code>Runtime</code> is used to execute an agent definition.</p> Warning <p>This class cannot be instantiated directly and must be subclassed.</p> Source code in <code>academy/agent.py</code> <pre><code>def __init__(self) -&gt; None:\n    self.__agent_context: AgentContext[Self] | None = None\n    self.__agent_run_sync_semaphore: asyncio.Semaphore | None = None\n    self.__manager: m.Manager[Any] | None = None\n</code></pre>"},{"location":"api/agent/#academy.agent.Agent.agent_context","title":"agent_context  <code>property</code>","text":"<pre><code>agent_context: AgentContext[Self]\n</code></pre> <p>Agent runtime context.</p> <p>Raises:</p> <ul> <li> <code>AgentNotInitializedError</code>             \u2013            <p>If the agent runtime implementing this agent has not been started.</p> </li> </ul>"},{"location":"api/agent/#academy.agent.Agent.agent_id","title":"agent_id  <code>property</code>","text":"<pre><code>agent_id: AgentId[Self]\n</code></pre> <p>Agent Id.</p> <p>Raises:</p> <ul> <li> <code>AgentNotInitializedError</code>             \u2013            <p>If the agent runtime implementing this agent has not been started.</p> </li> </ul>"},{"location":"api/agent/#academy.agent.Agent.agent_exchange_client","title":"agent_exchange_client  <code>property</code>","text":"<pre><code>agent_exchange_client: AgentExchangeClient[Self, Any]\n</code></pre> <p>Agent exchange client.</p> <p>Raises:</p> <ul> <li> <code>AgentNotInitializedError</code>             \u2013            <p>If the agent runtime implementing this agent has not been started.</p> </li> </ul>"},{"location":"api/agent/#academy.agent.Agent.agent_on_startup","title":"agent_on_startup  <code>async</code>","text":"<pre><code>agent_on_startup() -&gt; None\n</code></pre> <p>Callback invoked at the end of an agent's startup sequence.</p> <p>Control loops will not start and action requests will not be processed until after this callback completes. Thus, it is safe to initialize resources in this callback that are needed by actions or loops.</p> <p>See <code>Runtime.run_until_complete()</code> for more details on the startup sequence.</p> Source code in <code>academy/agent.py</code> <pre><code>async def agent_on_startup(self) -&gt; None:\n    \"\"\"Callback invoked at the end of an agent's startup sequence.\n\n    Control loops will not start and action requests will not be\n    processed until after this callback completes. Thus, it is safe to\n    initialize resources in this callback that are needed by actions or\n    loops.\n\n    See\n    [`Runtime.run_until_complete()`][academy.runtime.Runtime.run_until_complete]\n    for more details on the startup sequence.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/agent/#academy.agent.Agent.agent_on_shutdown","title":"agent_on_shutdown  <code>async</code>","text":"<pre><code>agent_on_shutdown() -&gt; None\n</code></pre> <p>Callback invoked at the beginning of an agent's shutdown sequence.</p> <p>See <code>Runtime.run_until_complete()</code> for more details on the shutdown sequence.</p> Source code in <code>academy/agent.py</code> <pre><code>async def agent_on_shutdown(self) -&gt; None:\n    \"\"\"Callback invoked at the beginning of an agent's shutdown sequence.\n\n    See\n    [`Runtime.run_until_complete()`][academy.runtime.Runtime.run_until_complete]\n    for more details on the shutdown sequence.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/agent/#academy.agent.Agent.agent_run_sync","title":"agent_run_sync  <code>async</code>","text":"<pre><code>agent_run_sync(\n    function: Callable[P, R],\n    /,\n    *args: args,\n    **kwargs: kwargs,\n) -&gt; R\n</code></pre> <p>Run a blocking function in separate thread.</p> Example <pre><code>import time\nfrom academy.agent import Agent, action\n\nclass Example(Agent):\n    def blocking_call(self, value: int) -&gt; int:\n        time.sleep(10)\n        return value\n\n    @action\n    async def non_blocking_call(self, value: int) -&gt; int:\n        result = await self.agent_run_sync(self.blocking_call, value)\n        ...\n        return result\n</code></pre> Note <p>The max concurrency of the executor is configured in the <code>RuntimeConfig</code>. If all executor workers are busy the function will be queued and a warning will be logged.</p> Warning <p>This function does not support cancellation. For example, if you wrap this call in <code>asyncio.wait_for()</code> and a timeout occurs, the task wrapping the coroutine will be cancelled but the blocking function will continue running in its thread until completion.</p> <p>Parameters:</p> <ul> <li> <code>function</code>               (<code>Callable[P, R]</code>)           \u2013            <p>The blocking function to run.</p> </li> <li> <code>*args</code>               (<code>args</code>, default:                   <code>()</code> )           \u2013            <p>Positional arguments for the function.</p> </li> <li> <code>**kwargs</code>               (<code>kwargs</code>, default:                   <code>{}</code> )           \u2013            <p>Keyword arguments for the function.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>R</code>           \u2013            <p>The result of the function call.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>AgentNotInitializedError</code>             \u2013            <p>If the agent runtime has not been started.</p> </li> <li> <code>Exception</code>             \u2013            <p>Any exception raised by the function.</p> </li> </ul> Source code in <code>academy/agent.py</code> <pre><code>async def agent_run_sync(\n    self,\n    function: Callable[P, R],\n    /,\n    *args: P.args,\n    **kwargs: P.kwargs,\n) -&gt; R:\n    \"\"\"Run a blocking function in separate thread.\n\n    Example:\n        ```python\n        import time\n        from academy.agent import Agent, action\n\n        class Example(Agent):\n            def blocking_call(self, value: int) -&gt; int:\n                time.sleep(10)\n                return value\n\n            @action\n            async def non_blocking_call(self, value: int) -&gt; int:\n                result = await self.agent_run_sync(self.blocking_call, value)\n                ...\n                return result\n        ```\n\n    Note:\n        The max concurrency of the executor is configured in the\n        [`RuntimeConfig`][academy.runtime.RuntimeConfig]. If all\n        executor workers are busy the function will be queued and a\n        warning will be logged.\n\n    Warning:\n       This function does not support cancellation. For example, if you\n       wrap this call in [`asyncio.wait_for()`][asyncio.wait_for] and a\n       timeout occurs, the task wrapping the coroutine will be cancelled\n       but the blocking function will continue running in its thread until\n       completion.\n\n    Args:\n        function: The blocking function to run.\n        *args: Positional arguments for the function.\n        **kwargs: Keyword arguments for the function.\n\n    Returns:\n        The result of the function call.\n\n    Raises:\n        AgentNotInitializedError: If the agent runtime has not been\n            started.\n        Exception: Any exception raised by the function.\n    \"\"\"  # noqa: E501\n    executor = self.agent_context.executor\n\n    wrapped = functools.partial(function, *args, **kwargs)\n    loop = asyncio.get_running_loop()\n\n    if self.__agent_run_sync_semaphore is None:\n        max_workers = executor._max_workers\n        self.__agent_run_sync_semaphore = asyncio.Semaphore(max_workers)\n\n    acquired = self.__agent_run_sync_semaphore.locked()\n    if acquired:\n        logger.warning(\n            f'Thread-pool executor for {self.agent_id} is overloaded, '\n            f'sync function \"{function.__name__}\" is waiting for a '\n            'worker',\n            extra={\n                'academy.agent_id': self.agent_id,\n                'academy.function_name': function.__name__,\n            },\n        )\n\n    async with self.__agent_run_sync_semaphore:\n        return await loop.run_in_executor(executor, wrapped)\n</code></pre>"},{"location":"api/agent/#academy.agent.Agent.agent_shutdown","title":"agent_shutdown","text":"<pre><code>agent_shutdown() -&gt; None\n</code></pre> <p>Request the agent to shutdown.</p> <p>Raises:</p> <ul> <li> <code>AgentNotInitializedError</code>             \u2013            <p>If the agent runtime implementing this agent has not been started.</p> </li> </ul> Source code in <code>academy/agent.py</code> <pre><code>def agent_shutdown(self) -&gt; None:\n    \"\"\"Request the agent to shutdown.\n\n    Raises:\n        AgentNotInitializedError: If the agent runtime implementing\n            this agent has not been started.\n    \"\"\"\n    self.agent_context.shutdown_event.set()\n</code></pre>"},{"location":"api/agent/#academy.agent.Agent.agent_launch_alongside","title":"agent_launch_alongside  <code>async</code>","text":"<pre><code>agent_launch_alongside(\n    agent: AgentT | type[AgentT],\n    *,\n    args: tuple[Any, ...] | None = None,\n    kwargs: dict[str, Any] | None = None\n) -&gt; Handle[AgentT]\n</code></pre> <p>Launch a child agent in the current event loop.</p> <p>Parameters:</p> <ul> <li> <code>agent</code>               (<code>AgentT | type[AgentT]</code>)           \u2013            <p>An agent instance to launch, or an agent class to be instantiated before launching using <code>args</code> and <code>kwargs</code>.</p> </li> <li> <code>args</code>               (<code>tuple[Any, ...] | None</code>, default:                   <code>None</code> )           \u2013            <p>Positional arguments used to initialize the agent. Ignored if <code>agent</code> is already an instance.</p> </li> <li> <code>kwargs</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Keyword arguments used to initialize the agent. Ignored if <code>agent</code> is already an instance.</p> </li> </ul> Source code in <code>academy/agent.py</code> <pre><code>async def agent_launch_alongside(\n    self,\n    agent: AgentT | type[AgentT],\n    *,\n    args: tuple[Any, ...] | None = None,\n    kwargs: dict[str, Any] | None = None,\n) -&gt; Handle[AgentT]:\n    \"\"\"Launch a child agent in the current event loop.\n\n    Args:\n        agent: An agent instance to launch, or an agent class to be\n            instantiated before launching using `args` and `kwargs`.\n        args: Positional arguments used to initialize the agent.\n            Ignored if `agent` is already an instance.\n        kwargs: Keyword arguments used to initialize the agent.\n            Ignored if `agent` is already an instance.\n    \"\"\"\n    return await self._agent_manager.launch(\n        agent,\n        args=args,\n        kwargs=kwargs,\n        executor='event_loop',\n    )\n</code></pre>"},{"location":"api/agent/#academy.agent.Agent.agent_describe","title":"agent_describe  <code>async</code>","text":"<pre><code>agent_describe() -&gt; AgentDescription\n</code></pre> <p>Returns a description of the agent.</p> <p>Returns:</p> <ul> <li> <code>AgentDescription</code>           \u2013            <p>A AgentDescription created from the class documentation.</p> </li> </ul> Source code in <code>academy/agent.py</code> <pre><code>@action\nasync def agent_describe(self) -&gt; AgentDescription:\n    \"\"\"Returns a description of the agent.\n\n    Returns:\n        A AgentDescription created from the class documentation.\n    \"\"\"\n    actions = {\n        name: ActionDescription(\n            name=name,\n            type_signature={\n                field: str(var_type)\n                for field, var_type in get_type_hints(method).items()\n            },\n            doc=method.__doc__,\n        )\n        for name, method in self._agent_actions().items()\n    }\n\n    return AgentDescription(\n        description=self.__doc__,\n        actions=actions,\n    )\n</code></pre>"},{"location":"api/agent/#academy.agent.action","title":"action","text":"<pre><code>action(\n    method: ActionMethod[P, R],\n) -&gt; ActionMethod[P, R]\n</code></pre><pre><code>action(\n    *,\n    allow_protected_name: bool = False,\n    context: bool = False\n) -&gt; Callable[[ActionMethod[P, R]], ActionMethod[P, R]]\n</code></pre> <pre><code>action(\n    method: ActionMethod[P, R] | None = None,\n    *,\n    allow_protected_name: bool = False,\n    context: bool = False\n) -&gt; (\n    ActionMethod[P, R]\n    | Callable[[ActionMethod[P, R]], ActionMethod[P, R]]\n)\n</code></pre> <p>Decorator that annotates a method of a agent as an action.</p> <p>Marking a method of a agent as an action makes the method available to other agents. I.e., peers within a multi-agent system can only invoke methods marked as actions on each other. This enables agents to define \"private\" methods.</p> Example <pre><code>from academy.agent import Agent, action\nfrom academy.context import ActionContext\n\nclass Example(Agent):\n    @action\n    async def perform(self) -&gt; ...:\n        ...\n\n    @action(context=True)\n    async def perform_with_ctx(self, *, context: ActionContext) -&gt; ...:\n        ...\n</code></pre> Warning <p>A warning will be emitted if the decorated method's name clashed with a method of <code>Handle</code> because it would not be possible to invoke this action remotely via attribute lookup on a handle. This warning can be suppressed with <code>allow_protected_name=True</code>, and the action must be invoked via <code>Handle.action()</code>.</p> <p>Parameters:</p> <ul> <li> <code>method</code>               (<code>ActionMethod[P, R] | None</code>, default:                   <code>None</code> )           \u2013            <p>Method to decorate as an action.</p> </li> <li> <code>allow_protected_name</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Allow decorating a method as an action when the name of the method clashes with a protected method name of <code>Handle</code>. This flag silences the emitted warning.</p> </li> <li> <code>context</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Specify that the action method expects a context argument. The <code>context</code> will be provided at runtime as a keyword argument.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If the decorated function is not a coroutine.</p> </li> <li> <code>TypeError</code>             \u2013            <p>If <code>context=True</code> and the method does not have a parameter named <code>context</code> or if <code>context</code> is a positional only argument.</p> </li> </ul> Source code in <code>academy/agent.py</code> <pre><code>def action(\n    method: ActionMethod[P, R] | None = None,\n    *,\n    allow_protected_name: bool = False,\n    context: bool = False,\n) -&gt; ActionMethod[P, R] | Callable[[ActionMethod[P, R]], ActionMethod[P, R]]:\n    \"\"\"Decorator that annotates a method of a agent as an action.\n\n    Marking a method of a agent as an action makes the method available\n    to other agents. I.e., peers within a multi-agent system can only invoke\n    methods marked as actions on each other. This enables agents to\n    define \"private\" methods.\n\n    Example:\n        ```python\n        from academy.agent import Agent, action\n        from academy.context import ActionContext\n\n        class Example(Agent):\n            @action\n            async def perform(self) -&gt; ...:\n                ...\n\n            @action(context=True)\n            async def perform_with_ctx(self, *, context: ActionContext) -&gt; ...:\n                ...\n        ```\n\n    Warning:\n        A warning will be emitted if the decorated method's name clashed\n        with a method of [`Handle`][academy.handle.Handle] because it would\n        not be possible to invoke this action remotely via attribute\n        lookup on a handle. This warning can be suppressed with\n        `allow_protected_name=True`, and the action must be invoked via\n        [`Handle.action()`][academy.handle.Handle.action].\n\n    Args:\n        method: Method to decorate as an action.\n        allow_protected_name: Allow decorating a method as an action when\n            the name of the method clashes with a protected method name of\n            [`Handle`][academy.handle.Handle]. This flag silences the\n            emitted warning.\n        context: Specify that the action method expects a context argument.\n            The `context` will be provided at runtime as a keyword argument.\n\n    Raises:\n        TypeError: If the decorated function is not a coroutine.\n        TypeError: If `context=True` and the method does not have a parameter\n            named `context` or if `context` is a positional only argument.\n    \"\"\"\n\n    def decorator(method_: ActionMethod[P, R]) -&gt; ActionMethod[P, R]:\n        if (\n            not allow_protected_name\n            and method_.__name__ in _get_handle_protected_methods()\n        ):\n            warnings.warn(\n                f'The name of the decorated method is \"{method_.__name__}\" '\n                'which clashes with a protected method of Handle. '\n                'Rename the decorated method to avoid ambiguity when remotely '\n                'invoking it via a handle.',\n                UserWarning,\n                stacklevel=3,\n            )\n\n        if not inspect.iscoroutinefunction(method_):\n            raise TypeError(\n                f'Action method \"{method_.__name__}\" is not a coroutine. '\n                'Did you forget an \"async\" in the method declaration?',\n            )\n\n        # Typing the requirement that if context=True then params P should\n        # contain a keyword argument named \"context\" is not easily annotated\n        # for mypy so instead we check at runtime.\n        if context:\n            sig = inspect.signature(method_)\n            if 'context' not in sig.parameters:\n                raise TypeError(\n                    f'Action method \"{method_.__name__}\" must accept a '\n                    '\"context\" keyword argument when used with '\n                    '@action(context=True).',\n                )\n            if (\n                sig.parameters['context'].kind\n                != inspect.Parameter.KEYWORD_ONLY\n            ):\n                raise TypeError(\n                    'The \"context\" argument to action method '\n                    f'\"{method_.__name__}\" must be a keyword only argument.',\n                )\n\n        method_._agent_method_type = 'action'  # type: ignore[attr-defined]\n        method_._action_method_context = context  # type: ignore[attr-defined]\n        return method_\n\n    if method is None:\n        return decorator\n    else:\n        return decorator(method)\n</code></pre>"},{"location":"api/agent/#academy.agent.loop","title":"loop","text":"<pre><code>loop(method: LoopMethod[AgentT]) -&gt; LoopMethod[AgentT]\n</code></pre> <p>Decorator that annotates a method of a agent as a control loop.</p> <p>Control loop methods of a agent are run as threads when an agent starts. A control loop can run for a well-defined period of time or indefinitely, provided the control loop exits when the <code>shutdown</code> event, passed as a parameter to all control loop methods, is set.</p> Example <pre><code>import asyncio\nfrom academy.agent import Agent, loop\n\nclass Example(Agent):\n    @loop\n    async def listen(self, shutdown: asyncio.Event) -&gt; None:\n        while not shutdown.is_set():\n            ...\n</code></pre> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>if the method signature does not conform to the <code>ControlLoop</code> protocol.</p> </li> </ul> Source code in <code>academy/agent.py</code> <pre><code>def loop(method: LoopMethod[AgentT]) -&gt; LoopMethod[AgentT]:\n    \"\"\"Decorator that annotates a method of a agent as a control loop.\n\n    Control loop methods of a agent are run as threads when an agent\n    starts. A control loop can run for a well-defined period of time or\n    indefinitely, provided the control loop exits when the `shutdown`\n    event, passed as a parameter to all control loop methods, is set.\n\n    Example:\n        ```python\n        import asyncio\n        from academy.agent import Agent, loop\n\n        class Example(Agent):\n            @loop\n            async def listen(self, shutdown: asyncio.Event) -&gt; None:\n                while not shutdown.is_set():\n                    ...\n        ```\n\n    Raises:\n        TypeError: if the method signature does not conform to the\n            [`ControlLoop`][academy.agent.ControlLoop] protocol.\n    \"\"\"\n    method._agent_method_type = 'loop'  # type: ignore[attr-defined]\n\n    found_sig = inspect.signature(method, eval_str=True)\n    expected_sig = inspect.signature(ControlLoop.__call__, eval_str=True)\n\n    if found_sig != expected_sig:\n        raise TypeError(\n            f'Signature of loop method \"{method.__name__}\" is {found_sig} '\n            f'but should be {expected_sig}. If the signatures look the same '\n            'except that types are stringified, try importing '\n            '\"from __future__ import annotations\" at the top of the module '\n            'where the agent is defined.',\n        )\n\n    @functools.wraps(method)\n    async def _wrapped(self: AgentT, shutdown: asyncio.Event) -&gt; None:\n        logger.debug(\n            'Started %r loop for %s',\n            method.__name__,\n            self,\n            extra={'academy.method': method.__name__, 'academy.self': self},\n        )\n        await method(self, shutdown)\n        logger.debug(\n            'Exited %r loop for %s',\n            method.__name__,\n            self,\n            extra={'academy.method': method.__name__, 'academy.self': self},\n        )\n\n    return _wrapped\n</code></pre>"},{"location":"api/agent/#academy.agent.event","title":"event","text":"<pre><code>event(\n    name: str,\n) -&gt; Callable[\n    [Callable[[AgentT], Coroutine[None, None, None]]],\n    LoopMethod[AgentT],\n]\n</code></pre> <p>Decorator that annotates a method of a agent as an event loop.</p> <p>An event loop is a special type of control loop that runs when a <code>asyncio.Event</code> is set. The event is cleared after the loop runs.</p> Example <pre><code>import asyncio\nfrom academy.agent import Agent, timer\n\nclass Example(Agent):\n    def __init__(self) -&gt; None:\n        self.alert = asyncio.Event()\n\n    @event('alert')\n    async def handle(self) -&gt; None:\n        # Runs every time alter is set\n        ...\n</code></pre> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Attribute name of the <code>asyncio.Event</code> to wait on.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>AttributeError</code>             \u2013            <p>Raised at runtime if no attribute named <code>name</code> exists on the agent.</p> </li> <li> <code>TypeError</code>             \u2013            <p>Raised at runtime if the attribute named <code>name</code> is not a <code>asyncio.Event</code>.</p> </li> </ul> Source code in <code>academy/agent.py</code> <pre><code>def event(\n    name: str,\n) -&gt; Callable[\n    [Callable[[AgentT], Coroutine[None, None, None]]],\n    LoopMethod[AgentT],\n]:\n    \"\"\"Decorator that annotates a method of a agent as an event loop.\n\n    An event loop is a special type of control loop that runs when a\n    [`asyncio.Event`][asyncio.Event] is set. The event is cleared\n    after the loop runs.\n\n    Example:\n        ```python\n        import asyncio\n        from academy.agent import Agent, timer\n\n        class Example(Agent):\n            def __init__(self) -&gt; None:\n                self.alert = asyncio.Event()\n\n            @event('alert')\n            async def handle(self) -&gt; None:\n                # Runs every time alter is set\n                ...\n        ```\n\n    Args:\n        name: Attribute name of the [`asyncio.Event`][asyncio.Event]\n            to wait on.\n\n    Raises:\n        AttributeError: Raised at runtime if no attribute named `name`\n            exists on the agent.\n        TypeError: Raised at runtime if the attribute named `name` is not\n            a [`asyncio.Event`][asyncio.Event].\n    \"\"\"\n\n    def decorator(\n        method: Callable[[AgentT], Coroutine[None, None, None]],\n    ) -&gt; LoopMethod[AgentT]:\n        method._agent_method_type = 'loop'  # type: ignore[attr-defined]\n\n        @functools.wraps(method)\n        async def _wrapped(self: AgentT, shutdown: asyncio.Event) -&gt; None:\n            event = getattr(self, name)\n            if not isinstance(event, asyncio.Event):\n                raise TypeError(\n                    f'Attribute {name} of {type(self).__class__} has type '\n                    f'{type(event).__class__}. Expected asyncio.Event.',\n                )\n\n            logger.debug(\n                'Started %r event loop for %s (event: %r)',\n                method.__name__,\n                self,\n                name,\n                extra={\n                    'academy.method': method.__name__,\n                    'academy.self': self,\n                    'academy.event_name': name,\n                },\n            )\n            while not shutdown.is_set():\n                await wait_event_async(shutdown, event)\n                if event.is_set():\n                    try:\n                        await method(self)\n                    finally:\n                        event.clear()\n            logger.debug(\n                'Exited %r event loop for %s',\n                method.__name__,\n                self,\n                extra={\n                    'academy.method': method.__name__,\n                    'academy.self': self,\n                },\n            )\n\n        return _wrapped\n\n    return decorator\n</code></pre>"},{"location":"api/agent/#academy.agent.timer","title":"timer","text":"<pre><code>timer(\n    interval: float | timedelta,\n) -&gt; Callable[\n    [Callable[[AgentT], Coroutine[None, None, None]]],\n    LoopMethod[AgentT],\n]\n</code></pre> <p>Decorator that annotates a method of a agent as a timer loop.</p> <p>A timer loop is a special type of control loop that runs at a set interval. The method will always be called once before the first sleep.</p> Example <pre><code>from academy.agent import Agent, timer\n\nclass Example(Agent):\n    @timer(interval=1)\n    async def listen(self) -&gt; None:\n        # Runs every 1 second\n        ...\n</code></pre> <p>Parameters:</p> <ul> <li> <code>interval</code>               (<code>float | timedelta</code>)           \u2013            <p>Seconds or a <code>timedelta</code> to wait between invoking the method.</p> </li> </ul> Source code in <code>academy/agent.py</code> <pre><code>def timer(\n    interval: float | timedelta,\n) -&gt; Callable[\n    [Callable[[AgentT], Coroutine[None, None, None]]],\n    LoopMethod[AgentT],\n]:\n    \"\"\"Decorator that annotates a method of a agent as a timer loop.\n\n    A timer loop is a special type of control loop that runs at a set\n    interval. The method will always be called once before the first\n    sleep.\n\n    Example:\n        ```python\n        from academy.agent import Agent, timer\n\n        class Example(Agent):\n            @timer(interval=1)\n            async def listen(self) -&gt; None:\n                # Runs every 1 second\n                ...\n        ```\n\n    Args:\n        interval: Seconds or a [`timedelta`][datetime.timedelta] to wait\n            between invoking the method.\n    \"\"\"\n    interval = (\n        interval.total_seconds()\n        if isinstance(interval, timedelta)\n        else interval\n    )\n\n    def decorator(\n        method: Callable[[AgentT], Coroutine[None, None, None]],\n    ) -&gt; LoopMethod[AgentT]:\n        method._agent_method_type = 'loop'  # type: ignore[attr-defined]\n\n        @functools.wraps(method)\n        async def _wrapped(self: AgentT, shutdown: asyncio.Event) -&gt; None:\n            logger.debug(\n                'Started %r timer loop for %s (interval: %fs)',\n                method.__name__,\n                self,\n                interval,\n                extra={\n                    'academy.method': method.__name__,\n                    'academy.self': self,\n                    'academy.interval': interval,\n                },\n            )\n            while not shutdown.is_set():\n                try:\n                    await asyncio.wait_for(shutdown.wait(), timeout=interval)\n                except asyncio.TimeoutError:\n                    await method(self)\n            logger.debug(\n                'Exited %r timer loop for %s',\n                method.__name__,\n                self,\n                extra={\n                    'academy.method': method.__name__,\n                    'academy.self': self,\n                },\n            )\n\n        return _wrapped\n\n    return decorator\n</code></pre>"},{"location":"api/context/","title":"academy.context","text":"<code>academy/context.py</code>"},{"location":"api/context/#academy.context.ActionContext","title":"ActionContext","text":"<pre><code>ActionContext(\n    source_id: EntityId,\n    exchange_client: AgentExchangeClient[Any, Any],\n)\n</code></pre> <p>Action invocation context.</p> Source code in <code>academy/context.py</code> <pre><code>def __init__(\n    self,\n    source_id: EntityId,\n    exchange_client: ae.AgentExchangeClient[Any, Any],\n) -&gt; None:\n    self._source_id = source_id\n    self._exchange_client = exchange_client\n    self._source_handle: Handle[Any] | None = None\n</code></pre>"},{"location":"api/context/#academy.context.ActionContext.source_id","title":"source_id  <code>property</code>","text":"<pre><code>source_id: EntityId\n</code></pre> <p>ID of the source that requested the action.</p>"},{"location":"api/context/#academy.context.ActionContext.source_handle","title":"source_handle  <code>property</code>","text":"<pre><code>source_handle: Handle[Any]\n</code></pre> <p>Get a handle to the source agent of the request.</p> <p>Returns:</p> <ul> <li> <code>Handle[Any]</code>           \u2013            <p>Handle to the agent that made the request.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If the source is a user entity.</p> </li> </ul>"},{"location":"api/context/#academy.context.ActionContext.is_agent_source","title":"is_agent_source","text":"<pre><code>is_agent_source() -&gt; bool\n</code></pre> <p>Is the source an agent.</p> Source code in <code>academy/context.py</code> <pre><code>def is_agent_source(self) -&gt; bool:\n    \"\"\"Is the source an agent.\"\"\"\n    return isinstance(self.source_id, AgentId)\n</code></pre>"},{"location":"api/context/#academy.context.ActionContext.is_user_source","title":"is_user_source","text":"<pre><code>is_user_source() -&gt; bool\n</code></pre> <p>Is the source a user.</p> Source code in <code>academy/context.py</code> <pre><code>def is_user_source(self) -&gt; bool:\n    \"\"\"Is the source a user.\"\"\"\n    return isinstance(self.source_id, UserId)\n</code></pre>"},{"location":"api/context/#academy.context.AgentContext","title":"AgentContext  <code>dataclass</code>","text":"<pre><code>AgentContext(\n    agent_id: AgentId[AgentT],\n    exchange_client: AgentExchangeClient[AgentT, Any],\n    executor: ThreadPoolExecutor,\n    shutdown_event: Event,\n)\n</code></pre> <p>               Bases: <code>Generic[AgentT]</code></p> <p>Agent runtime context.</p>"},{"location":"api/context/#academy.context.AgentContext.agent_id","title":"agent_id  <code>instance-attribute</code>","text":"<pre><code>agent_id: AgentId[AgentT]\n</code></pre> <p>ID of the exchange as registered with the exchange.</p>"},{"location":"api/context/#academy.context.AgentContext.exchange_client","title":"exchange_client  <code>instance-attribute</code>","text":"<pre><code>exchange_client: AgentExchangeClient[AgentT, Any]\n</code></pre> <p>Client used by agent to communicate with the exchange.</p>"},{"location":"api/context/#academy.context.AgentContext.executor","title":"executor  <code>instance-attribute</code>","text":"<pre><code>executor: ThreadPoolExecutor\n</code></pre> <p>Thread-pool executor used for running synchronous tasks.</p>"},{"location":"api/context/#academy.context.AgentContext.shutdown_event","title":"shutdown_event  <code>instance-attribute</code>","text":"<pre><code>shutdown_event: Event\n</code></pre> <p>Shutdown event used to signal the agent to shutdown.</p>"},{"location":"api/debug/","title":"academy.debug","text":"<code>academy/debug.py</code>"},{"location":"api/debug/#academy.debug.set_academy_debug","title":"set_academy_debug","text":"<pre><code>set_academy_debug(debug_mode: bool = True) -&gt; None\n</code></pre> <p>Set academy debug mode.</p> <p>When debug mode is set, errors in critical tasks will raise a SystemExit exception causing the thread to exit. These critical tasks are expected not to raise exceptions, and any exception indicate something within Academy has broken.</p> Source code in <code>academy/debug.py</code> <pre><code>def set_academy_debug(debug_mode: bool = True) -&gt; None:\n    \"\"\"Set academy debug mode.\n\n    When debug mode is set, errors in critical tasks will\n    raise a SystemExit exception causing the thread to exit.\n    These critical tasks are expected not to raise exceptions,\n    and any exception indicate something within Academy has\n    broken.\n    \"\"\"\n    global academy_debug_mode  # noqa: PLW0603\n    academy_debug_mode = debug_mode\n</code></pre>"},{"location":"api/debug/#academy.debug.get_academy_debug","title":"get_academy_debug","text":"<pre><code>get_academy_debug() -&gt; bool\n</code></pre> <p>Fetch academy debug mode.</p> Source code in <code>academy/debug.py</code> <pre><code>def get_academy_debug() -&gt; bool:\n    \"\"\"Fetch academy debug mode.\"\"\"\n    return academy_debug_mode\n</code></pre>"},{"location":"api/event/","title":"academy.event","text":"<code>academy/event.py</code>"},{"location":"api/event/#academy.event.wait_event_async","title":"wait_event_async  <code>async</code>","text":"<pre><code>wait_event_async(\n    *events: Event, timeout: float | None = None\n) -&gt; Event\n</code></pre> <p>Wait for the first async event to be set.</p> <p>Parameters:</p> <ul> <li> <code>events</code>               (<code>Event</code>, default:                   <code>()</code> )           \u2013            <p>One or more events to wait on.</p> </li> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Maximum number of seconds to wait for an event to finish.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Event</code>           \u2013            <p>The first event to finish.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TimeoutError</code>             \u2013            <p>If no event finished within <code>timeout</code> seconds.</p> </li> </ul> Source code in <code>academy/event.py</code> <pre><code>async def wait_event_async(\n    *events: asyncio.Event,\n    timeout: float | None = None,\n) -&gt; asyncio.Event:\n    \"\"\"Wait for the first async event to be set.\n\n    Args:\n        events: One or more events to wait on.\n        timeout: Maximum number of seconds to wait for an event to finish.\n\n    Returns:\n        The first event to finish.\n\n    Raises:\n        TimeoutError: If no event finished within `timeout` seconds.\n    \"\"\"\n    tasks = {\n        asyncio.create_task(\n            event.wait(),\n            name=f'or-event-waiter-{i}',\n        ): event\n        for i, event in enumerate(events)\n    }\n    done, pending = await asyncio.wait(\n        tasks.keys(),\n        timeout=timeout,\n        return_when=asyncio.FIRST_COMPLETED,\n    )\n    for task in pending:\n        task.cancel()\n        with contextlib.suppress(asyncio.CancelledError):\n            await task\n\n    if len(done) == 0:\n        raise TimeoutError(f'No events were set within {timeout} seconds.')\n\n    return tasks[done.pop()]\n</code></pre>"},{"location":"api/exception/","title":"academy.exception","text":"<code>academy/exception.py</code>"},{"location":"api/exception/#academy.exception.ActionCancelledError","title":"ActionCancelledError","text":"<pre><code>ActionCancelledError(name: str)\n</code></pre> <p>               Bases: <code>Exception</code></p> <p>Action was cancelled by the agent.</p> <p>This often happens when an agent is shutdown mid-action execution and configured to cancel running actions.</p> Source code in <code>academy/exception.py</code> <pre><code>def __init__(self, name: str) -&gt; None:\n    super().__init__(f'Action \"{name}\" was cancelled by the agent.')\n    self.name = name\n</code></pre>"},{"location":"api/exception/#academy.exception.AgentNotInitializedError","title":"AgentNotInitializedError","text":"<pre><code>AgentNotInitializedError()\n</code></pre> <p>               Bases: <code>Exception</code></p> <p>Agent runtime context has not been initialized.</p> <p>This error is typically raised when accessing the runtime context for an agent before the agent has been executed.</p> Source code in <code>academy/exception.py</code> <pre><code>def __init__(self) -&gt; None:\n    super().__init__(\n        'Agent runtime context has not been initialized. '\n        'Has the agent been started?',\n    )\n</code></pre>"},{"location":"api/exception/#academy.exception.PingCancelledError","title":"PingCancelledError","text":"<pre><code>PingCancelledError()\n</code></pre> <p>               Bases: <code>Exception</code></p> <p>Ping cancelled before response.</p> <p>This error is typically raised when an agent receives a message before startup, then exits while starting.</p> Source code in <code>academy/exception.py</code> <pre><code>def __init__(self) -&gt; None:\n    super().__init__(\n        'Ping was cancelled. Agent may have exited before starting.',\n    )\n</code></pre>"},{"location":"api/exception/#academy.exception.ExchangeError","title":"ExchangeError","text":"<p>               Bases: <code>Exception</code></p> <p>Base type for exchange related errors.</p>"},{"location":"api/exception/#academy.exception.BadEntityIdError","title":"BadEntityIdError","text":"<pre><code>BadEntityIdError(uid: EntityId)\n</code></pre> <p>               Bases: <code>ExchangeError</code></p> <p>Entity associated with the identifier is unknown.</p> Source code in <code>academy/exception.py</code> <pre><code>def __init__(self, uid: EntityId) -&gt; None:\n    super().__init__(f'Unknown identifier {uid}.')\n    self.uid = uid\n</code></pre>"},{"location":"api/exception/#academy.exception.ForbiddenError","title":"ForbiddenError","text":"<p>               Bases: <code>ExchangeError</code></p> <p>Exchange client does not have permission to access resources.</p>"},{"location":"api/exception/#academy.exception.MessageTooLargeError","title":"MessageTooLargeError","text":"<pre><code>MessageTooLargeError(size: int, limit: int)\n</code></pre> <p>               Bases: <code>ExchangeError</code></p> <p>Message payload is too large for exchange.</p> <p>If encountering this error, consider using the <code>ProxyStoreExchangeTransport</code> class an way to by-pass the exchange for large data.</p> Source code in <code>academy/exception.py</code> <pre><code>def __init__(self, size: int, limit: int) -&gt; None:\n    self.size = size\n    self.limit = limit\n\n    super().__init__(\n        f'Message of size {size} bytes is larger than limit {limit}.',\n    )\n</code></pre>"},{"location":"api/exception/#academy.exception.MailboxTerminatedError","title":"MailboxTerminatedError","text":"<pre><code>MailboxTerminatedError(uid: EntityId)\n</code></pre> <p>               Bases: <code>ExchangeError</code></p> <p>Entity mailbox is terminated and cannot send or receive messages.</p> <p>Constructing this error type implicitly returns one of the derived types, <code>AgentTerminatedError</code> or <code>UserTerminatedError</code>, based on the entity type.</p> Source code in <code>academy/exception.py</code> <pre><code>def __init__(self, uid: EntityId) -&gt; None:\n    super().__init__(f'Mailbox for {uid} has been terminated.')\n    self.uid = uid\n</code></pre>"},{"location":"api/exception/#academy.exception.AgentTerminatedError","title":"AgentTerminatedError","text":"<pre><code>AgentTerminatedError(uid: AgentId[Any])\n</code></pre> <p>               Bases: <code>MailboxTerminatedError</code></p> <p>Agent mailbox is terminated and cannot send or receive messages.</p> Source code in <code>academy/exception.py</code> <pre><code>def __init__(self, uid: AgentId[Any]) -&gt; None:\n    super().__init__(uid)\n</code></pre>"},{"location":"api/exception/#academy.exception.UserTerminatedError","title":"UserTerminatedError","text":"<pre><code>UserTerminatedError(uid: UserId)\n</code></pre> <p>               Bases: <code>MailboxTerminatedError</code></p> <p>User mailbox is terminated and cannot send or receive messages.</p> Source code in <code>academy/exception.py</code> <pre><code>def __init__(self, uid: UserId) -&gt; None:\n    super().__init__(uid)\n</code></pre>"},{"location":"api/exception/#academy.exception.UnauthorizedError","title":"UnauthorizedError","text":"<p>               Bases: <code>ExchangeError</code></p> <p>Exchange client has not provided valid authentication credentials.</p>"},{"location":"api/exception/#academy.exception.ExchangeClientNotFoundError","title":"ExchangeClientNotFoundError","text":"<pre><code>ExchangeClientNotFoundError(aid: AgentId[Any])\n</code></pre> <p>               Bases: <code>Exception</code></p> <p>Handle to agent can not find an exchange client to use.</p> <p>A <code>Handle</code> is initialized with a target agent ID is not used in a context where an exchange client could be inferred. Typically this can be resolved by using a <code>ExchangeClient</code> or <code>Manager</code> as a context manager. If this error happens within an agent, it likely means the agent was not started.</p> Source code in <code>academy/exception.py</code> <pre><code>def __init__(self, aid: AgentId[Any]) -&gt; None:\n    super().__init__(\n        f'Handle to {aid} can not find an exchange client to use. See the '\n        'exception docstring for troubleshooting.',\n    )\n    self.aid = aid\n</code></pre>"},{"location":"api/exception/#academy.exception.raise_exceptions","title":"raise_exceptions","text":"<pre><code>raise_exceptions(\n    exceptions: Iterable[BaseException],\n    *,\n    message: str | None = None\n) -&gt; None\n</code></pre> <p>Raise exceptions as a group.</p> <p>Raises a set of exceptions as an <code>ExceptionGroup</code> in Python 3.11 and later. If only one exception is provided, it is raised directly. In Python 3.10 and older, only one exception is raised.</p> <p>This is a no-op if the size of <code>exceptions</code> is zero.</p> <p>Parameters:</p> <ul> <li> <code>exceptions</code>               (<code>Iterable[BaseException]</code>)           \u2013            <p>An iterable of exceptions to raise.</p> </li> <li> <code>message</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Custom error message for the exception group.</p> </li> </ul> Source code in <code>academy/exception.py</code> <pre><code>def raise_exceptions(\n    exceptions: Iterable[BaseException],\n    *,\n    message: str | None = None,\n) -&gt; None:\n    \"\"\"Raise exceptions as a group.\n\n    Raises a set of exceptions as an [`ExceptionGroup`][ExceptionGroup]\n    in Python 3.11 and later. If only one exception is provided, it is raised\n    directly. In Python 3.10 and older, only one exception is raised.\n\n    This is a no-op if the size of `exceptions` is zero.\n\n    Args:\n        exceptions: An iterable of exceptions to raise.\n        message: Custom error message for the exception group.\n    \"\"\"\n    excs = tuple(exceptions)\n    if len(excs) == 0:\n        return\n\n    if sys.version_info &gt;= (3, 11) and len(excs) &gt; 1:  # pragma: &gt;=3.11 cover\n        message = (\n            message if message is not None else 'Caught multiple exceptions!'\n        )\n        # Note that BaseExceptionGroup will return ExceptionGroup if all\n        # of the errors are Exception, rather than BaseException, so that this\n        # can be caught by \"except Exception\".\n        raise BaseExceptionGroup(message, excs)  # noqa: F821\n    else:  # pragma: &lt;3.11 cover\n        raise excs[0]\n</code></pre>"},{"location":"api/handle/","title":"academy.handle","text":"<code>academy/handle.py</code>"},{"location":"api/handle/#academy.handle.Handle","title":"Handle","text":"<pre><code>Handle(\n    agent_id: AgentId[AgentT],\n    *,\n    exchange: ExchangeClient[Any] | None = None,\n    ignore_context: bool = False\n)\n</code></pre> <p>               Bases: <code>Generic[AgentT]</code></p> <p>Handle to a remote agent.</p> <p>Internally, handles use an <code>ExchangeClient</code> to send requests to and receive responses from the remote agent. By default the correct exchange client is inferred from the context using a context variable (specifically, the <code>academy.handle.exchange_context</code> variable). This allows the same handle to be used in different contexts, automatically using the correct client to send messages.</p> <p>When a handle is used in contexts that have not configured the exchange client (such as outside of an agent runtime or <code>Manager</code>), a default exchange can be provided via the <code>exchange</code> argument. For advanced usage, the <code>ignore_context</code> flag will cause the handle to only use the <code>exchange</code> argument no matter what the current context is.</p> Note <p>The <code>exchange</code> argument will not be included when a handle is pickled. Thus, unpickled handles must be used in a context that configures an exchange client.</p> <p>Parameters:</p> <ul> <li> <code>agent_id</code>               (<code>AgentId[AgentT]</code>)           \u2013            <p>ID of the remote agent.</p> </li> <li> <code>exchange</code>               (<code>ExchangeClient[Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>A default exchange client to be used if an exchange client is not configured in the current context.</p> </li> <li> <code>ignore_context</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Ignore the current context and force use of <code>exchange</code> for communication.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If <code>ignore_context=True</code> but <code>exchange</code> is not provided.</p> </li> </ul> Source code in <code>academy/handle.py</code> <pre><code>def __init__(\n    self,\n    agent_id: AgentId[AgentT],\n    *,\n    exchange: ExchangeClient[Any] | None = None,\n    ignore_context: bool = False,\n) -&gt; None:\n    self.agent_id = agent_id\n    self._exchange = exchange\n    self._registered_exchanges: WeakSet[ExchangeClient[Any]] = WeakSet()\n    self.ignore_context = ignore_context\n\n    if ignore_context and not exchange:\n        raise ValueError(\n            'Cannot initialize handle with ignore_context=True '\n            'and no explicit exchange.',\n        )\n\n    # Unique identifier for each handle object; used to disambiguate\n    # messages when multiple handles are bound to the same mailbox.\n    self.handle_id = uuid.uuid4()\n    self._pending_response_futures: dict[\n        uuid.UUID,\n        asyncio.Future[Any],\n    ] = {}\n    self._shutdown_requests: set[uuid.UUID] = set()\n\n    if self._exchange is not None:\n        self._register_with_exchange(self._exchange)\n</code></pre>"},{"location":"api/handle/#academy.handle.Handle.exchange","title":"exchange  <code>property</code>","text":"<pre><code>exchange: ExchangeClient[Any]\n</code></pre> <p>Exchange client used to send messages.</p> <p>Returns:</p> <ul> <li> <code>ExchangeClient[Any]</code>           \u2013            <p>Exchange client.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ExchangeClientNotFoundError</code>             \u2013            <p>If no exchange client is set in the current context nor was one provided to the handle.</p> </li> </ul>"},{"location":"api/handle/#academy.handle.Handle.action","title":"action  <code>async</code>","text":"<pre><code>action(action: str, /, *args: Any, **kwargs: Any) -&gt; R\n</code></pre> <p>Invoke an action on the agent.</p> <p>Parameters:</p> <ul> <li> <code>action</code>               (<code>str</code>)           \u2013            <p>Action to invoke.</p> </li> <li> <code>args</code>               (<code>Any</code>, default:                   <code>()</code> )           \u2013            <p>Positional arguments for the action.</p> </li> <li> <code>kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Keywords arguments for the action.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>R</code>           \u2013            <p>Result of the action.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>AgentTerminatedError</code>             \u2013            <p>If the agent's mailbox was closed. This typically indicates the agent shutdown for another reason (it self terminated or via another handle).</p> </li> <li> <code>Exception</code>             \u2013            <p>Any exception raised by the action.</p> </li> </ul> Source code in <code>academy/handle.py</code> <pre><code>async def action(self, action: str, /, *args: Any, **kwargs: Any) -&gt; R:\n    \"\"\"Invoke an action on the agent.\n\n    Args:\n        action: Action to invoke.\n        args: Positional arguments for the action.\n        kwargs: Keywords arguments for the action.\n\n    Returns:\n        Result of the action.\n\n    Raises:\n        AgentTerminatedError: If the agent's mailbox was closed. This\n            typically indicates the agent shutdown for another reason\n            (it self terminated or via another handle).\n        Exception: Any exception raised by the action.\n    \"\"\"\n    exchange = self.exchange\n    self._register_with_exchange(exchange)\n\n    request = Message.create(\n        src=exchange.client_id,\n        dest=self.agent_id,\n        label=self.handle_id,\n        body=ActionRequest(action=action, pargs=args, kargs=kwargs),\n    )\n    loop = asyncio.get_running_loop()\n    future: asyncio.Future[R] = loop.create_future()\n    self._pending_response_futures[request.tag] = future\n\n    await self.exchange.send(request)\n    logger.debug(\n        'Sent action request from %s to %s (action=%r)',\n        exchange.client_id,\n        self.agent_id,\n        action,\n        extra=request.log_extra()\n        | {\n            'academy.action': action,\n        },\n    )\n    await future\n    return future.result()\n</code></pre>"},{"location":"api/handle/#academy.handle.Handle.ping","title":"ping  <code>async</code>","text":"<pre><code>ping(*, timeout: float | None = None) -&gt; float\n</code></pre> <p>Ping the agent.</p> <p>Ping the agent and wait to get a response.</p> <p>Parameters:</p> <ul> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional timeout in seconds to wait for the response.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>Round-trip time in seconds.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>AgentTerminatedError</code>             \u2013            <p>If the agent's mailbox was closed. This typically indicates the agent shutdown for another reason (it self terminated or via another handle).</p> </li> <li> <code>TimeoutError</code>             \u2013            <p>If the timeout is exceeded.</p> </li> </ul> Source code in <code>academy/handle.py</code> <pre><code>async def ping(self, *, timeout: float | None = None) -&gt; float:\n    \"\"\"Ping the agent.\n\n    Ping the agent and wait to get a response.\n\n    Args:\n        timeout: Optional timeout in seconds to wait for the response.\n\n    Returns:\n        Round-trip time in seconds.\n\n    Raises:\n        AgentTerminatedError: If the agent's mailbox was closed. This\n            typically indicates the agent shutdown for another reason\n            (it self terminated or via another handle).\n        TimeoutError: If the timeout is exceeded.\n    \"\"\"\n    exchange = self.exchange\n    self._register_with_exchange(exchange)\n\n    request = Message.create(\n        src=exchange.client_id,\n        dest=self.agent_id,\n        label=self.handle_id,\n        body=PingRequest(),\n    )\n    loop = asyncio.get_running_loop()\n    future: asyncio.Future[None] = loop.create_future()\n    self._pending_response_futures[request.tag] = future\n    start = time.perf_counter()\n    await self.exchange.send(request)\n    logger.debug(\n        'Sent ping from %s to %s',\n        exchange.client_id,\n        self.agent_id,\n        extra=request.log_extra(),\n    )\n\n    await asyncio.wait_for(future, timeout)\n\n    elapsed = time.perf_counter() - start\n    logger.debug(\n        'Received ping from %s to %s in %.1f ms',\n        exchange.client_id,\n        self.agent_id,\n        elapsed * 1000,\n        extra=request.log_extra()\n        | {\n            'academy.ping_time_s': elapsed,\n        },\n    )\n    return elapsed\n</code></pre>"},{"location":"api/handle/#academy.handle.Handle.shutdown","title":"shutdown  <code>async</code>","text":"<pre><code>shutdown(*, terminate: bool | None = None) -&gt; None\n</code></pre> <p>Instruct the agent to shutdown.</p> <p>This is non-blocking and will only send the request. Any unexpected error responses sent by the exchange will be logged.</p> <p>Parameters:</p> <ul> <li> <code>terminate</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Override the termination behavior of the agent defined in the <code>RuntimeConfig</code>.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>AgentTerminatedError</code>             \u2013            <p>If the agent's mailbox was closed. This typically indicates the agent shutdown for another reason (it self terminated or via another handle).</p> </li> </ul> Source code in <code>academy/handle.py</code> <pre><code>async def shutdown(self, *, terminate: bool | None = None) -&gt; None:\n    \"\"\"Instruct the agent to shutdown.\n\n    This is non-blocking and will only send the request. Any unexpected\n    error responses sent by the exchange will be logged.\n\n    Args:\n        terminate: Override the termination behavior of the agent defined\n            in the [`RuntimeConfig`][academy.runtime.RuntimeConfig].\n\n    Raises:\n        AgentTerminatedError: If the agent's mailbox was closed. This\n            typically indicates the agent shutdown for another reason\n            (it self terminated or via another handle).\n    \"\"\"\n    exchange = self.exchange\n    self._register_with_exchange(exchange)\n\n    request = Message.create(\n        src=exchange.client_id,\n        dest=self.agent_id,\n        label=self.handle_id,\n        body=ShutdownRequest(terminate=terminate),\n    )\n    self._shutdown_requests.add(request.tag)\n    await self.exchange.send(request)\n    logger.debug(\n        'Sent shutdown request from %s to %s',\n        exchange.client_id,\n        self.agent_id,\n        extra=request.log_extra(),\n    )\n</code></pre>"},{"location":"api/handle/#academy.handle.ProxyHandle","title":"ProxyHandle","text":"<pre><code>ProxyHandle(agent: AgentT)\n</code></pre> <p>               Bases: <code>Handle[AgentT]</code></p> <p>Proxy handle.</p> <p>A proxy handle is thin wrapper around an <code>Agent</code> instance that is useful for testing agents that are initialized with a handle to another agent without needing to spawn agents. This wrapper invokes actions synchronously.</p> Source code in <code>academy/handle.py</code> <pre><code>def __init__(self, agent: AgentT) -&gt; None:\n    self.agent = agent\n    self.agent_id: AgentId[AgentT] = AgentId.new()\n    self._agent_closed = False\n</code></pre>"},{"location":"api/handle/#academy.handle.ProxyHandle.exchange","title":"exchange  <code>property</code>","text":"<pre><code>exchange: ExchangeClient[Any]\n</code></pre> <p>Exchange client used to send messages.</p> <p>Returns:</p> <ul> <li> <code>ExchangeClient[Any]</code>           \u2013            <p>Exchange client.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ExchangeClientNotFoundError</code>             \u2013            <p>If no exchange client is set in the current context nor was one provided to the handle.</p> </li> </ul>"},{"location":"api/handle/#academy.handle.ProxyHandle.action","title":"action  <code>async</code>","text":"<pre><code>action(action: str, /, *args: Any, **kwargs: Any) -&gt; R\n</code></pre> <p>Invoke an action on the agent.</p> <p>Parameters:</p> <ul> <li> <code>action</code>               (<code>str</code>)           \u2013            <p>Action to invoke.</p> </li> <li> <code>args</code>               (<code>Any</code>, default:                   <code>()</code> )           \u2013            <p>Positional arguments for the action.</p> </li> <li> <code>kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Keywords arguments for the action.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>R</code>           \u2013            <p>Result of the action.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>AgentTerminatedError</code>             \u2013            <p>If the agent's mailbox was closed. This typically indicates the agent shutdown for another reason (it self terminated or via another handle).</p> </li> <li> <code>Exception</code>             \u2013            <p>Any exception raised by the action.</p> </li> </ul> Source code in <code>academy/handle.py</code> <pre><code>async def action(self, action: str, /, *args: Any, **kwargs: Any) -&gt; R:\n    \"\"\"Invoke an action on the agent.\n\n    Args:\n        action: Action to invoke.\n        args: Positional arguments for the action.\n        kwargs: Keywords arguments for the action.\n\n    Returns:\n        Result of the action.\n\n    Raises:\n        AgentTerminatedError: If the agent's mailbox was closed. This\n            typically indicates the agent shutdown for another reason\n            (it self terminated or via another handle).\n        Exception: Any exception raised by the action.\n    \"\"\"\n    if self._agent_closed:\n        raise AgentTerminatedError(self.agent_id)\n\n    method = getattr(self.agent, action)\n    return await method(*args, **kwargs)\n</code></pre>"},{"location":"api/handle/#academy.handle.ProxyHandle.ping","title":"ping  <code>async</code>","text":"<pre><code>ping(*, timeout: float | None = None) -&gt; float\n</code></pre> <p>Ping the agent.</p> <p>This is a no-op for proxy handles and returns 0 latency.</p> <p>Parameters:</p> <ul> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional timeout in seconds to wait for the response.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>Round-trip time in seconds.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>AgentTerminatedError</code>             \u2013            <p>If the agent's mailbox was closed. This typically indicates the agent shutdown for another reason (it self terminated or via another handle).</p> </li> <li> <code>TimeoutError</code>             \u2013            <p>If the timeout is exceeded.</p> </li> </ul> Source code in <code>academy/handle.py</code> <pre><code>async def ping(self, *, timeout: float | None = None) -&gt; float:\n    \"\"\"Ping the agent.\n\n    This is a no-op for proxy handles and returns 0 latency.\n\n    Args:\n        timeout: Optional timeout in seconds to wait for the response.\n\n    Returns:\n        Round-trip time in seconds.\n\n    Raises:\n        AgentTerminatedError: If the agent's mailbox was closed. This\n            typically indicates the agent shutdown for another reason\n            (it self terminated or via another handle).\n        TimeoutError: If the timeout is exceeded.\n    \"\"\"\n    if self._agent_closed:\n        raise AgentTerminatedError(self.agent_id)\n    return 0\n</code></pre>"},{"location":"api/handle/#academy.handle.ProxyHandle.shutdown","title":"shutdown  <code>async</code>","text":"<pre><code>shutdown(*, terminate: bool | None = None) -&gt; None\n</code></pre> <p>Instruct the agent to shutdown.</p> <p>This is non-blocking and will only send the message.</p> <p>Parameters:</p> <ul> <li> <code>terminate</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Override the termination behavior of the agent defined in the <code>RuntimeConfig</code>.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>AgentTerminatedError</code>             \u2013            <p>If the agent's mailbox was closed. This typically indicates the agent shutdown for another reason (it self terminated or via another handle).</p> </li> </ul> Source code in <code>academy/handle.py</code> <pre><code>async def shutdown(self, *, terminate: bool | None = None) -&gt; None:\n    \"\"\"Instruct the agent to shutdown.\n\n    This is non-blocking and will only send the message.\n\n    Args:\n        terminate: Override the termination behavior of the agent defined\n            in the [`RuntimeConfig`][academy.runtime.RuntimeConfig].\n\n    Raises:\n        AgentTerminatedError: If the agent's mailbox was closed. This\n            typically indicates the agent shutdown for another reason\n            (it self terminated or via another handle).\n    \"\"\"\n    if self._agent_closed:\n        raise AgentTerminatedError(self.agent_id)\n    self._agent_closed = True if terminate is None else terminate\n</code></pre>"},{"location":"api/identifier/","title":"academy.identifier","text":"<code>academy/identifier.py</code>"},{"location":"api/identifier/#academy.identifier.EntityId","title":"EntityId  <code>module-attribute</code>","text":"<pre><code>EntityId = AgentId[Any] | UserId\n</code></pre> <p>EntityId union type for type annotations.</p>"},{"location":"api/identifier/#academy.identifier.AgentId","title":"AgentId  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code>, <code>Generic[AgentT]</code></p> <p>Unique identifier for an agent entity in a multi-agent system.</p> <p>Config:</p> <ul> <li><code>extra</code>: <code>forbid</code></li> <li><code>frozen</code>: <code>True</code></li> <li><code>validate_default</code>: <code>True</code></li> </ul> <p>Fields:</p> <ul> <li> <code>uid</code>                 (<code>UUID</code>)             </li> <li> <code>name</code>                 (<code>str | None</code>)             </li> <li> <code>role</code>                 (<code>Literal['agent']</code>)             </li> </ul>"},{"location":"api/identifier/#academy.identifier.AgentId.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(name: str | None = None) -&gt; Self\n</code></pre> <p>Create a new identifier.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional human-readable name for the entity.</p> </li> </ul> Source code in <code>academy/identifier.py</code> <pre><code>@classmethod\ndef new(cls, name: str | None = None) -&gt; Self:\n    \"\"\"Create a new identifier.\n\n    Args:\n        name: Optional human-readable name for the entity.\n    \"\"\"\n    return cls(uid=uuid.uuid4(), name=name)\n</code></pre>"},{"location":"api/identifier/#academy.identifier.UserId","title":"UserId  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Unique identifier for a user entity in a multi-agent system.</p> <p>Config:</p> <ul> <li><code>extra</code>: <code>forbid</code></li> <li><code>frozen</code>: <code>True</code></li> <li><code>validate_default</code>: <code>True</code></li> </ul> <p>Fields:</p> <ul> <li> <code>uid</code>                 (<code>UUID</code>)             </li> <li> <code>name</code>                 (<code>str | None</code>)             </li> <li> <code>role</code>                 (<code>Literal['user']</code>)             </li> </ul>"},{"location":"api/identifier/#academy.identifier.UserId.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(name: str | None = None) -&gt; Self\n</code></pre> <p>Create a new identifier.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional human-readable name for the entity.</p> </li> </ul> Source code in <code>academy/identifier.py</code> <pre><code>@classmethod\ndef new(cls, name: str | None = None) -&gt; Self:\n    \"\"\"Create a new identifier.\n\n    Args:\n        name: Optional human-readable name for the entity.\n    \"\"\"\n    return cls(uid=uuid.uuid4(), name=name)\n</code></pre>"},{"location":"api/logging/","title":"academy.logging","text":"<code>academy/logging.py</code>"},{"location":"api/logging/#academy.logging.JSONHandler","title":"JSONHandler","text":"<pre><code>JSONHandler(filename: Path)\n</code></pre> <p>               Bases: <code>Handler</code></p> <p>A LogHandler which outputs records as JSON objects, one per line.</p> Source code in <code>academy/logging.py</code> <pre><code>def __init__(self, filename: pathlib.Path) -&gt; None:\n    super().__init__()\n    self.f = open(filename, 'w')  # noqa: SIM115\n</code></pre>"},{"location":"api/logging/#academy.logging.JSONHandler.emit","title":"emit","text":"<pre><code>emit(record: LogRecord) -&gt; None\n</code></pre> <p>Emits the log record as a JSON object.</p> <p>Each attribute (including extra attributes) of the log record becomes an entry in the JSON object. Each value is rendered using <code>str</code>.</p> Source code in <code>academy/logging.py</code> <pre><code>def emit(self, record: logging.LogRecord) -&gt; None:\n    \"\"\"Emits the log record as a JSON object.\n\n    Each attribute (including extra attributes) of the log record becomes\n    an entry in the JSON object. Each value is rendered using ``str``.\n    \"\"\"\n    d = {}\n\n    d['formatted'] = self.format(record)\n\n    for k, v in record.__dict__.items():\n        try:\n            d[k] = str(v)\n        except Exception as e:\n            d[k] = f'Unrepresentable: {e!r}'\n\n    json.dump(d, fp=self.f)\n    print('', file=self.f)\n    self.f.flush()\n</code></pre>"},{"location":"api/logging/#academy.logging.init_logging","title":"init_logging","text":"<pre><code>init_logging(\n    level: int | str = INFO,\n    *,\n    logfile: str | Path | None = None,\n    logfile_level: int | str | None = None,\n    color: bool = True,\n    extra: int = False,\n    force: bool = False\n) -&gt; Logger\n</code></pre> <p>Initialize global logger.</p> <p>Parameters:</p> <ul> <li> <code>level</code>               (<code>int | str</code>, default:                   <code>INFO</code> )           \u2013            <p>Minimum logging level.</p> </li> <li> <code>logfile</code>               (<code>str | Path | None</code>, default:                   <code>None</code> )           \u2013            <p>Configure a file handler for this path.</p> </li> <li> <code>logfile_level</code>               (<code>int | str | None</code>, default:                   <code>None</code> )           \u2013            <p>Minimum logging level for the file handler. Defaults to that of <code>level</code>.</p> </li> <li> <code>color</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Use colorful logging for stdout.</p> </li> <li> <code>extra</code>               (<code>int</code>, default:                   <code>False</code> )           \u2013            <p>Include extra info in log messages, such as thread ID and process ID. This is helpful for debugging. True or 1 adds some extra info. 2 adds on observability-style logging of key-value metadata, and adds a second logfile formatted as JSON.</p> </li> <li> <code>force</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Remove any existing handlers attached to the root handler. This option is useful to silencing the third-party package logging. Note: should not be set when running inside pytest.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Logger</code>           \u2013            <p>The root logger.</p> </li> </ul> Source code in <code>academy/logging.py</code> <pre><code>def init_logging(  # noqa: PLR0913\n    level: int | str = logging.INFO,\n    *,\n    logfile: str | pathlib.Path | None = None,\n    logfile_level: int | str | None = None,\n    color: bool = True,\n    extra: int = False,\n    force: bool = False,\n) -&gt; logging.Logger:\n    \"\"\"Initialize global logger.\n\n    Args:\n        level: Minimum logging level.\n        logfile: Configure a file handler for this path.\n        logfile_level: Minimum logging level for the file handler. Defaults\n            to that of `level`.\n        color: Use colorful logging for stdout.\n        extra: Include extra info in log messages, such as thread ID and\n            process ID. This is helpful for debugging. True or 1 adds some\n            extra info. 2 adds on observability-style logging of key-value\n            metadata, and adds a second logfile formatted as JSON.\n        force: Remove any existing handlers attached to the root\n            handler. This option is useful to silencing the third-party\n            package logging. Note: should not be set when running inside\n            pytest.\n\n    Returns:\n        The root logger.\n    \"\"\"\n    stdout_handler = logging.StreamHandler(sys.stdout)\n    stdout_handler.setFormatter(_Formatter(color=color, extra=extra))\n    stdout_handler.setLevel(level)\n    if extra:\n        stdout_handler.addFilter(_os_thread_filter)\n    handlers: list[logging.Handler] = [stdout_handler]\n\n    if logfile is not None:\n        logfile_level = level if logfile_level is None else logfile_level\n        path = pathlib.Path(logfile)\n        path.parent.mkdir(parents=True, exist_ok=True)\n        human_handler = logging.FileHandler(path)\n        human_handler.setFormatter(_Formatter(color=False, extra=extra))\n        human_handler.setLevel(logfile_level)\n        if extra:\n            human_handler.addFilter(_os_thread_filter)\n        handlers.append(human_handler)\n\n        if extra &gt; 1:\n            json_handler = JSONHandler(path.with_suffix('.jsonlog'))\n            json_handler.setLevel(logfile_level)\n            handlers.append(json_handler)\n\n    logging.basicConfig(\n        datefmt='%Y-%m-%d %H:%M:%S',\n        level=logging.NOTSET,\n        handlers=handlers,\n        force=force,\n    )\n\n    # This needs to be after the configuration of the root logger because\n    # warnings get logged to a 'py.warnings' logger.\n    logging.captureWarnings(True)\n\n    logger = logging.getLogger()\n    logger.info(\n        'Configured logger (stdout-level=%s, logfile=%s, logfile-level=%s)',\n        logging.getLevelName(level) if isinstance(level, int) else level,\n        logfile,\n        logging.getLevelName(logfile_level)\n        if isinstance(logfile_level, int)\n        else logfile_level,\n    )\n\n    return logger\n</code></pre>"},{"location":"api/logging/#academy.logging.execute_and_log_traceback","title":"execute_and_log_traceback  <code>async</code>","text":"<pre><code>execute_and_log_traceback(fut: Future[Any]) -&gt; Any\n</code></pre> <p>Await a future and log any exception..</p> <p>Catches any exceptions raised by the coroutine, logs the traceback, and re-raises the exception.</p> Source code in <code>academy/logging.py</code> <pre><code>async def execute_and_log_traceback(\n    fut: Future[Any],\n) -&gt; Any:\n    \"\"\"Await a future and log any exception..\n\n    Catches any exceptions raised by the coroutine, logs the traceback,\n    and re-raises the exception.\n    \"\"\"\n    try:\n        return await fut\n    except Exception:\n        logger.exception('Background task raised an exception.')\n        raise\n</code></pre>"},{"location":"api/manager/","title":"academy.manager","text":"<code>academy/manager.py</code>"},{"location":"api/manager/#academy.manager.Manager","title":"Manager","text":"<pre><code>Manager(\n    exchange_client: ExchangeClient[ExchangeTransportT],\n    executors: (\n        Executor\n        | MutableMapping[str, Executor | None]\n        | None\n    ) = None,\n    *,\n    default_executor: str = \"event_loop\",\n    max_retries: int = 0\n)\n</code></pre> <p>               Bases: <code>Generic[ExchangeTransportT]</code>, <code>NoPickleMixin</code></p> <p>Launch and manage running agents.</p> <p>A manager is used to launch agents in the current event loop or in <code>Executors</code> and interact with/manage those agents.</p> Tip <p>This class can be used as a context manager. Upon exiting the context, running agents will be shutdown, any agent handles created by the manager will be closed, and the executors will be shutdown.</p> Tip <p>When using <code>ProcessPoolExecutors</code>, use the <code>initializer</code> argument to configure logging in the worker processes that will execute agents.</p> Note <p>The manager takes ownership of the exchange client and executors, meaning the manager will clean up those resources when the manager is closed.</p> <p>Parameters:</p> <ul> <li> <code>exchange_client</code>               (<code>ExchangeClient[ExchangeTransportT]</code>)           \u2013            <p>Exchange client.</p> </li> <li> <code>executors</code>               (<code>Executor | MutableMapping[str, Executor | None] | None</code>, default:                   <code>None</code> )           \u2013            <p>An executor instance or mapping of names to executors to use to run agents. If a single executor is provided, it is set as the default executor with name <code>'default'</code>, overriding any value of <code>default_executor</code>. Setting <code>executor=None</code> (the default) or passing <code>{'name': None, ...}</code> can be used to launch agents in the current event loop.</p> </li> <li> <code>default_executor</code>               (<code>str</code>, default:                   <code>'event_loop'</code> )           \u2013            <p>Specify the name of the default executor to use when not specified in <code>launch()</code>.</p> </li> <li> <code>max_retries</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Maximum number of times to retry running an agent if it exits with an error.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If <code>default_executor</code> is specified but does not exist in <code>executors</code>, or if executors is badly typed.</p> </li> </ul> Source code in <code>academy/manager.py</code> <pre><code>def __init__(\n    self,\n    exchange_client: ae.ExchangeClient[ExchangeTransportT],\n    executors: Executor\n    | MutableMapping[str, Executor | None]\n    | None = None,\n    *,\n    default_executor: str = 'event_loop',\n    max_retries: int = 0,\n) -&gt; None:\n    self._executors: dict[str, Executor | None] = {'event_loop': None}\n    if isinstance(executors, Executor):\n        self._executors.update({'default': executors})\n        default_executor = 'default'\n    elif isinstance(executors, MutableMapping):\n        self._executors.update(executors)\n    elif executors is None:\n        pass\n    else:  # unreachable if types are followed\n        raise ValueError('Invalid executors parameter')\n\n    if default_executor not in self._executors:\n        raise ValueError(\n            f'No executor named \"{default_executor}\" was provided to '\n            'use as the default.',\n        )\n\n    self._exchange_client = exchange_client\n    self._exchange_factory = exchange_client.factory()\n    self._user_id = self._exchange_client.client_id\n    self._default_executor = default_executor\n    self._max_retries = max_retries\n    self._closed = asyncio.Event()\n\n    self._handles: dict[AgentId[Any], Handle[Any]] = {}\n    self._acbs: dict[AgentId[Any], _ACB[Any]] = {}\n\n    logger.info(\n        'Initialized manager (%s)',\n        self.user_id,\n        extra={'academy.user_id': self.user_id},\n    )\n</code></pre>"},{"location":"api/manager/#academy.manager.Manager.exchange_client","title":"exchange_client  <code>property</code>","text":"<pre><code>exchange_client: ExchangeClient[ExchangeTransportT]\n</code></pre> <p>User client for the exchange.</p>"},{"location":"api/manager/#academy.manager.Manager.exchange_factory","title":"exchange_factory  <code>property</code>","text":"<pre><code>exchange_factory: ExchangeFactory[ExchangeTransportT]\n</code></pre> <p>Client factory for the exchange.</p>"},{"location":"api/manager/#academy.manager.Manager.user_id","title":"user_id  <code>property</code>","text":"<pre><code>user_id: EntityId\n</code></pre> <p>Exchange client user ID of this manager.</p>"},{"location":"api/manager/#academy.manager.Manager.from_exchange_factory","title":"from_exchange_factory  <code>async</code> <code>classmethod</code>","text":"<pre><code>from_exchange_factory(\n    factory: ExchangeFactory[ExchangeTransportT],\n    executors: (\n        Executor\n        | MutableMapping[str, Executor | None]\n        | None\n    ) = None,\n    *,\n    default_executor: str = \"event_loop\",\n    max_retries: int = 0\n) -&gt; Self\n</code></pre> <p>Instantiate a new exchange client and manager from a factory.</p> Source code in <code>academy/manager.py</code> <pre><code>@classmethod\nasync def from_exchange_factory(\n    cls,\n    factory: ae.ExchangeFactory[ExchangeTransportT],\n    executors: Executor\n    | MutableMapping[str, Executor | None]\n    | None = None,\n    *,\n    default_executor: str = 'event_loop',\n    max_retries: int = 0,\n) -&gt; Self:\n    \"\"\"Instantiate a new exchange client and manager from a factory.\"\"\"\n    client = await factory.create_user_client()\n    return cls(\n        client,\n        executors,\n        default_executor=default_executor,\n        max_retries=max_retries,\n    )\n</code></pre>"},{"location":"api/manager/#academy.manager.Manager.close","title":"close  <code>async</code>","text":"<pre><code>close(close_exchange: bool = True) -&gt; None\n</code></pre> <p>Shutdown the manager and cleanup resources.</p> <ol> <li>Request all running agents to shut down.</li> <li>Wait for all running agents to shut down.</li> <li>Close the exchange client. (if close_exchange)</li> <li>Shutdown the executors.</li> <li>Raise an exceptions returned by agents.</li> </ol> <p>Parameters:</p> <ul> <li> <code>close_exchange</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If the exchange_client should be closed.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Exception</code>             \u2013            <p>Any exceptions raised by agents.</p> </li> </ul> Source code in <code>academy/manager.py</code> <pre><code>async def close(self, close_exchange: bool = True) -&gt; None:\n    \"\"\"Shutdown the manager and cleanup resources.\n\n    1. Request all running agents to shut down.\n    1. Wait for all running agents to shut down.\n    1. Close the exchange client. (if close_exchange)\n    1. Shutdown the executors.\n    1. Raise an exceptions returned by agents.\n\n    Args:\n        close_exchange: If the exchange_client should be closed.\n\n    Raises:\n        Exception: Any exceptions raised by agents.\n    \"\"\"\n    self._closed.set()  # Stop from launching retries\n\n    for acb in self._acbs.values():\n        if not acb.task.done():\n            handle = self.get_handle(acb.agent_id)\n            with contextlib.suppress(AgentTerminatedError):\n                await handle.shutdown()\n    logger.debug('Requested shutdown from all agents')\n\n    for acb in self._acbs.values():\n        await acb.task\n    logger.debug('All agents have completed')\n\n    if close_exchange:\n        await self.exchange_client.close()\n\n    for executor in self._executors.values():\n        if executor is not None:\n            executor.shutdown(wait=True, cancel_futures=True)\n\n    exceptions = (acb.task.exception() for acb in self._acbs.values())\n    exceptions_only = tuple(e for e in exceptions if e is not None)\n    raise_exceptions(\n        exceptions_only,\n        message='Caught failures in agent while shutting down.',\n    )\n\n    logger.info(\n        'Closed manager (%s)',\n        self.user_id,\n        extra={'academy.user_id': self.user_id},\n    )\n</code></pre>"},{"location":"api/manager/#academy.manager.Manager.add_executor","title":"add_executor","text":"<pre><code>add_executor(name: str, executor: Executor) -&gt; Self\n</code></pre> <p>Add an executor to the manager.</p> Note <p>It is not possible to remove an executor as this could create complications if an agent is already running in that executor.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Name of the executor used when launching agents.</p> </li> <li> <code>executor</code>               (<code>Executor</code>)           \u2013            <p>Executor instance.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>Self for chaining.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If an executor with <code>name</code> already exists.</p> </li> </ul> Source code in <code>academy/manager.py</code> <pre><code>def add_executor(self, name: str, executor: Executor) -&gt; Self:\n    \"\"\"Add an executor to the manager.\n\n    Note:\n        It is not possible to remove an executor as this could create\n        complications if an agent is already running in that executor.\n\n    Args:\n        name: Name of the executor used when launching agents.\n        executor: Executor instance.\n\n    Returns:\n        Self for chaining.\n\n    Raises:\n        ValueError: If an executor with `name` already exists.\n    \"\"\"\n    if name in self._executors:\n        raise ValueError(f'Executor named \"{name}\" already exists.')\n    self._executors[name] = executor\n    return self\n</code></pre>"},{"location":"api/manager/#academy.manager.Manager.set_default_executor","title":"set_default_executor","text":"<pre><code>set_default_executor(name: str) -&gt; Self\n</code></pre> <p>Set the default executor by name.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Name of the executor to use as default.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>Self for chaining.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If no executor with <code>name</code> exists.</p> </li> </ul> Source code in <code>academy/manager.py</code> <pre><code>def set_default_executor(self, name: str) -&gt; Self:\n    \"\"\"Set the default executor by name.\n\n    Args:\n        name: Name of the executor to use as default.\n\n    Returns:\n        Self for chaining.\n\n    Raises:\n        ValueError: If no executor with `name` exists.\n    \"\"\"\n    if name not in self._executors:\n        raise ValueError(f'An executor named \"{name}\" does not exist.')\n    self._default_executor = name\n    return self\n</code></pre>"},{"location":"api/manager/#academy.manager.Manager.launch","title":"launch  <code>async</code>","text":"<pre><code>launch(\n    agent: AgentT | type[AgentT],\n    *,\n    args: tuple[Any, ...] | None = None,\n    kwargs: dict[str, Any] | None = None,\n    config: RuntimeConfig | None = None,\n    executor: str | None = None,\n    submit_kwargs: dict[str, Any] | None = None,\n    name: str | None = None,\n    registration: AgentRegistration[AgentT] | None = None,\n    init_logging: bool = False,\n    loglevel: int | str = INFO,\n    logfile: str | None = None\n) -&gt; Handle[AgentT]\n</code></pre> <p>Launch a new agent with a specified agent.</p> <p>Parameters:</p> <ul> <li> <code>agent</code>               (<code>AgentT | type[AgentT]</code>)           \u2013            <p>Agent instance the agent will implement or the agent type that will be initialized on the worker using <code>args</code> and <code>kwargs</code>.</p> </li> <li> <code>args</code>               (<code>tuple[Any, ...] | None</code>, default:                   <code>None</code> )           \u2013            <p>Positional arguments used to initialize the agent. Ignored if <code>agent</code> is already an instance.</p> </li> <li> <code>kwargs</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Keyword arguments used to initialize the agent. Ignored if <code>agent</code> is already an instance.</p> </li> <li> <code>config</code>               (<code>RuntimeConfig | None</code>, default:                   <code>None</code> )           \u2013            <p>Agent run configuration.</p> </li> <li> <code>executor</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Name of the executor instance to use. If <code>None</code>, uses the default executor.</p> </li> <li> <code>submit_kwargs</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional arguments to pass to the submit function of the executor (i.e. a resource specification).</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Readable name of the agent used when registering a new agent.</p> </li> <li> <code>registration</code>               (<code>AgentRegistration[AgentT] | None</code>, default:                   <code>None</code> )           \u2013            <p>If <code>None</code>, a new agent will be registered with the exchange.</p> </li> <li> <code>init_logging</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Initialize logging before running agent.</p> </li> <li> <code>loglevel</code>               (<code>int | str</code>, default:                   <code>INFO</code> )           \u2013            <p>Level of logging.</p> </li> <li> <code>logfile</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Location to write logs.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Handle[AgentT]</code>           \u2013            <p>Handle (client bound) used to interact with the agent.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>If <code>registration</code> is provided and an agent with that ID has already been executed.</p> </li> </ul> Source code in <code>academy/manager.py</code> <pre><code>async def launch(  # noqa: PLR0913\n    self,\n    agent: AgentT | type[AgentT],\n    *,\n    args: tuple[Any, ...] | None = None,\n    kwargs: dict[str, Any] | None = None,\n    config: RuntimeConfig | None = None,\n    executor: str | None = None,\n    submit_kwargs: dict[str, Any] | None = None,\n    name: str | None = None,\n    registration: AgentRegistration[AgentT] | None = None,\n    init_logging: bool = False,\n    loglevel: int | str = logging.INFO,\n    logfile: str | None = None,\n) -&gt; Handle[AgentT]:\n    \"\"\"Launch a new agent with a specified agent.\n\n    Args:\n        agent: Agent instance the agent will implement or the\n            agent type that will be initialized on the worker using\n            `args` and `kwargs`.\n        args: Positional arguments used to initialize the agent.\n            Ignored if `agent` is already an instance.\n        kwargs: Keyword arguments used to initialize the agent.\n            Ignored if `agent` is already an instance.\n        config: Agent run configuration.\n        executor: Name of the executor instance to use. If `None`, uses\n            the default executor.\n        submit_kwargs: Additional arguments to pass to the submit function\n            of the executor (i.e. a resource specification).\n        name: Readable name of the agent used when registering a new agent.\n        registration: If `None`, a new agent will be registered with\n            the exchange.\n        init_logging: Initialize logging before running agent.\n        loglevel: Level of logging.\n        logfile: Location to write logs.\n\n    Returns:\n        Handle (client bound) used to interact with the agent.\n\n    Raises:\n        RuntimeError: If `registration` is provided and an agent with\n            that ID has already been executed.\n    \"\"\"\n    executor = executor if executor is not None else self._default_executor\n    assert executor is not None\n    executor_instance = self._executors[executor]\n\n    if registration is None:\n        agent_type = agent if isinstance(agent, type) else type(agent)\n        registration = await self.register_agent(agent_type, name=name)\n    elif registration.agent_id in self._acbs:\n        raise RuntimeError(\n            f'{registration.agent_id} has already been executed.',\n        )\n\n    if init_logging and (\n        executor_instance is None\n        or isinstance(executor_instance, ThreadPoolExecutor)\n    ):\n        warnings.warn(\n            f'`init_logging` was specified for agent '\n            f'{registration.agent_id} running in the same process as the '\n            f'Manager. `init_logging` should only be called once per '\n            f'process.',\n            stacklevel=2,\n        )\n\n    agent_id = registration.agent_id\n\n    spec = _RunSpec(\n        agent=agent,\n        config=RuntimeConfig() if config is None else config,\n        exchange_factory=self.exchange_factory,\n        registration=registration,\n        agent_args=() if args is None else args,\n        agent_kwargs={} if kwargs is None else kwargs,\n        submit_kwargs={} if submit_kwargs is None else submit_kwargs,\n        init_logging=init_logging,\n        loglevel=loglevel,\n        logfile=logfile,\n    )\n\n    task = asyncio.create_task(\n        self._run_agent(executor_instance, spec),\n        name=f'manager-{executor}-run-{agent_id}',\n    )\n\n    acb = _ACB(agent_id=agent_id, executor=executor, task=task)\n    self._acbs[agent_id] = acb\n    handle = self.get_handle(agent_id)\n    logger.info(\n        'Launched agent (%s; %s)',\n        agent_id,\n        agent,\n        extra={'academy.agent_id': agent_id, 'academy.agent': agent},\n    )\n    if executor_instance is not None:\n        self._warn_executor_overloaded(executor_instance, executor)\n    return handle\n</code></pre>"},{"location":"api/manager/#academy.manager.Manager.get_handle","title":"get_handle","text":"<pre><code>get_handle(\n    agent: AgentId[AgentT] | AgentRegistration[AgentT],\n) -&gt; Handle[AgentT]\n</code></pre> <p>Create a new handle to an agent.</p> <p>A handle acts like a reference to a remote agent, enabling a user to manage the agent or asynchronously invoke actions.</p> <p>Parameters:</p> <ul> <li> <code>agent</code>               (<code>AgentId[AgentT] | AgentRegistration[AgentT]</code>)           \u2013            <p>Agent ID or registration indicating the agent to create a handle to. The agent must be registered with the same exchange that this manager is a client of.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Handle[AgentT]</code>           \u2013            <p>Handle to the agent.</p> </li> </ul> Source code in <code>academy/manager.py</code> <pre><code>def get_handle(\n    self,\n    agent: AgentId[AgentT] | AgentRegistration[AgentT],\n) -&gt; Handle[AgentT]:\n    \"\"\"Create a new handle to an agent.\n\n    A handle acts like a reference to a remote agent, enabling a user\n    to manage the agent or asynchronously invoke actions.\n\n    Args:\n        agent: Agent ID or registration indicating the agent to create\n            a handle to. The agent must be registered with the same\n            exchange that this manager is a client of.\n\n    Returns:\n        Handle to the agent.\n    \"\"\"\n    agent_id = agent if isinstance(agent, AgentId) else agent.agent_id\n    handle = self._handles.get(agent_id, None)\n    if handle is not None:\n        return handle\n    handle = Handle(agent_id)\n    self._handles[agent_id] = handle\n    return handle\n</code></pre>"},{"location":"api/manager/#academy.manager.Manager.register_agent","title":"register_agent  <code>async</code>","text":"<pre><code>register_agent(\n    agent: type[AgentT], *, name: str | None = None\n) -&gt; AgentRegistration[AgentT]\n</code></pre> <p>Register a new agent with the exchange.</p> <p>Parameters:</p> <ul> <li> <code>agent</code>               (<code>type[AgentT]</code>)           \u2013            <p>Agent type of the agent.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional display name for the agent.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AgentRegistration[AgentT]</code>           \u2013            <p>Agent registration info that can be passed to</p> </li> <li> <code>AgentRegistration[AgentT]</code>           \u2013            <p><code>launch()</code>.</p> </li> </ul> Source code in <code>academy/manager.py</code> <pre><code>async def register_agent(\n    self,\n    agent: type[AgentT],\n    *,\n    name: str | None = None,\n) -&gt; AgentRegistration[AgentT]:\n    \"\"\"Register a new agent with the exchange.\n\n    Args:\n        agent: Agent type of the agent.\n        name: Optional display name for the agent.\n\n    Returns:\n        Agent registration info that can be passed to\n        [`launch()`][academy.manager.Manager.launch].\n    \"\"\"\n    return await self.exchange_client.register_agent(agent, name=name)\n</code></pre>"},{"location":"api/manager/#academy.manager.Manager.running","title":"running","text":"<pre><code>running() -&gt; set[AgentId[Any]]\n</code></pre> <p>Get a set of IDs of all running agents.</p> <p>Returns:</p> <ul> <li> <code>set[AgentId[Any]]</code>           \u2013            <p>Set of agent IDs corresponding to all agents launched by this             manager that have not completed yet.</p> </li> </ul> Source code in <code>academy/manager.py</code> <pre><code>def running(self) -&gt; set[AgentId[Any]]:\n    \"\"\"Get a set of IDs of all running agents.\n\n    Returns:\n        Set of agent IDs corresponding to all agents launched by this \\\n        manager that have not completed yet.\n    \"\"\"\n    running: set[AgentId[Any]] = set()\n    for acb in self._acbs.values():\n        if not acb.task.done():\n            running.add(acb.agent_id)\n    return running\n</code></pre>"},{"location":"api/manager/#academy.manager.Manager.shutdown","title":"shutdown  <code>async</code>","text":"<pre><code>shutdown(\n    agent: AgentId[Any] | Handle[Any],\n    *,\n    blocking: bool = True,\n    raise_error: bool = True,\n    terminate: bool | None = None,\n    timeout: float | None = None\n) -&gt; None\n</code></pre> <p>Shutdown a launched agent.</p> <p>Parameters:</p> <ul> <li> <code>agent</code>               (<code>AgentId[Any] | Handle[Any]</code>)           \u2013            <p>ID or handle to the launched agent.</p> </li> <li> <code>blocking</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Wait for the agent to exit before returning.</p> </li> <li> <code>raise_error</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Raise the error returned by the agent if <code>blocking=True</code>.</p> </li> <li> <code>terminate</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Override the termination behavior of the agent defined in the <code>RuntimeConfig</code>.</p> </li> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional timeout is seconds when <code>blocking=True</code>.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BadEntityIdError</code>             \u2013            <p>If an agent with <code>agent_id</code> was not launched by this manager.</p> </li> <li> <code>TimeoutError</code>             \u2013            <p>If <code>timeout</code> was exceeded while blocking for agent.</p> </li> </ul> Source code in <code>academy/manager.py</code> <pre><code>async def shutdown(\n    self,\n    agent: AgentId[Any] | Handle[Any],\n    *,\n    blocking: bool = True,\n    raise_error: bool = True,\n    terminate: bool | None = None,\n    timeout: float | None = None,\n) -&gt; None:\n    \"\"\"Shutdown a launched agent.\n\n    Args:\n        agent: ID or handle to the launched agent.\n        blocking: Wait for the agent to exit before returning.\n        raise_error: Raise the error returned by the agent if\n            `blocking=True`.\n        terminate: Override the termination behavior of the agent defined\n            in the [`RuntimeConfig`][academy.runtime.RuntimeConfig].\n        timeout: Optional timeout is seconds when `blocking=True`.\n\n    Raises:\n        BadEntityIdError: If an agent with `agent_id` was not\n            launched by this manager.\n        TimeoutError: If `timeout` was exceeded while blocking for agent.\n    \"\"\"\n    agent_id = agent.agent_id if isinstance(agent, Handle) else agent\n\n    if agent_id not in self._acbs:\n        raise BadEntityIdError(agent_id) from None\n    if self._acbs[agent_id].task.done():\n        return\n\n    handle = self.get_handle(agent_id)\n    with contextlib.suppress(AgentTerminatedError):\n        await handle.shutdown(terminate=terminate)\n\n    if blocking:\n        await self.wait(\n            {agent_id},\n            raise_error=raise_error,\n            timeout=timeout,\n        )\n</code></pre>"},{"location":"api/manager/#academy.manager.Manager.wait","title":"wait  <code>async</code>","text":"<pre><code>wait(\n    agents: Iterable[AgentId[Any] | Handle[Any]],\n    *,\n    raise_error: bool = False,\n    return_when: str = ALL_COMPLETED,\n    timeout: float | None = None\n) -&gt; None\n</code></pre> <p>Wait for launched agents to complete.</p> Note <p>Calling <code>wait()</code> is only valid after <code>launch()</code> has succeeded.</p> <p>Parameters:</p> <ul> <li> <code>agents</code>               (<code>Iterable[AgentId[Any] | Handle[Any]]</code>)           \u2013            <p>An iterable of agent IDs or handles to wait on.</p> </li> <li> <code>raise_error</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Raise errors returned by completed agents.</p> </li> <li> <code>return_when</code>               (<code>str</code>, default:                   <code>ALL_COMPLETED</code> )           \u2013            <p>Indicate when this function should return. The same as <code>asyncio.wait()</code>.</p> </li> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional timeout in seconds to wait for agents.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BadEntityIdError</code>             \u2013            <p>If an agent was not launched by this manager.</p> </li> <li> <code>TimeoutError</code>             \u2013            <p>If <code>timeout</code> was exceeded while waiting for agents.</p> </li> <li> <code>Exception</code>             \u2013            <p>Any exception raised by an agent that completed due to a failure and <code>raise_error=True</code> is set.</p> </li> </ul> Source code in <code>academy/manager.py</code> <pre><code>async def wait(\n    self,\n    agents: Iterable[AgentId[Any] | Handle[Any]],\n    *,\n    raise_error: bool = False,\n    return_when: str = asyncio.ALL_COMPLETED,\n    timeout: float | None = None,\n) -&gt; None:\n    \"\"\"Wait for launched agents to complete.\n\n    Note:\n        Calling `wait()` is only valid after `launch()` has succeeded.\n\n    Args:\n        agents: An iterable of agent IDs or handles to wait on.\n        raise_error: Raise errors returned by completed agents.\n        return_when: Indicate when this function should return. The\n            same as [`asyncio.wait()`][asyncio.wait].\n        timeout: Optional timeout in seconds to wait for agents.\n\n    Raises:\n        BadEntityIdError: If an agent was not launched by this manager.\n        TimeoutError: If `timeout` was exceeded while waiting for agents.\n        Exception: Any exception raised by an agent that completed due\n            to a failure and `raise_error=True` is set.\n    \"\"\"\n    agent_ids = {\n        agent if isinstance(agent, AgentId) else agent.agent_id\n        for agent in agents\n    }\n\n    if len(agent_ids) == 0:\n        return\n\n    agent_tasks: list[asyncio.Task[None]] = []\n    for agent_id in agent_ids:\n        try:\n            agent_tasks.append(self._acbs[agent_id].task)\n        except KeyError:\n            raise BadEntityIdError(agent_id) from None\n\n    done, pending = await asyncio.wait(\n        agent_tasks,\n        return_when=return_when,\n        timeout=timeout,\n    )\n\n    if len(done) == 0:\n        raise TimeoutError(\n            f'No agents completed within {timeout} seconds: '\n            f'{len(pending)} pending agent(s).',\n        )\n    elif return_when == asyncio.ALL_COMPLETED and len(pending) &gt; 0:\n        raise TimeoutError(\n            f'Not all agents completed within {timeout} seconds: '\n            f'{len(pending)} pending agent(s).',\n        )\n\n    if raise_error:\n        exceptions = (task.exception() for task in agent_tasks)\n        exceptions_only = tuple(e for e in exceptions if e is not None)\n        raise_exceptions(\n            exceptions_only,\n            message='Waited agents raised the following exceptions.',\n        )\n</code></pre>"},{"location":"api/message/","title":"academy.message","text":"<code>academy/message.py</code>"},{"location":"api/message/#academy.message.ActionRequest","title":"ActionRequest  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Agent action request message.</p> Warning <p>The positional and keywords arguments for the invoked action are pickled and base64-encoded when serialized to JSON. This can have non-trivial time and space overheads for large arguments.</p> <p>Config:</p> <ul> <li><code>default</code>: <code>DEFAULT_MUTABLE_CONFIG</code></li> </ul> <p>Fields:</p> <ul> <li> <code>action</code>                 (<code>str</code>)             </li> <li> <code>pargs</code>                 (<code>SkipValidation[tuple[Any, ...]]</code>)             </li> <li> <code>kargs</code>                 (<code>SkipValidation[dict[str, Any]]</code>)             </li> <li> <code>kind</code>                 (<code>Literal['action-request']</code>)             </li> </ul>"},{"location":"api/message/#academy.message.ActionRequest.action","title":"action  <code>pydantic-field</code>","text":"<pre><code>action: str\n</code></pre> <p>Name of the requested action.</p>"},{"location":"api/message/#academy.message.ActionRequest.pargs","title":"pargs  <code>pydantic-field</code>","text":"<pre><code>pargs: SkipValidation[tuple[Any, ...]]\n</code></pre> <p>Positional arguments to the action method.</p>"},{"location":"api/message/#academy.message.ActionRequest.kargs","title":"kargs  <code>pydantic-field</code>","text":"<pre><code>kargs: SkipValidation[dict[str, Any]]\n</code></pre> <p>Keyword arguments to the action method.</p>"},{"location":"api/message/#academy.message.ActionRequest.get_args","title":"get_args","text":"<pre><code>get_args() -&gt; tuple[Any, ...]\n</code></pre> <p>Get the positional arguments.</p> <p>Lazily deserializes and returns the positional arguments. Caches the result to avoid redundant decoding.</p> <p>Returns:</p> <ul> <li> <code>tuple[Any, ...]</code>           \u2013            <p>The deserialized tuple of positional arguments.</p> </li> </ul> Source code in <code>academy/message.py</code> <pre><code>def get_args(self) -&gt; tuple[Any, ...]:\n    \"\"\"Get the positional arguments.\n\n    Lazily deserializes and returns the positional arguments.\n    Caches the result to avoid redundant decoding.\n\n    Returns:\n        The deserialized tuple of positional arguments.\n    \"\"\"\n    if isinstance(self.pargs, str):\n        self.pargs = pickle.loads(base64.b64decode(self.pargs))\n    return self.pargs\n</code></pre>"},{"location":"api/message/#academy.message.ActionRequest.get_kwargs","title":"get_kwargs","text":"<pre><code>get_kwargs() -&gt; dict[str, Any]\n</code></pre> <p>Get the keyword arguments.</p> <p>Lazily deserializes and returns the keyword arguments. Caches the result to avoid redundant decoding.</p> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>           \u2013            <p>The deserialized dictionary of keyword arguments.</p> </li> </ul> Source code in <code>academy/message.py</code> <pre><code>def get_kwargs(self) -&gt; dict[str, Any]:\n    \"\"\"Get the keyword arguments.\n\n    Lazily deserializes and returns the keyword arguments.\n    Caches the result to avoid redundant decoding.\n\n    Returns:\n        The deserialized dictionary of keyword arguments.\n    \"\"\"\n    if isinstance(self.kargs, str):\n        self.kargs = pickle.loads(base64.b64decode(self.kargs))\n    return self.kargs\n</code></pre>"},{"location":"api/message/#academy.message.PingRequest","title":"PingRequest  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Agent ping request message.</p> <p>Config:</p> <ul> <li><code>default</code>: <code>DEFAULT_FROZEN_CONFIG</code></li> </ul> <p>Fields:</p> <ul> <li> <code>kind</code>                 (<code>Literal['ping-request']</code>)             </li> </ul>"},{"location":"api/message/#academy.message.ShutdownRequest","title":"ShutdownRequest  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Agent shutdown request message.</p> <p>Config:</p> <ul> <li><code>default</code>: <code>DEFAULT_FROZEN_CONFIG</code></li> </ul> <p>Fields:</p> <ul> <li> <code>terminate</code>                 (<code>bool | None</code>)             </li> <li> <code>kind</code>                 (<code>Literal['shutdown-request']</code>)             </li> </ul>"},{"location":"api/message/#academy.message.ShutdownRequest.terminate","title":"terminate  <code>pydantic-field</code>","text":"<pre><code>terminate: bool | None = None\n</code></pre> <p>Override the termination behavior of the agent.</p>"},{"location":"api/message/#academy.message.ActionResponse","title":"ActionResponse  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Agent action response message.</p> Warning <p>The result is pickled and base64-encoded when serialized to JSON. This can have non-trivial time and space overheads for large results.</p> <p>Config:</p> <ul> <li><code>default</code>: <code>DEFAULT_MUTABLE_CONFIG</code></li> </ul> <p>Fields:</p> <ul> <li> <code>action</code>                 (<code>str</code>)             </li> <li> <code>result</code>                 (<code>SkipValidation[Any]</code>)             </li> <li> <code>kind</code>                 (<code>Literal['action-response']</code>)             </li> </ul>"},{"location":"api/message/#academy.message.ActionResponse.action","title":"action  <code>pydantic-field</code>","text":"<pre><code>action: str\n</code></pre> <p>Name of the requested action.</p>"},{"location":"api/message/#academy.message.ActionResponse.result","title":"result  <code>pydantic-field</code>","text":"<pre><code>result: SkipValidation[Any]\n</code></pre> <p>Result of the action, if successful.</p>"},{"location":"api/message/#academy.message.ActionResponse.get_result","title":"get_result","text":"<pre><code>get_result() -&gt; Any\n</code></pre> <p>Get the result.</p> <p>Lazily deserializes and returns the result of the action. Caches the result to avoid redundant decoding.</p> <p>Returns:</p> <ul> <li> <code>Any</code>           \u2013            <p>The deserialized result of the action.</p> </li> </ul> Source code in <code>academy/message.py</code> <pre><code>def get_result(self) -&gt; Any:\n    \"\"\"Get the result.\n\n    Lazily deserializes and returns the result of the action.\n    Caches the result to avoid redundant decoding.\n\n    Returns:\n        The deserialized result of the action.\n    \"\"\"\n    if (\n        isinstance(self.result, list)\n        and len(self.result) == 2  # noqa PLR2004\n        and self.result[0] == '__pickled__'\n    ):\n        self.result = pickle.loads(base64.b64decode(self.result[1]))\n    return self.result\n</code></pre>"},{"location":"api/message/#academy.message.ErrorResponse","title":"ErrorResponse  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Error response message.</p> <p>Contains the exception raised by a failed request.</p> <p>Config:</p> <ul> <li><code>default</code>: <code>DEFAULT_MUTABLE_CONFIG</code></li> </ul> <p>Fields:</p> <ul> <li> <code>exception</code>                 (<code>SkipValidation[Exception]</code>)             </li> <li> <code>kind</code>                 (<code>Literal['error-response']</code>)             </li> </ul>"},{"location":"api/message/#academy.message.ErrorResponse.exception","title":"exception  <code>pydantic-field</code>","text":"<pre><code>exception: SkipValidation[Exception]\n</code></pre> <p>Exception of the failed request.</p>"},{"location":"api/message/#academy.message.ErrorResponse.get_exception","title":"get_exception","text":"<pre><code>get_exception() -&gt; Exception\n</code></pre> <p>Get the exception.</p> <p>Lazily deserializes and returns the exception object. Caches the result to avoid redundant decoding.</p> <p>Returns:</p> <ul> <li> <code>Exception</code>           \u2013            <p>The deserialized exception.</p> </li> </ul> Source code in <code>academy/message.py</code> <pre><code>def get_exception(self) -&gt; Exception:\n    \"\"\"Get the exception.\n\n    Lazily deserializes and returns the exception object.\n    Caches the result to avoid redundant decoding.\n\n    Returns:\n        The deserialized exception.\n    \"\"\"\n    if isinstance(self.exception, str):\n        self.exception = pickle.loads(base64.b64decode(self.exception))\n    return self.exception\n</code></pre>"},{"location":"api/message/#academy.message.SuccessResponse","title":"SuccessResponse  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Success response message.</p> <p>Config:</p> <ul> <li><code>default</code>: <code>DEFAULT_FROZEN_CONFIG</code></li> </ul> <p>Fields:</p> <ul> <li> <code>kind</code>                 (<code>Literal['success-response']</code>)             </li> </ul>"},{"location":"api/message/#academy.message.Header","title":"Header  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Message metadata header.</p> <p>Contains information about the sender, receiver, and message context.</p> <p>Config:</p> <ul> <li><code>default</code>: <code>DEFAULT_FROZEN_CONFIG</code></li> </ul> <p>Fields:</p> <ul> <li> <code>src</code>                 (<code>EntityId</code>)             </li> <li> <code>dest</code>                 (<code>EntityId</code>)             </li> <li> <code>tag</code>                 (<code>UUID</code>)             </li> <li> <code>label</code>                 (<code>UUID | None</code>)             </li> <li> <code>kind</code>                 (<code>Literal['request', 'response']</code>)             </li> </ul>"},{"location":"api/message/#academy.message.Header.src","title":"src  <code>pydantic-field</code>","text":"<pre><code>src: EntityId\n</code></pre> <p>Message source ID.</p>"},{"location":"api/message/#academy.message.Header.dest","title":"dest  <code>pydantic-field</code>","text":"<pre><code>dest: EntityId\n</code></pre> <p>Message destination ID.</p>"},{"location":"api/message/#academy.message.Header.tag","title":"tag  <code>pydantic-field</code>","text":"<pre><code>tag: UUID\n</code></pre> <p>Unique message tag used to match requests and responses.</p>"},{"location":"api/message/#academy.message.Header.label","title":"label  <code>pydantic-field</code>","text":"<pre><code>label: UUID | None = None\n</code></pre> <p>Optional label used to disambiguate response messages when multiple objects (i.e., handles) share the same mailbox. This is a different usage from the <code>tag</code>.</p>"},{"location":"api/message/#academy.message.Header.create_response_header","title":"create_response_header","text":"<pre><code>create_response_header() -&gt; Self\n</code></pre> <p>Create a response header based on the current request header.</p> <p>Swaps the source and destination, retains the tag and label, and sets the kind to 'response'.</p> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>A new header instance with reversed roles.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the current header is already a response.</p> </li> </ul> Source code in <code>academy/message.py</code> <pre><code>def create_response_header(self) -&gt; Self:\n    \"\"\"Create a response header based on the current request header.\n\n    Swaps the source and destination, retains the tag and label,\n    and sets the kind to 'response'.\n\n    Returns:\n        A new header instance with reversed roles.\n\n    Raises:\n        ValueError: If the current header is already a response.\n    \"\"\"\n    if self.kind == 'response':\n        raise ValueError(\n            'Cannot create response header from another response header',\n        )\n    return type(self)(\n        tag=self.tag,\n        src=self.dest,\n        dest=self.src,\n        label=self.label,\n        kind='response',\n    )\n</code></pre>"},{"location":"api/message/#academy.message.Message","title":"Message  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code>, <code>Generic[BodyT]</code></p> <p>A complete message with header and body.</p> <p>Wraps a header and a typed request/response body. Supports lazy deserialization of message bodies, metadata access, and convenient construction.</p> Note <p>The body value is ignored when testing equality or hashing an instance because the body value could be in either a serialized or deserialized state until <code>get_body()</code> is called.</p> <p>Config:</p> <ul> <li><code>default</code>: <code>DEFAULT_MUTABLE_CONFIG</code></li> </ul> <p>Fields:</p> <ul> <li> <code>header</code>                 (<code>Header</code>)             </li> <li> <code>body</code>                 (<code>SkipValidation[BodyT]</code>)             </li> </ul>"},{"location":"api/message/#academy.message.Message.src","title":"src  <code>property</code>","text":"<pre><code>src: EntityId\n</code></pre> <p>Message source ID.</p>"},{"location":"api/message/#academy.message.Message.dest","title":"dest  <code>property</code>","text":"<pre><code>dest: EntityId\n</code></pre> <p>Message destination ID.</p>"},{"location":"api/message/#academy.message.Message.tag","title":"tag  <code>property</code>","text":"<pre><code>tag: UUID\n</code></pre> <p>Message tag.</p>"},{"location":"api/message/#academy.message.Message.label","title":"label  <code>property</code>","text":"<pre><code>label: UUID | None\n</code></pre> <p>Message label.</p>"},{"location":"api/message/#academy.message.Message.create","title":"create  <code>classmethod</code>","text":"<pre><code>create(\n    src: EntityId,\n    dest: EntityId,\n    body: BodyT,\n    *,\n    label: UUID | None = None\n) -&gt; Message[BodyT]\n</code></pre> <p>Create a new message with the specified header and body.</p> <p>Parameters:</p> <ul> <li> <code>src</code>               (<code>EntityId</code>)           \u2013            <p>Source entity ID.</p> </li> <li> <code>dest</code>               (<code>EntityId</code>)           \u2013            <p>Destination entity ID.</p> </li> <li> <code>body</code>               (<code>BodyT</code>)           \u2013            <p>Message body.</p> </li> <li> <code>label</code>               (<code>UUID | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional label for disambiguation.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Message[BodyT]</code>           \u2013            <p>A new message instance.</p> </li> </ul> Source code in <code>academy/message.py</code> <pre><code>@classmethod\ndef create(\n    cls,\n    src: EntityId,\n    dest: EntityId,\n    body: BodyT,\n    *,\n    label: uuid.UUID | None = None,\n) -&gt; Message[BodyT]:\n    \"\"\"Create a new message with the specified header and body.\n\n    Args:\n        src: Source entity ID.\n        dest: Destination entity ID.\n        body: Message body.\n        label: Optional label for disambiguation.\n\n    Returns:\n        A new message instance.\n    \"\"\"\n    if isinstance(body, get_args(Request)):\n        kind = 'request'\n    elif isinstance(body, get_args(Response)):\n        kind = 'response'\n    else:\n        raise AssertionError('Unreachable.')\n    header = Header(src=src, dest=dest, label=label, kind=kind)\n    request: Message[BodyT] = Message(header=header, body=body)\n    return request\n</code></pre>"},{"location":"api/message/#academy.message.Message.create_response","title":"create_response","text":"<pre><code>create_response(body: ResponseT) -&gt; Message[ResponseT]\n</code></pre> <p>Create a response message from this request message.</p> <p>Parameters:</p> <ul> <li> <code>body</code>               (<code>ResponseT</code>)           \u2013            <p>Response message body.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Message[ResponseT]</code>           \u2013            <p>A new response message instance.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If this message is already a response.</p> </li> </ul> Source code in <code>academy/message.py</code> <pre><code>def create_response(self, body: ResponseT) -&gt; Message[ResponseT]:\n    \"\"\"Create a response message from this request message.\n\n    Args:\n        body: Response message body.\n\n    Returns:\n        A new response message instance.\n\n    Raises:\n        ValueError: If this message is already a response.\n    \"\"\"\n    header = self.header.create_response_header()\n    response: Message[ResponseT] = Message(header=header, body=body)\n    return response\n</code></pre>"},{"location":"api/message/#academy.message.Message.get_body","title":"get_body","text":"<pre><code>get_body() -&gt; BodyT\n</code></pre> <p>Return the message body, deserializing if needed.</p> <p>Lazily deserializes and returns the body object. Caches the body to avoid redundant decoding.</p> <p>Returns:</p> <ul> <li> <code>BodyT</code>           \u2013            <p>The deserialized body.</p> </li> </ul> Source code in <code>academy/message.py</code> <pre><code>def get_body(self) -&gt; BodyT:\n    \"\"\"Return the message body, deserializing if needed.\n\n    Lazily deserializes and returns the body object.\n    Caches the body to avoid redundant decoding.\n\n    Returns:\n        The deserialized body.\n    \"\"\"\n    if isinstance(self.body, get_args(Body)):\n        return self.body\n\n    adapter: TypeAdapter[BodyT] = TypeAdapter(Body)\n    body = (\n        adapter.validate_json(self.body)\n        if isinstance(self.body, str)\n        else adapter.validate_python(self.body)\n    )\n    self.body = body\n    return self.body\n</code></pre>"},{"location":"api/message/#academy.message.Message.is_request","title":"is_request","text":"<pre><code>is_request() -&gt; bool\n</code></pre> <p>Check if the message is a request.</p> Source code in <code>academy/message.py</code> <pre><code>def is_request(self) -&gt; bool:\n    \"\"\"Check if the message is a request.\"\"\"\n    return self.header.kind == 'request'\n</code></pre>"},{"location":"api/message/#academy.message.Message.is_response","title":"is_response","text":"<pre><code>is_response() -&gt; bool\n</code></pre> <p>Check if the message is a response.</p> Source code in <code>academy/message.py</code> <pre><code>def is_response(self) -&gt; bool:\n    \"\"\"Check if the message is a response.\"\"\"\n    return self.header.kind == 'response'\n</code></pre>"},{"location":"api/message/#academy.message.Message.model_deserialize","title":"model_deserialize  <code>classmethod</code>","text":"<pre><code>model_deserialize(data: bytes) -&gt; Message[BodyT]\n</code></pre> <p>Deserialize a message from bytes using pickle.</p> Warning <p>This uses pickle and is therefore susceptible to all the typical pickle warnings about code injection.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>bytes</code>)           \u2013            <p>The serialized message as bytes.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Message[BodyT]</code>           \u2013            <p>The deserialized message instance.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If the deserialized object is not a Message.</p> </li> </ul> Source code in <code>academy/message.py</code> <pre><code>@classmethod\ndef model_deserialize(cls, data: bytes) -&gt; Message[BodyT]:\n    \"\"\"Deserialize a message from bytes using pickle.\n\n    Warning:\n        This uses pickle and is therefore susceptible to all the\n        typical pickle warnings about code injection.\n\n    Args:\n        data: The serialized message as bytes.\n\n    Returns:\n        The deserialized message instance.\n\n    Raises:\n        TypeError: If the deserialized object is not a Message.\n    \"\"\"\n    message = pickle.loads(data)\n    if not isinstance(message, cls):\n        raise TypeError(\n            'Deserialized message is not of type Message.',\n        )\n    return message\n</code></pre>"},{"location":"api/message/#academy.message.Message.model_serialize","title":"model_serialize","text":"<pre><code>model_serialize() -&gt; bytes\n</code></pre> <p>Serialize the message to bytes using pickle.</p> Warning <p>This uses pickle and is therefore susceptible to all the typical pickle warnings about code injection.</p> <p>Returns:</p> <ul> <li> <code>bytes</code>           \u2013            <p>The serialized message as bytes.</p> </li> </ul> Source code in <code>academy/message.py</code> <pre><code>def model_serialize(self) -&gt; bytes:\n    \"\"\"Serialize the message to bytes using pickle.\n\n    Warning:\n        This uses pickle and is therefore susceptible to all the\n        typical pickle warnings about code injection.\n\n    Returns:\n        The serialized message as bytes.\n    \"\"\"\n    return pickle.dumps(self)\n</code></pre>"},{"location":"api/message/#academy.message.Message.log_extra","title":"log_extra","text":"<pre><code>log_extra() -&gt; dict[str, object]\n</code></pre> <p>Returns extra info useful in logs about this Message.</p> Source code in <code>academy/message.py</code> <pre><code>def log_extra(self) -&gt; dict[str, object]:\n    \"\"\"Returns extra info useful in logs about this Message.\"\"\"\n    return {\n        'academy.message_type': type(self.body).__name__,\n        'academy.src': self.src,\n        'academy.dest': self.dest,\n        'academy.message_tag': self.tag,\n        'academy.message_label': self.label,\n    }\n</code></pre>"},{"location":"api/mypy_plugin/","title":"academy.mypy_plugin","text":"<code>academy/mypy_plugin.py</code> <p>Academy mypy plugin.</p> <p>This plugin enables mypy to perform static type inference on <code>Handle</code> types.</p> <p><pre><code>from academy.agent import Agent, action\nfrom academy.handle import Handle\n\nclass Example(Agent):\n    @action\n    async def get_value(self) -&gt; int: ...\n\nhandle: Handle[Example]\n\nreveal_type(await handle.get_value())\n# note: Revealed type is \"int\"\n</code></pre> Without the plugin, mypy will default to <code>Any</code>.</p> Note <p>The plugin makes a best effort to warn users about incorrect use of agent handles. This includes raising errors when accessing attributes of a agent, rather than methods, via a handle and when incorrect parameter types are passed to an action. However, the plugin cannot distinguish which callable attributes of a handle are annotated as actions, but this will still produce an error at runtime.</p> <p>Enable the plugin by adding <code>academy.mypy_plugin</code> to the list of plugins in your mypy config file.</p> <ul> <li><code>pyproject.toml</code> <pre><code>[tools.mypy]\nplugins = [\"academy.mypy_plugin\"]\n</code></pre></li> <li><code>mypy.ini</code> and <code>setup.cfg</code> <pre><code>[mypy]\nplugins = academy.mypy_plugin\n</code></pre></li> </ul>"},{"location":"api/runtime/","title":"academy.runtime","text":"<code>academy/runtime.py</code>"},{"location":"api/runtime/#academy.runtime.RuntimeConfig","title":"RuntimeConfig  <code>dataclass</code>","text":"<pre><code>RuntimeConfig(\n    cancel_actions_on_shutdown: bool = True,\n    max_sync_concurrency: int | None = None,\n    raise_loop_errors_on_shutdown: bool = True,\n    shutdown_on_loop_error: bool = True,\n    terminate_on_error: bool = True,\n    terminate_on_success: bool = True,\n)\n</code></pre> <p>Agent runtime configuration.</p> <p>Attributes:</p> <ul> <li> <code>cancel_actions_on_shutdown</code>               (<code>bool</code>)           \u2013            <p>Cancel running actions when the agent is shutdown, otherwise wait for the actions to finish.</p> </li> <li> <code>max_sync_concurrency</code>               (<code>int | None</code>)           \u2013            <p>Maximum number of concurrent sync tasks allowed via <code>Agent.agent_run_sync()</code>. This is used to set the number of threads in a default <code>ThreadPoolExecutor</code>.</p> </li> <li> <code>raise_loop_errors_on_shutdown</code>               (<code>bool</code>)           \u2013            <p>Raise any captured loop errors when the agent is shutdown.</p> </li> <li> <code>shutdown_on_loop_error</code>               (<code>bool</code>)           \u2013            <p>Shutdown the agent if any loop raises an error.</p> </li> <li> <code>terminate_on_error</code>               (<code>bool</code>)           \u2013            <p>Terminate the agent by closing its mailbox permanently if the agent shuts down due to an error.</p> </li> <li> <code>terminate_on_success</code>               (<code>bool</code>)           \u2013            <p>Terminate the agent by closing its mailbox permanently if the agent shuts down without an error.</p> </li> </ul>"},{"location":"api/runtime/#academy.runtime.Runtime","title":"Runtime","text":"<pre><code>Runtime(\n    agent: AgentT,\n    *,\n    exchange_factory: ExchangeFactory[ExchangeTransportT],\n    registration: AgentRegistrationT,\n    config: RuntimeConfig | None = None\n)\n</code></pre> <p>               Bases: <code>Generic[AgentT]</code>, <code>NoPickleMixin</code></p> <p>Agent runtime manager.</p> <p>The runtime is used to execute an agent by managing stateful resources, startup/shutdown, lifecycle hooks, and concurrency.</p> <p>An agent can be run in two ways: <pre><code>runtime = Runtime(agent, ...)\n\n# Option 1: Async context manager\nasync with runtime:\n    ...\n    await runtime.wait_shutdown()\n\n# Option 2: Run until complete\nawait runtime.run_until_complete()\n</code></pre></p> Note <p>A runtime can only be used once, after which attempts to run an agent using the same runtime with raise a <code>RuntimeError</code>.</p> Note <p>If any <code>@loop</code> method raises an error, the agent will be signaled to shutdown if <code>shutdown_on_loop_error</code> is set in the <code>config</code>.</p> <p>Parameters:</p> <ul> <li> <code>agent</code>               (<code>AgentT</code>)           \u2013            <p>Agent that the agent will exhibit.</p> </li> <li> <code>exchange_factory</code>               (<code>ExchangeFactory[ExchangeTransportT]</code>)           \u2013            <p>Message exchange factory.</p> </li> <li> <code>registration</code>               (<code>AgentRegistrationT</code>)           \u2013            <p>Agent registration info returned by the exchange.</p> </li> <li> <code>config</code>               (<code>RuntimeConfig | None</code>, default:                   <code>None</code> )           \u2013            <p>Agent execution parameters.</p> </li> </ul> Source code in <code>academy/runtime.py</code> <pre><code>def __init__(\n    self,\n    agent: AgentT,\n    *,\n    exchange_factory: ae.ExchangeFactory[ExchangeTransportT],\n    registration: AgentRegistrationT,\n    config: RuntimeConfig | None = None,\n) -&gt; None:\n    self.agent_id = registration.agent_id\n    self.agent = agent\n    self.factory = exchange_factory\n    self.registration = registration\n    self.config = config if config is not None else RuntimeConfig()\n\n    self._actions = agent._agent_actions()\n    self._loops = agent._agent_loops()\n\n    self._started_event = asyncio.Event()\n    self._shutdown_event = asyncio.Event()\n    self._shutdown_options = _ShutdownState()\n    self._agent_startup_called = False\n\n    self._action_tasks: dict[uuid.UUID, asyncio.Task[None]] = {}\n    self._loop_tasks: dict[str, asyncio.Task[None]] = {}\n    self._loop_exceptions: list[tuple[str, Exception]] = []\n\n    self._sync_executor = ThreadPoolExecutor(\n        self.config.max_sync_concurrency,\n        thread_name_prefix='agent-sync-executor-thread',\n    )\n\n    self._exchange_client: (\n        ae.AgentExchangeClient[AgentT, ExchangeTransportT] | None\n    ) = None\n    self._exchange_listener_task: asyncio.Task[None] | None = None\n    self.exchange_context_token: (\n        contextvars.Token[ae.ExchangeClient[Any]] | None\n    ) = None\n</code></pre>"},{"location":"api/runtime/#academy.runtime.Runtime.action","title":"action  <code>async</code>","text":"<pre><code>action(\n    action: str,\n    source_id: EntityId,\n    *,\n    args: Any,\n    kwargs: Any\n) -&gt; Any\n</code></pre> <p>Invoke an action of the agent's agent.</p> <p>Parameters:</p> <ul> <li> <code>action</code>               (<code>str</code>)           \u2013            <p>Name of action to invoke.</p> </li> <li> <code>source_id</code>               (<code>EntityId</code>)           \u2013            <p>ID of the source that requested the action.</p> </li> <li> <code>args</code>               (<code>Any</code>)           \u2013            <p>Tuple of positional arguments.</p> </li> <li> <code>kwargs</code>               (<code>Any</code>)           \u2013            <p>Dictionary of keyword arguments.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any</code>           \u2013            <p>Result of the action.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>AttributeError</code>             \u2013            <p>If an action with this name is not implemented by the agent's agent.</p> </li> </ul> Source code in <code>academy/runtime.py</code> <pre><code>async def action(\n    self,\n    action: str,\n    source_id: EntityId,\n    *,\n    args: Any,\n    kwargs: Any,\n) -&gt; Any:\n    \"\"\"Invoke an action of the agent's agent.\n\n    Args:\n        action: Name of action to invoke.\n        source_id: ID of the source that requested the action.\n        args: Tuple of positional arguments.\n        kwargs: Dictionary of keyword arguments.\n\n    Returns:\n        Result of the action.\n\n    Raises:\n        AttributeError: If an action with this name is not implemented by\n            the agent's agent.\n    \"\"\"\n    logger.debug(\n        'Invoking \"%s\" action on %s',\n        action,\n        self.agent_id,\n        extra={\n            'academy.action': action,\n            'academy.agent_id': self.agent_id,\n        },\n    )\n    if action not in self._actions:\n        raise AttributeError(\n            f'{self.agent} does not have an action named \"{action}\".',\n        )\n    action_method = self._actions[action]\n    if action_method._action_method_context:\n        assert self._exchange_client is not None\n        context = ActionContext(source_id, self._exchange_client)\n        return await action_method(*args, context=context, **kwargs)\n    else:\n        return await action_method(*args, **kwargs)\n</code></pre>"},{"location":"api/runtime/#academy.runtime.Runtime.run_until_complete","title":"run_until_complete  <code>async</code>","text":"<pre><code>run_until_complete() -&gt; None\n</code></pre> <p>Run the agent until shutdown.</p> <p>Agent startup involves:</p> <ol> <li>Creates a new exchange client for the agent, and sets the exchange    context to this agent's client for all handles.</li> <li>Sets the runtime context on the agent.</li> <li>Binds all handles of the agent to this agent's exchange client.</li> <li>Schedules a <code>Task</code> to listen for messages in the    agent's mailbox in the exchange. Agent requests will not start    processing until the end of the startup sequence.</li> <li>Schedules a <code>Task</code> for all control loops defined on    the agent. Each task will block until the end of the startup    sequence before starting the loop.</li> <li>Calls    <code>Agent.agent_on_startup()</code>.</li> </ol> <p>After startup succeeds, this method waits for the agent to be shutdown, such as due to a failure in a control loop or receiving a shutdown message.</p> <p>Agent shutdown involves:</p> <ol> <li>Calls    <code>Agent.agent_on_shutdown()</code>.</li> <li>Cancels running control loop tasks.</li> <li>Cancels the mailbox message listener task so no new requests are    received.</li> <li>Waits for any currently executing actions to complete.</li> <li>Terminates the agent's mailbox in the exchange if configured.</li> <li>Restores the exchange context and closes the exchange client.</li> </ol> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>If the agent has already been shutdown.</p> </li> <li> <code>Exception</code>             \u2013            <p>Any exceptions raised during startup, shutdown, or inside of control loops.</p> </li> </ul> Source code in <code>academy/runtime.py</code> <pre><code>async def run_until_complete(self) -&gt; None:\n    \"\"\"Run the agent until shutdown.\n\n    Agent startup involves:\n\n    1. Creates a new exchange client for the agent, and sets the exchange\n       context to this agent's client for all handles.\n    1. Sets the runtime context on the agent.\n    1. Binds all handles of the agent to this agent's exchange client.\n    1. Schedules a [`Task`][asyncio.Task] to listen for messages in the\n       agent's mailbox in the exchange. Agent requests will not start\n       processing until the end of the startup sequence.\n    1. Schedules a [`Task`][asyncio.Task] for all control loops defined on\n       the agent. Each task will block until the end of the startup\n       sequence before starting the loop.\n    1. Calls\n       [`Agent.agent_on_startup()`][academy.agent.Agent.agent_on_startup].\n\n    After startup succeeds, this method waits for the agent to be shutdown,\n    such as due to a failure in a control loop or receiving a shutdown\n    message.\n\n    Agent shutdown involves:\n\n    1. Calls\n       [`Agent.agent_on_shutdown()`][academy.agent.Agent.agent_on_shutdown].\n    1. Cancels running control loop tasks.\n    1. Cancels the mailbox message listener task so no new requests are\n       received.\n    1. Waits for any currently executing actions to complete.\n    1. Terminates the agent's mailbox in the exchange if configured.\n    1. Restores the exchange context and closes the exchange client.\n\n    Raises:\n        RuntimeError: If the agent has already been shutdown.\n        Exception: Any exceptions raised during startup, shutdown, or\n            inside of control loops.\n    \"\"\"\n    async with self:\n        await self.wait_shutdown()\n</code></pre>"},{"location":"api/runtime/#academy.runtime.Runtime.signal_shutdown","title":"signal_shutdown","text":"<pre><code>signal_shutdown(\n    *, expected: bool = True, terminate: bool | None = None\n) -&gt; None\n</code></pre> <p>Signal that the agent should exit.</p> <p>If the agent has not started, this will cause the agent to immediately shutdown when next started. If the agent is shutdown, this has no effect.</p> <p>Parameters:</p> <ul> <li> <code>expected</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If the reason for the shutdown was due to normal expected reasons or due to unexpected errors.</p> </li> <li> <code>terminate</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Optionally override the mailbox termination settings in the run config.</p> </li> </ul> Source code in <code>academy/runtime.py</code> <pre><code>def signal_shutdown(\n    self,\n    *,\n    expected: bool = True,\n    terminate: bool | None = None,\n) -&gt; None:\n    \"\"\"Signal that the agent should exit.\n\n    If the agent has not started, this will cause the agent to immediately\n    shutdown when next started. If the agent is shutdown, this has no\n    effect.\n\n    Args:\n        expected: If the reason for the shutdown was due to normal\n            expected reasons or due to unexpected errors.\n        terminate: Optionally override the mailbox termination settings\n            in the run config.\n    \"\"\"\n    self._shutdown_options = _ShutdownState(\n        expected_shutdown=expected,\n        terminate_override=terminate,\n    )\n    self._shutdown_event.set()\n</code></pre>"},{"location":"api/runtime/#academy.runtime.Runtime.wait_shutdown","title":"wait_shutdown  <code>async</code>","text":"<pre><code>wait_shutdown(timeout: float | None = None) -&gt; None\n</code></pre> <p>Wait for agent shutdown to be signalled.</p> <p>Parameters:</p> <ul> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional timeout in seconds to wait for a shutdown event.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TimeoutError</code>             \u2013            <p>If <code>timeout</code> was exceeded while waiting for agents.</p> </li> </ul> Source code in <code>academy/runtime.py</code> <pre><code>async def wait_shutdown(self, timeout: float | None = None) -&gt; None:\n    \"\"\"Wait for agent shutdown to be signalled.\n\n    Args:\n        timeout: Optional timeout in seconds to wait for a shutdown event.\n\n    Raises:\n        TimeoutError: If `timeout` was exceeded while waiting for agents.\n    \"\"\"\n    try:\n        await asyncio.wait_for(\n            self._shutdown_event.wait(),\n            timeout=timeout,\n        )\n    except asyncio.TimeoutError:\n        # In Python 3.10 and older, asyncio.TimeoutError and TimeoutError\n        # are different error types.\n        raise TimeoutError(\n            f'Agent shutdown was not signalled within {timeout} seconds.',\n        ) from None\n</code></pre>"},{"location":"api/serialize/","title":"academy.serialize","text":"<code>academy/serialize.py</code>"},{"location":"api/serialize/#academy.serialize.NoPickleMixin","title":"NoPickleMixin","text":"<p>Mixin that raises an error if a type is pickled.</p>"},{"location":"api/socket/","title":"academy.socket","text":"<code>academy/socket.py</code>"},{"location":"api/socket/#academy.socket.SocketClosedError","title":"SocketClosedError","text":"<p>               Bases: <code>Exception</code></p> <p>Socket is already closed.</p>"},{"location":"api/socket/#academy.socket.SocketOpenError","title":"SocketOpenError","text":"<p>               Bases: <code>Exception</code></p> <p>Failed to open socket.</p>"},{"location":"api/socket/#academy.socket.SimpleSocket","title":"SimpleSocket","text":"<pre><code>SimpleSocket(\n    reader: StreamReader,\n    writer: StreamWriter,\n    *,\n    timeout: float | None = None\n)\n</code></pre> <p>Simple socket wrapper.</p> <p>Configures a client connection using a non-blocking TCP socket over IPv4. The send and recv methods handle byte encoding, message delimiters, and partial message buffering.</p> Note <p>This class can be used as an async context manager.</p> <p>Parameters:</p> <ul> <li> <code>reader</code>               (<code>StreamReader</code>)           \u2013            <p>Socket reader interface.</p> </li> <li> <code>writer</code>               (<code>StreamWriter</code>)           \u2013            <p>Socket writer interface.</p> </li> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional timeout for socket operations.</p> </li> </ul> Source code in <code>academy/socket.py</code> <pre><code>def __init__(\n    self,\n    reader: asyncio.StreamReader,\n    writer: asyncio.StreamWriter,\n    *,\n    timeout: float | None = None,\n) -&gt; None:\n    self.reader = reader\n    self.writer = writer\n    self.timeout = timeout\n    self.closed = False\n</code></pre>"},{"location":"api/socket/#academy.socket.SimpleSocket.connect","title":"connect  <code>async</code> <code>classmethod</code>","text":"<pre><code>connect(\n    host: str, port: int, *, timeout: float | None = None\n) -&gt; Self\n</code></pre> <p>Establish a new TCP connection.</p> <p>Parameters:</p> <ul> <li> <code>host</code>               (<code>str</code>)           \u2013            <p>Host address to connect to.</p> </li> <li> <code>port</code>               (<code>int</code>)           \u2013            <p>Port to connect to.</p> </li> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Connection establish timeout.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>SocketOpenError</code>             \u2013            <p>If creating the socket fails. The <code>__cause__</code> of the exception will be set to the underlying <code>OSError</code>.</p> </li> </ul> Source code in <code>academy/socket.py</code> <pre><code>@classmethod\nasync def connect(\n    cls,\n    host: str,\n    port: int,\n    *,\n    timeout: float | None = None,\n) -&gt; Self:\n    \"\"\"Establish a new TCP connection.\n\n    Args:\n        host: Host address to connect to.\n        port: Port to connect to.\n        timeout: Connection establish timeout.\n\n    Raises:\n        SocketOpenError: If creating the socket fails. The `__cause__` of\n            the exception will be set to the underlying `OSError`.\n    \"\"\"\n    try:\n        coro = asyncio.open_connection(host, port)\n        reader, writer = await asyncio.wait_for(coro, timeout)\n    except (OSError, asyncio.TimeoutError) as e:\n        raise SocketOpenError() from e\n\n    return cls(reader, writer, timeout=timeout)\n</code></pre>"},{"location":"api/socket/#academy.socket.SimpleSocket.close","title":"close  <code>async</code>","text":"<pre><code>close(shutdown: bool = True) -&gt; None\n</code></pre> <p>Close the socket.</p> <p>Parameters:</p> <ul> <li> <code>shutdown</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Write EOF to the socket.</p> </li> </ul> Source code in <code>academy/socket.py</code> <pre><code>async def close(self, shutdown: bool = True) -&gt; None:\n    \"\"\"Close the socket.\n\n    Args:\n        shutdown: Write EOF to the socket.\n    \"\"\"\n    if self.closed:\n        return\n    self.closed = True\n    if shutdown and not self.writer.is_closing():\n        self.writer.write_eof()\n    self.writer.close()\n    await self.writer.wait_closed()\n</code></pre>"},{"location":"api/socket/#academy.socket.SimpleSocket.send","title":"send  <code>async</code>","text":"<pre><code>send(message: bytes) -&gt; None\n</code></pre> <p>Send bytes to the socket.</p> Note <p>This is a noop if the message is empty.</p> <p>Parameters:</p> <ul> <li> <code>message</code>               (<code>bytes</code>)           \u2013            <p>Message to send.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>SocketClosedError</code>             \u2013            <p>If the socket was closed.</p> </li> <li> <code>OSError</code>             \u2013            <p>If an error occurred.</p> </li> </ul> Source code in <code>academy/socket.py</code> <pre><code>async def send(self, message: bytes) -&gt; None:\n    \"\"\"Send bytes to the socket.\n\n    Note:\n        This is a noop if the message is empty.\n\n    Args:\n        message: Message to send.\n\n    Raises:\n        SocketClosedError: If the socket was closed.\n        OSError: If an error occurred.\n    \"\"\"\n    if self.closed or self.writer.is_closing():\n        raise SocketClosedError()\n\n    if not message:\n        return\n\n    header = _make_header(message)\n    self.writer.write(header)\n    await self.writer.drain()\n\n    sent_size = 0\n    message_size = len(message)\n    while sent_size &lt; message_size:\n        nbytes = min(message_size - sent_size, MESSAGE_CHUNK_SIZE)\n        chunk = message[sent_size : sent_size + nbytes]\n        self.writer.write(chunk)\n        await self.writer.drain()\n        sent_size += len(chunk)\n</code></pre>"},{"location":"api/socket/#academy.socket.SimpleSocket.send_string","title":"send_string  <code>async</code>","text":"<pre><code>send_string(message: str) -&gt; None\n</code></pre> <p>Send a string to the socket.</p> <p>Strings are encoded with UTF-8.</p> <p>Parameters:</p> <ul> <li> <code>message</code>               (<code>str</code>)           \u2013            <p>Message to send.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>SocketClosedError</code>             \u2013            <p>if the socket was closed.</p> </li> <li> <code>OSError</code>             \u2013            <p>if an error occurred.</p> </li> </ul> Source code in <code>academy/socket.py</code> <pre><code>async def send_string(self, message: str) -&gt; None:\n    \"\"\"Send a string to the socket.\n\n    Strings are encoded with UTF-8.\n\n    Args:\n        message: Message to send.\n\n    Raises:\n        SocketClosedError: if the socket was closed.\n        OSError: if an error occurred.\n    \"\"\"\n    await self.send(message.encode('utf-8'))\n</code></pre>"},{"location":"api/socket/#academy.socket.SimpleSocket.recv","title":"recv  <code>async</code>","text":"<pre><code>recv() -&gt; bytes\n</code></pre> <p>Receive the next message from the socket.</p> <p>Returns:</p> <ul> <li> <code>bytes</code>           \u2013            <p>Bytes containing the message.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>SocketClosedError</code>             \u2013            <p>if the socket was closed.</p> </li> <li> <code>OSError</code>             \u2013            <p>if an error occurred.</p> </li> </ul> Source code in <code>academy/socket.py</code> <pre><code>async def recv(self) -&gt; bytes:\n    \"\"\"Receive the next message from the socket.\n\n    Returns:\n        Bytes containing the message.\n\n    Raises:\n        SocketClosedError: if the socket was closed.\n        OSError: if an error occurred.\n    \"\"\"\n    if self.closed:\n        raise SocketClosedError()\n\n    header = await self.reader.readexactly(MESSAGE_HEADER_SIZE)\n    message_size = _get_size_from_header(header)\n\n    buffer = bytearray(message_size)\n    received = 0\n    while received &lt; message_size:\n        nbytes = min(message_size - received, MESSAGE_CHUNK_SIZE)\n        chunk = await self.reader.readexactly(nbytes)\n        buffer[received : received + len(chunk)] = chunk\n        received += len(chunk)\n\n    return buffer\n</code></pre>"},{"location":"api/socket/#academy.socket.SimpleSocket.recv_string","title":"recv_string  <code>async</code>","text":"<pre><code>recv_string() -&gt; str\n</code></pre> <p>Receive the next message from the socket.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>Message decoded as a UTF-8 string.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>SocketClosedError</code>             \u2013            <p>if the socket was closed.</p> </li> <li> <code>OSError</code>             \u2013            <p>if an error occurred.</p> </li> </ul> Source code in <code>academy/socket.py</code> <pre><code>async def recv_string(self) -&gt; str:\n    \"\"\"Receive the next message from the socket.\n\n    Returns:\n        Message decoded as a UTF-8 string.\n\n    Raises:\n        SocketClosedError: if the socket was closed.\n        OSError: if an error occurred.\n    \"\"\"\n    return (await self.recv()).decode('utf-8')\n</code></pre>"},{"location":"api/socket/#academy.socket.SocketPool","title":"SocketPool","text":"<pre><code>SocketPool()\n</code></pre> <p>Simple socket pool.</p> Source code in <code>academy/socket.py</code> <pre><code>def __init__(self) -&gt; None:\n    self._sockets: dict[str, SimpleSocket] = {}\n    self._lock = asyncio.Lock()\n</code></pre>"},{"location":"api/socket/#academy.socket.SocketPool.close","title":"close  <code>async</code>","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close all the sockets in the pool.</p> Source code in <code>academy/socket.py</code> <pre><code>async def close(self) -&gt; None:\n    \"\"\"Close all the sockets in the pool.\"\"\"\n    for address in tuple(self._sockets.keys()):\n        await self.close_socket(address)\n</code></pre>"},{"location":"api/socket/#academy.socket.SocketPool.close_socket","title":"close_socket  <code>async</code>","text":"<pre><code>close_socket(address: str) -&gt; None\n</code></pre> <p>Close the socket for the given address.</p> Source code in <code>academy/socket.py</code> <pre><code>async def close_socket(self, address: str) -&gt; None:\n    \"\"\"Close the socket for the given address.\"\"\"\n    async with self._lock:\n        conn = self._sockets.pop(address, None)\n    if conn is not None:  # pragma: no branch\n        await conn.close(shutdown=True)\n</code></pre>"},{"location":"api/socket/#academy.socket.SocketPool.get_socket","title":"get_socket  <code>async</code>","text":"<pre><code>get_socket(address: str) -&gt; SimpleSocket\n</code></pre> <p>Get or create a socket for a given address.</p> Source code in <code>academy/socket.py</code> <pre><code>async def get_socket(self, address: str) -&gt; SimpleSocket:\n    \"\"\"Get or create a socket for a given address.\"\"\"\n    async with self._lock:\n        try:\n            return self._sockets[address]\n        except KeyError:\n            parts = address.split(':')\n            host, port = parts[0], int(parts[1])\n            conn = await SimpleSocket.connect(host, port)\n            self._sockets[address] = conn\n            return conn\n</code></pre>"},{"location":"api/socket/#academy.socket.SocketPool.send","title":"send  <code>async</code>","text":"<pre><code>send(address: str, message: bytes) -&gt; None\n</code></pre> <p>Send a message to a given address.</p> Source code in <code>academy/socket.py</code> <pre><code>async def send(self, address: str, message: bytes) -&gt; None:\n    \"\"\"Send a message to a given address.\"\"\"\n    conn = await self.get_socket(address)\n    try:\n        await conn.send(message)\n    except (SocketClosedError, OSError):\n        await self.close_socket(address)\n        raise\n</code></pre>"},{"location":"api/socket/#academy.socket.SimpleSocketServer","title":"SimpleSocketServer","text":"<pre><code>SimpleSocketServer(\n    handler: Callable[[bytes], Awaitable[bytes | None]],\n    *,\n    host: str = \"0.0.0.0\",\n    port: int | None = None\n)\n</code></pre> <p>Simple asyncio TCP socket server.</p> <p>Parameters:</p> <ul> <li> <code>handler</code>               (<code>Callable[[bytes], Awaitable[bytes | None]]</code>)           \u2013            <p>Callback that handles a message and returns the response string. The handler is called synchronously within the client handler so it should not perform any heavy/blocking operations.</p> </li> <li> <code>host</code>               (<code>str</code>, default:                   <code>'0.0.0.0'</code> )           \u2013            <p>Host to bind to.</p> </li> <li> <code>port</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Port to bind to. If <code>None</code>, a random port is bound to.</p> </li> </ul> Source code in <code>academy/socket.py</code> <pre><code>def __init__(\n    self,\n    handler: Callable[[bytes], Awaitable[bytes | None]],\n    *,\n    host: str = '0.0.0.0',\n    port: int | None = None,\n) -&gt; None:\n    self.host = host\n    self.port = port if port is not None else open_port()\n    self.handler = handler\n    self._client_tasks: set[asyncio.Task[None]] = set()\n</code></pre>"},{"location":"api/socket/#academy.socket.SimpleSocketServer.serve","title":"serve  <code>async</code>","text":"<pre><code>serve() -&gt; AsyncGenerator[Self]\n</code></pre> <p>Serve in a context manager.</p> Source code in <code>academy/socket.py</code> <pre><code>@asynccontextmanager\nasync def serve(self) -&gt; AsyncGenerator[Self]:\n    \"\"\"Serve in a context manager.\"\"\"\n    server = await asyncio.start_server(\n        self._register_client_task,\n        host=self.host,\n        port=self.port,\n    )\n    logger.debug(\n        'TCP server listening at %s:%s',\n        self.host,\n        self.port,\n        extra={'academy.host': self.host, 'academy.port': self.port},\n    )\n\n    async with server:\n        await server.start_serving()\n\n        yield self\n\n        for task in tuple(self._client_tasks):\n            task.cancel('Server has been closed.')\n            with contextlib.suppress(asyncio.CancelledError):\n                await task\n\n    if sys.version_info &gt;= (3, 13):  # pragma: &gt;=3.13 cover\n        server.close_clients()\n    logger.debug(\n        'TCP server finished at %s:%s',\n        self.host,\n        self.port,\n        extra={'academy.host': self.host, 'academy.port': self.port},\n    )\n</code></pre>"},{"location":"api/socket/#academy.socket.address_by_hostname","title":"address_by_hostname","text":"<pre><code>address_by_hostname() -&gt; str\n</code></pre> <p>Get the IP address from the hostname of the local host.</p> Source code in <code>academy/socket.py</code> <pre><code>def address_by_hostname() -&gt; str:\n    \"\"\"Get the IP address from the hostname of the local host.\"\"\"\n    return socket.gethostbyname(platform.node())\n</code></pre>"},{"location":"api/socket/#academy.socket.address_by_interface","title":"address_by_interface","text":"<pre><code>address_by_interface(ifname: str) -&gt; str\n</code></pre> <p>Get the IP address of the given interface.</p> <p>Source: https://stackoverflow.com/questions/24196932/how-can-i-get-the-ip-address-of-eth0-in-python#24196955</p> <p>Parameters:</p> <ul> <li> <code>ifname</code>               (<code>str</code>)           \u2013            <p>Name of the interface whose address is to be returned.</p> </li> </ul> Source code in <code>academy/socket.py</code> <pre><code>def address_by_interface(ifname: str) -&gt; str:  # pragma: darwin no cover\n    \"\"\"Get the IP address of the given interface.\n\n    Source: https://stackoverflow.com/questions/24196932/how-can-i-get-the-ip-address-of-eth0-in-python#24196955\n\n    Args:\n        ifname: Name of the interface whose address is to be returned.\n    \"\"\"\n    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    return socket.inet_ntoa(\n        fcntl.ioctl(\n            s.fileno(),\n            0x8915,  # SIOCGIFADDR\n            struct.pack('256s', bytes(ifname[:15], 'utf-8')),\n        )[20:24],\n    )\n</code></pre>"},{"location":"api/socket/#academy.socket.open_port","title":"open_port","text":"<pre><code>open_port() -&gt; int\n</code></pre> <p>Return open port.</p> <p>Source: https://stackoverflow.com/questions/2838244</p> Source code in <code>academy/socket.py</code> <pre><code>def open_port() -&gt; int:\n    \"\"\"Return open port.\n\n    Source: https://stackoverflow.com/questions/2838244\n    \"\"\"\n    while True:\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        s.bind(('', 0))\n        s.listen(1)\n        port = s.getsockname()[1]\n        s.close()\n        if port not in _used_ports:  # pragma: no branch\n            _used_ports.add(port)\n            return port\n</code></pre>"},{"location":"api/socket/#academy.socket.wait_connection","title":"wait_connection","text":"<pre><code>wait_connection(\n    host: str,\n    port: int,\n    *,\n    sleep: float = 0.01,\n    timeout: float | None = None\n) -&gt; None\n</code></pre> <p>Wait for a socket connection to be established.</p> <p>Repeatedly tries to open and close a socket connection to <code>host:port</code>. If successful, the function returns. If unsuccessful before the timeout, a <code>TimeoutError</code> is raised. The function will sleep for <code>sleep</code> seconds in between successive connection attempts.</p> <p>Parameters:</p> <ul> <li> <code>host</code>               (<code>str</code>)           \u2013            <p>Host address to connect to.</p> </li> <li> <code>port</code>               (<code>int</code>)           \u2013            <p>Host port to connect to.</p> </li> <li> <code>sleep</code>               (<code>float</code>, default:                   <code>0.01</code> )           \u2013            <p>Seconds to sleep after unsuccessful connections.</p> </li> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Maximum number of seconds to wait for successful connections.</p> </li> </ul> Source code in <code>academy/socket.py</code> <pre><code>def wait_connection(\n    host: str,\n    port: int,\n    *,\n    sleep: float = 0.01,\n    timeout: float | None = None,\n) -&gt; None:\n    \"\"\"Wait for a socket connection to be established.\n\n    Repeatedly tries to open and close a socket connection to `host:port`.\n    If successful, the function returns. If unsuccessful before the timeout,\n    a `TimeoutError` is raised. The function will sleep for `sleep` seconds\n    in between successive connection attempts.\n\n    Args:\n        host: Host address to connect to.\n        port: Host port to connect to.\n        sleep: Seconds to sleep after unsuccessful connections.\n        timeout: Maximum number of seconds to wait for successful connections.\n    \"\"\"\n    sleep = min(sleep, timeout) if timeout is not None else sleep\n    waited = 0.0\n\n    while True:\n        try:\n            start = time.perf_counter()\n            with socket.create_connection((host, port), timeout=timeout):\n                break\n        except OSError as e:\n            connection_time = time.perf_counter() - start\n            waited += connection_time\n            if timeout is not None and waited &gt;= timeout:\n                raise TimeoutError from e\n            time.sleep(sleep)\n            waited += sleep\n</code></pre>"},{"location":"api/state/","title":"academy.state","text":"<code>academy/state.py</code>"},{"location":"api/state/#academy.state.FileState","title":"FileState","text":"<pre><code>FileState(\n    filename: str | Path,\n    *,\n    flag: Literal[\"r\", \"w\", \"c\", \"n\"] = \"c\",\n    protocol: int | None = DEFAULT_PICKLE_PROTOCOL,\n    writeback: bool = False\n)\n</code></pre> <p>               Bases: <code>DbfilenameShelf[ValueT]</code></p> <p>Dictionary interface for persistent state.</p> <p>Persists arbitrary Python objects to disk using pickle and a dbm database.</p> Note <p>This class uses the shelve module so refer there for additional caveats.</p> Example <pre><code>from typing import Any\nfrom academy.agent import Agent, action\nfrom academy.state import FileState\n\nclass Example(Agent):\n    def __init__(self, state_path: str) -&gt; None:\n        super().__init__()\n        self.state: FileState[Any] = FileState(state_path)\n\n    def agent_on_shutdown(self) -&gt; None:\n        self.state.close()\n\n    @action\n    def get_state(self, key: str) -&gt; Any:\n        return self.state[key]\n\n    @action\n    def modify_state(self, key: str, value: Any) -&gt; None:\n        self.state[key] = value\n</code></pre> Note <p>When using the <code>Manager</code>, use the deferred agent initialization to ensure that the state is initialized on the worker, rather than the client.</p> <pre><code>from academy.manager import Manager\n\nasync with Manager(...) as manager:\n    handle = manager.launch(Example, args=('/tmp/agent-state.dbm',))\n</code></pre> <p>Parameters:</p> <ul> <li> <code>filename</code>               (<code>str | Path</code>)           \u2013            <p>Base filename for the underlying databased used to store key-value pairs.</p> </li> <li> <code>flag</code>               (<code>Literal['r', 'w', 'c', 'n']</code>, default:                   <code>'c'</code> )           \u2013            <p>Open an existing database read-only: <code>r</code>; open an existing database for read and write: <code>w</code>; open a database for read and write, creating it if not existent: <code>c</code> (default); always create a new empty database for read and write: <code>n</code>.</p> </li> <li> <code>protocol</code>               (<code>int | None</code>, default:                   <code>DEFAULT_PICKLE_PROTOCOL</code> )           \u2013            <p>Pickling protocol. Defaults to version 5; <code>None</code> uses the pickle default version.</p> </li> <li> <code>writeback</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>By default (<code>False</code>), modified objects are only written when assigned. If <code>True</code>, the object will hold a cache of all entries accessed and write them back to the dict at sync and close times. This allows natural operations on mutable entries, but can consume much more memory and make sync and close take a long time.</p> </li> </ul> Source code in <code>academy/state.py</code> <pre><code>def __init__(\n    self,\n    filename: str | pathlib.Path,\n    *,\n    flag: Literal['r', 'w', 'c', 'n'] = 'c',\n    protocol: int | None = DEFAULT_PICKLE_PROTOCOL,\n    writeback: bool = False,\n) -&gt; None:\n    super().__init__(\n        str(filename),\n        flag=flag,\n        protocol=protocol,\n        writeback=writeback,\n    )\n</code></pre>"},{"location":"api/task/","title":"academy.task","text":"<code>academy/task.py</code>"},{"location":"api/task/#academy.task.SafeTaskExitError","title":"SafeTaskExitError","text":"<p>               Bases: <code>Exception</code></p> <p>Exception that can be raised inside a task to safely exit it.</p>"},{"location":"api/task/#academy.task.spawn_guarded_background_task","title":"spawn_guarded_background_task","text":"<pre><code>spawn_guarded_background_task(\n    coro: Coroutine[Any, Any, Any],\n    *,\n    name: str,\n    log_exception: bool = True\n) -&gt; Task[Any]\n</code></pre> <p>Run a coroutine safely in the background.</p> <p>Launches the coroutine as an asyncio task. Optionally attaches logging to any exception raised, and/or exiting on any exception raised. Tasks can raise <code>SafeTaskExit</code> to signal the task is finished but should not cause a system exit.</p> <p>Source: https://stackoverflow.com/questions/62588076</p> <p>Parameters:</p> <ul> <li> <code>coro</code>               (<code>Coroutine[Any, Any, Any]</code>)           \u2013            <p>Coroutine to run as task.</p> </li> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>name of background task. Unlike asyncio.create_task, this is required</p> </li> <li> <code>log_exception</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Write exception to the log. Set to false if exceptions are already logged by coro.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Task[Any]</code>           \u2013            <p>Asyncio task.</p> </li> </ul> Source code in <code>academy/task.py</code> <pre><code>def spawn_guarded_background_task(\n    coro: Coroutine[Any, Any, Any],\n    *,\n    name: str,\n    log_exception: bool = True,\n) -&gt; asyncio.Task[Any]:\n    \"\"\"Run a coroutine safely in the background.\n\n    Launches the coroutine as an asyncio task. Optionally attaches logging\n    to any exception raised, and/or exiting on any exception raised.\n    Tasks can raise [`SafeTaskExit`][academy.task.SafeTaskExitError]\n    to signal the task is finished but should not cause a system exit.\n\n    Source: https://stackoverflow.com/questions/62588076\n\n    Args:\n        coro: Coroutine to run as task.\n        name: name of background task. Unlike asyncio.create_task, this is\n            required\n        log_exception: Write exception to the log. Set to false if exceptions\n            are already logged by coro.\n\n    Returns:\n        Asyncio task.\n    \"\"\"\n    if log_exception:\n        fut = asyncio.ensure_future(coro)\n        coro = execute_and_log_traceback(fut)\n\n    task = asyncio.create_task(\n        coro,\n        name=name,\n    )\n    task.add_done_callback(_exit_on_error)\n\n    return task\n</code></pre>"},{"location":"api/exchange/","title":"academy.exchange","text":"<code>academy/exchange/__init__.py</code>"},{"location":"api/exchange/#academy.exchange.AgentExchangeClient","title":"AgentExchangeClient","text":"<pre><code>AgentExchangeClient(\n    agent_id: AgentId[AgentT],\n    transport: ExchangeTransportT,\n    request_handler: RequestHandler[RequestT_co],\n)\n</code></pre> <p>               Bases: <code>ExchangeClient[ExchangeTransportT]</code>, <code>Generic[AgentT, ExchangeTransportT]</code></p> <p>Agent exchange client.</p> Warning <p>Agent exchange clients should only be created via <code>ExchangeFactory.create_agent_client()</code>!</p> <p>Parameters:</p> <ul> <li> <code>agent_id</code>               (<code>AgentId[AgentT]</code>)           \u2013            <p>Agent ID.</p> </li> <li> <code>transport</code>               (<code>ExchangeTransportT</code>)           \u2013            <p>Exchange transport bound to <code>agent_id</code>.</p> </li> <li> <code>request_handler</code>               (<code>RequestHandler[RequestT_co]</code>)           \u2013            <p>Request handler of the agent that will be called for each message received to this agent's mailbox. start_listener: Start a message listener thread.</p> </li> </ul> Source code in <code>academy/exchange/client.py</code> <pre><code>def __init__(\n    self,\n    agent_id: AgentId[AgentT],\n    transport: ExchangeTransportT,\n    request_handler: RequestHandler[RequestT_co],\n) -&gt; None:\n    super().__init__(transport)\n    self._agent_id = agent_id\n    self._request_handler = request_handler\n</code></pre>"},{"location":"api/exchange/#academy.exchange.AgentExchangeClient.client_id","title":"client_id  <code>property</code>","text":"<pre><code>client_id: AgentId[AgentT]\n</code></pre> <p>Agent ID of the client.</p>"},{"location":"api/exchange/#academy.exchange.AgentExchangeClient.discover","title":"discover  <code>async</code>","text":"<pre><code>discover(\n    agent: type[Agent], *, allow_subclasses: bool = True\n) -&gt; tuple[AgentId[Any], ...]\n</code></pre> <p>Discover peer agents with a given agent.</p> <p>Parameters:</p> <ul> <li> <code>agent</code>               (<code>type[Agent]</code>)           \u2013            <p>Agent type of interest.</p> </li> <li> <code>allow_subclasses</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Return agents implementing subclasses of the agent.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[AgentId[Any], ...]</code>           \u2013            <p>Tuple of agent IDs implementing the agent.</p> </li> </ul> Source code in <code>academy/exchange/client.py</code> <pre><code>async def discover(\n    self,\n    agent: type[Agent],\n    *,\n    allow_subclasses: bool = True,\n) -&gt; tuple[AgentId[Any], ...]:\n    \"\"\"Discover peer agents with a given agent.\n\n    Args:\n        agent: Agent type of interest.\n        allow_subclasses: Return agents implementing subclasses of the\n            agent.\n\n    Returns:\n        Tuple of agent IDs implementing the agent.\n    \"\"\"\n    return await self._transport.discover(\n        agent,\n        allow_subclasses=allow_subclasses,\n    )\n</code></pre>"},{"location":"api/exchange/#academy.exchange.AgentExchangeClient.factory","title":"factory","text":"<pre><code>factory() -&gt; ExchangeFactory[ExchangeTransportT]\n</code></pre> <p>Get an exchange factory.</p> Source code in <code>academy/exchange/client.py</code> <pre><code>def factory(self) -&gt; ExchangeFactory[ExchangeTransportT]:\n    \"\"\"Get an exchange factory.\"\"\"\n    return self._transport.factory()\n</code></pre>"},{"location":"api/exchange/#academy.exchange.AgentExchangeClient.register_handle","title":"register_handle","text":"<pre><code>register_handle(handle: Handle[AgentT]) -&gt; None\n</code></pre> <p>Register an existing handle to receive messages.</p> <p>Parameters:</p> <ul> <li> <code>handle</code>               (<code>Handle[AgentT]</code>)           \u2013            <p>Handle to register.</p> </li> </ul> Source code in <code>academy/exchange/client.py</code> <pre><code>def register_handle(self, handle: Handle[AgentT]) -&gt; None:\n    \"\"\"Register an existing handle to receive messages.\n\n    Args:\n        handle: Handle to register.\n    \"\"\"\n    self._handles[handle.handle_id] = handle\n</code></pre>"},{"location":"api/exchange/#academy.exchange.AgentExchangeClient.register_agent","title":"register_agent  <code>async</code>","text":"<pre><code>register_agent(\n    agent: type[AgentT], *, name: str | None = None\n) -&gt; AgentRegistration[AgentT]\n</code></pre> <p>Register a new agent and associated mailbox with the exchange.</p> <p>Parameters:</p> <ul> <li> <code>agent</code>               (<code>type[AgentT]</code>)           \u2013            <p>Agent type of the agent.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional display name for the agent.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AgentRegistration[AgentT]</code>           \u2013            <p>Agent registration info.</p> </li> </ul> Source code in <code>academy/exchange/client.py</code> <pre><code>async def register_agent(\n    self,\n    agent: type[AgentT],\n    *,\n    name: str | None = None,\n) -&gt; AgentRegistration[AgentT]:\n    \"\"\"Register a new agent and associated mailbox with the exchange.\n\n    Args:\n        agent: Agent type of the agent.\n        name: Optional display name for the agent.\n\n    Returns:\n        Agent registration info.\n    \"\"\"\n    registration = await self._transport.register_agent(\n        agent,\n        name=name,\n    )\n    logger.info(\n        'Registered %s in exchange',\n        registration.agent_id,\n        extra={'academy.agent_id': registration.agent_id},\n    )\n    return registration\n</code></pre>"},{"location":"api/exchange/#academy.exchange.AgentExchangeClient.send","title":"send  <code>async</code>","text":"<pre><code>send(message: Message[Any]) -&gt; None\n</code></pre> <p>Send a message to a mailbox.</p> <p>Parameters:</p> <ul> <li> <code>message</code>               (<code>Message[Any]</code>)           \u2013            <p>Message to send.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BadEntityIdError</code>             \u2013            <p>If a mailbox for <code>message.dest</code> does not exist.</p> </li> <li> <code>MailboxTerminatedError</code>             \u2013            <p>If the mailbox was closed.</p> </li> </ul> Source code in <code>academy/exchange/client.py</code> <pre><code>async def send(self, message: Message[Any]) -&gt; None:\n    \"\"\"Send a message to a mailbox.\n\n    Args:\n        message: Message to send.\n\n    Raises:\n        BadEntityIdError: If a mailbox for `message.dest` does not exist.\n        MailboxTerminatedError: If the mailbox was closed.\n    \"\"\"\n    await self._transport.send(message)\n    logger.debug(\n        'Sent %s to %s',\n        type(message.body).__name__,\n        message.dest,\n        extra=message.log_extra(),\n    )\n</code></pre>"},{"location":"api/exchange/#academy.exchange.AgentExchangeClient.status","title":"status  <code>async</code>","text":"<pre><code>status(uid: EntityId) -&gt; MailboxStatus\n</code></pre> <p>Check the status of a mailbox in the exchange.</p> <p>Parameters:</p> <ul> <li> <code>uid</code>               (<code>EntityId</code>)           \u2013            <p>Entity identifier of the mailbox to check.</p> </li> </ul> Source code in <code>academy/exchange/client.py</code> <pre><code>async def status(self, uid: EntityId) -&gt; MailboxStatus:\n    \"\"\"Check the status of a mailbox in the exchange.\n\n    Args:\n        uid: Entity identifier of the mailbox to check.\n    \"\"\"\n    return await self._transport.status(uid)\n</code></pre>"},{"location":"api/exchange/#academy.exchange.AgentExchangeClient.terminate","title":"terminate  <code>async</code>","text":"<pre><code>terminate(uid: EntityId) -&gt; None\n</code></pre> <p>Terminate a mailbox in the exchange.</p> <p>Terminating a mailbox means that the corresponding entity will no longer be able to receive messages.</p> Note <p>This method is a no-op if the mailbox does not exist.</p> <p>Parameters:</p> <ul> <li> <code>uid</code>               (<code>EntityId</code>)           \u2013            <p>Entity identifier of the mailbox to close.</p> </li> </ul> Source code in <code>academy/exchange/client.py</code> <pre><code>async def terminate(self, uid: EntityId) -&gt; None:\n    \"\"\"Terminate a mailbox in the exchange.\n\n    Terminating a mailbox means that the corresponding entity will no\n    longer be able to receive messages.\n\n    Note:\n        This method is a no-op if the mailbox does not exist.\n\n    Args:\n        uid: Entity identifier of the mailbox to close.\n    \"\"\"\n    await self._transport.terminate(uid)\n</code></pre>"},{"location":"api/exchange/#academy.exchange.AgentExchangeClient.close","title":"close  <code>async</code>","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the user client.</p> <p>This closes the underlying exchange transport and all handles created by this client. The agent's mailbox will not be terminated so the agent can be started again later.</p> Source code in <code>academy/exchange/client.py</code> <pre><code>async def close(self) -&gt; None:\n    \"\"\"Close the user client.\n\n    This closes the underlying exchange transport and all handles created\n    by this client. The agent's mailbox will not be terminated so the agent\n    can be started again later.\n    \"\"\"\n    async with self._close_lock:\n        if self._closed:\n            return\n\n        await self._transport.close()\n        self._closed = True\n        logger.info(\n            'Closed exchange client for %s',\n            self.client_id,\n            extra={'academy.mailbox_id': self.client_id},\n        )\n</code></pre>"},{"location":"api/exchange/#academy.exchange.ExchangeClient","title":"ExchangeClient","text":"<pre><code>ExchangeClient(transport: ExchangeTransportT)\n</code></pre> <p>               Bases: <code>ABC</code>, <code>Generic[ExchangeTransportT]</code></p> <p>Base exchange client.</p> Warning <p>Exchange clients should only be created via <code>ExchangeFactory.create_agent_client()</code> or <code>ExchangeFactory.create_user_client()</code>!</p> <p>Parameters:</p> <ul> <li> <code>transport</code>               (<code>ExchangeTransportT</code>)           \u2013            <p>Exchange transport bound to a mailbox.</p> </li> </ul> Source code in <code>academy/exchange/client.py</code> <pre><code>def __init__(\n    self,\n    transport: ExchangeTransportT,\n) -&gt; None:\n    self._transport = transport\n    self._handles: WeakValueDictionary[uuid.UUID, Handle[Any]] = (\n        WeakValueDictionary()\n    )\n    self._close_lock = asyncio.Lock()\n    self._closed = False\n</code></pre>"},{"location":"api/exchange/#academy.exchange.ExchangeClient.client_id","title":"client_id  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>client_id: EntityId\n</code></pre> <p>Client ID as registered with the exchange.</p>"},{"location":"api/exchange/#academy.exchange.ExchangeClient.close","title":"close  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the transport.</p> Source code in <code>academy/exchange/client.py</code> <pre><code>@abc.abstractmethod\nasync def close(self) -&gt; None:\n    \"\"\"Close the transport.\"\"\"\n    ...\n</code></pre>"},{"location":"api/exchange/#academy.exchange.ExchangeClient.discover","title":"discover  <code>async</code>","text":"<pre><code>discover(\n    agent: type[Agent], *, allow_subclasses: bool = True\n) -&gt; tuple[AgentId[Any], ...]\n</code></pre> <p>Discover peer agents with a given agent.</p> <p>Parameters:</p> <ul> <li> <code>agent</code>               (<code>type[Agent]</code>)           \u2013            <p>Agent type of interest.</p> </li> <li> <code>allow_subclasses</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Return agents implementing subclasses of the agent.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[AgentId[Any], ...]</code>           \u2013            <p>Tuple of agent IDs implementing the agent.</p> </li> </ul> Source code in <code>academy/exchange/client.py</code> <pre><code>async def discover(\n    self,\n    agent: type[Agent],\n    *,\n    allow_subclasses: bool = True,\n) -&gt; tuple[AgentId[Any], ...]:\n    \"\"\"Discover peer agents with a given agent.\n\n    Args:\n        agent: Agent type of interest.\n        allow_subclasses: Return agents implementing subclasses of the\n            agent.\n\n    Returns:\n        Tuple of agent IDs implementing the agent.\n    \"\"\"\n    return await self._transport.discover(\n        agent,\n        allow_subclasses=allow_subclasses,\n    )\n</code></pre>"},{"location":"api/exchange/#academy.exchange.ExchangeClient.factory","title":"factory","text":"<pre><code>factory() -&gt; ExchangeFactory[ExchangeTransportT]\n</code></pre> <p>Get an exchange factory.</p> Source code in <code>academy/exchange/client.py</code> <pre><code>def factory(self) -&gt; ExchangeFactory[ExchangeTransportT]:\n    \"\"\"Get an exchange factory.\"\"\"\n    return self._transport.factory()\n</code></pre>"},{"location":"api/exchange/#academy.exchange.ExchangeClient.register_handle","title":"register_handle","text":"<pre><code>register_handle(handle: Handle[AgentT]) -&gt; None\n</code></pre> <p>Register an existing handle to receive messages.</p> <p>Parameters:</p> <ul> <li> <code>handle</code>               (<code>Handle[AgentT]</code>)           \u2013            <p>Handle to register.</p> </li> </ul> Source code in <code>academy/exchange/client.py</code> <pre><code>def register_handle(self, handle: Handle[AgentT]) -&gt; None:\n    \"\"\"Register an existing handle to receive messages.\n\n    Args:\n        handle: Handle to register.\n    \"\"\"\n    self._handles[handle.handle_id] = handle\n</code></pre>"},{"location":"api/exchange/#academy.exchange.ExchangeClient.register_agent","title":"register_agent  <code>async</code>","text":"<pre><code>register_agent(\n    agent: type[AgentT], *, name: str | None = None\n) -&gt; AgentRegistration[AgentT]\n</code></pre> <p>Register a new agent and associated mailbox with the exchange.</p> <p>Parameters:</p> <ul> <li> <code>agent</code>               (<code>type[AgentT]</code>)           \u2013            <p>Agent type of the agent.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional display name for the agent.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AgentRegistration[AgentT]</code>           \u2013            <p>Agent registration info.</p> </li> </ul> Source code in <code>academy/exchange/client.py</code> <pre><code>async def register_agent(\n    self,\n    agent: type[AgentT],\n    *,\n    name: str | None = None,\n) -&gt; AgentRegistration[AgentT]:\n    \"\"\"Register a new agent and associated mailbox with the exchange.\n\n    Args:\n        agent: Agent type of the agent.\n        name: Optional display name for the agent.\n\n    Returns:\n        Agent registration info.\n    \"\"\"\n    registration = await self._transport.register_agent(\n        agent,\n        name=name,\n    )\n    logger.info(\n        'Registered %s in exchange',\n        registration.agent_id,\n        extra={'academy.agent_id': registration.agent_id},\n    )\n    return registration\n</code></pre>"},{"location":"api/exchange/#academy.exchange.ExchangeClient.send","title":"send  <code>async</code>","text":"<pre><code>send(message: Message[Any]) -&gt; None\n</code></pre> <p>Send a message to a mailbox.</p> <p>Parameters:</p> <ul> <li> <code>message</code>               (<code>Message[Any]</code>)           \u2013            <p>Message to send.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BadEntityIdError</code>             \u2013            <p>If a mailbox for <code>message.dest</code> does not exist.</p> </li> <li> <code>MailboxTerminatedError</code>             \u2013            <p>If the mailbox was closed.</p> </li> </ul> Source code in <code>academy/exchange/client.py</code> <pre><code>async def send(self, message: Message[Any]) -&gt; None:\n    \"\"\"Send a message to a mailbox.\n\n    Args:\n        message: Message to send.\n\n    Raises:\n        BadEntityIdError: If a mailbox for `message.dest` does not exist.\n        MailboxTerminatedError: If the mailbox was closed.\n    \"\"\"\n    await self._transport.send(message)\n    logger.debug(\n        'Sent %s to %s',\n        type(message.body).__name__,\n        message.dest,\n        extra=message.log_extra(),\n    )\n</code></pre>"},{"location":"api/exchange/#academy.exchange.ExchangeClient.status","title":"status  <code>async</code>","text":"<pre><code>status(uid: EntityId) -&gt; MailboxStatus\n</code></pre> <p>Check the status of a mailbox in the exchange.</p> <p>Parameters:</p> <ul> <li> <code>uid</code>               (<code>EntityId</code>)           \u2013            <p>Entity identifier of the mailbox to check.</p> </li> </ul> Source code in <code>academy/exchange/client.py</code> <pre><code>async def status(self, uid: EntityId) -&gt; MailboxStatus:\n    \"\"\"Check the status of a mailbox in the exchange.\n\n    Args:\n        uid: Entity identifier of the mailbox to check.\n    \"\"\"\n    return await self._transport.status(uid)\n</code></pre>"},{"location":"api/exchange/#academy.exchange.ExchangeClient.terminate","title":"terminate  <code>async</code>","text":"<pre><code>terminate(uid: EntityId) -&gt; None\n</code></pre> <p>Terminate a mailbox in the exchange.</p> <p>Terminating a mailbox means that the corresponding entity will no longer be able to receive messages.</p> Note <p>This method is a no-op if the mailbox does not exist.</p> <p>Parameters:</p> <ul> <li> <code>uid</code>               (<code>EntityId</code>)           \u2013            <p>Entity identifier of the mailbox to close.</p> </li> </ul> Source code in <code>academy/exchange/client.py</code> <pre><code>async def terminate(self, uid: EntityId) -&gt; None:\n    \"\"\"Terminate a mailbox in the exchange.\n\n    Terminating a mailbox means that the corresponding entity will no\n    longer be able to receive messages.\n\n    Note:\n        This method is a no-op if the mailbox does not exist.\n\n    Args:\n        uid: Entity identifier of the mailbox to close.\n    \"\"\"\n    await self._transport.terminate(uid)\n</code></pre>"},{"location":"api/exchange/#academy.exchange.UserExchangeClient","title":"UserExchangeClient","text":"<pre><code>UserExchangeClient(\n    user_id: UserId,\n    transport: ExchangeTransportT,\n    *,\n    start_listener: bool = True\n)\n</code></pre> <p>               Bases: <code>ExchangeClient[ExchangeTransportT]</code></p> <p>User exchange client.</p> Warning <p>User exchange clients should only be created via <code>ExchangeFactory.create_user_client()</code>!</p> <p>Parameters:</p> <ul> <li> <code>user_id</code>               (<code>UserId</code>)           \u2013            <p>User ID.</p> </li> <li> <code>transport</code>               (<code>ExchangeTransportT</code>)           \u2013            <p>Exchange transport bound to <code>user_id</code>.</p> </li> <li> <code>start_listener</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Start a message listener thread.</p> </li> </ul> Source code in <code>academy/exchange/client.py</code> <pre><code>def __init__(\n    self,\n    user_id: UserId,\n    transport: ExchangeTransportT,\n    *,\n    start_listener: bool = True,\n) -&gt; None:\n    super().__init__(transport)\n    self._user_id = user_id\n    self._listener_task: asyncio.Task[None] | None = None\n    if start_listener:\n        self._listener_task = spawn_guarded_background_task(\n            self._listen_for_messages(),\n            name=f'user-exchange-listener-{self.client_id}',\n        )\n</code></pre>"},{"location":"api/exchange/#academy.exchange.UserExchangeClient.client_id","title":"client_id  <code>property</code>","text":"<pre><code>client_id: UserId\n</code></pre> <p>User ID of the client.</p>"},{"location":"api/exchange/#academy.exchange.UserExchangeClient.discover","title":"discover  <code>async</code>","text":"<pre><code>discover(\n    agent: type[Agent], *, allow_subclasses: bool = True\n) -&gt; tuple[AgentId[Any], ...]\n</code></pre> <p>Discover peer agents with a given agent.</p> <p>Parameters:</p> <ul> <li> <code>agent</code>               (<code>type[Agent]</code>)           \u2013            <p>Agent type of interest.</p> </li> <li> <code>allow_subclasses</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Return agents implementing subclasses of the agent.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[AgentId[Any], ...]</code>           \u2013            <p>Tuple of agent IDs implementing the agent.</p> </li> </ul> Source code in <code>academy/exchange/client.py</code> <pre><code>async def discover(\n    self,\n    agent: type[Agent],\n    *,\n    allow_subclasses: bool = True,\n) -&gt; tuple[AgentId[Any], ...]:\n    \"\"\"Discover peer agents with a given agent.\n\n    Args:\n        agent: Agent type of interest.\n        allow_subclasses: Return agents implementing subclasses of the\n            agent.\n\n    Returns:\n        Tuple of agent IDs implementing the agent.\n    \"\"\"\n    return await self._transport.discover(\n        agent,\n        allow_subclasses=allow_subclasses,\n    )\n</code></pre>"},{"location":"api/exchange/#academy.exchange.UserExchangeClient.factory","title":"factory","text":"<pre><code>factory() -&gt; ExchangeFactory[ExchangeTransportT]\n</code></pre> <p>Get an exchange factory.</p> Source code in <code>academy/exchange/client.py</code> <pre><code>def factory(self) -&gt; ExchangeFactory[ExchangeTransportT]:\n    \"\"\"Get an exchange factory.\"\"\"\n    return self._transport.factory()\n</code></pre>"},{"location":"api/exchange/#academy.exchange.UserExchangeClient.register_handle","title":"register_handle","text":"<pre><code>register_handle(handle: Handle[AgentT]) -&gt; None\n</code></pre> <p>Register an existing handle to receive messages.</p> <p>Parameters:</p> <ul> <li> <code>handle</code>               (<code>Handle[AgentT]</code>)           \u2013            <p>Handle to register.</p> </li> </ul> Source code in <code>academy/exchange/client.py</code> <pre><code>def register_handle(self, handle: Handle[AgentT]) -&gt; None:\n    \"\"\"Register an existing handle to receive messages.\n\n    Args:\n        handle: Handle to register.\n    \"\"\"\n    self._handles[handle.handle_id] = handle\n</code></pre>"},{"location":"api/exchange/#academy.exchange.UserExchangeClient.register_agent","title":"register_agent  <code>async</code>","text":"<pre><code>register_agent(\n    agent: type[AgentT], *, name: str | None = None\n) -&gt; AgentRegistration[AgentT]\n</code></pre> <p>Register a new agent and associated mailbox with the exchange.</p> <p>Parameters:</p> <ul> <li> <code>agent</code>               (<code>type[AgentT]</code>)           \u2013            <p>Agent type of the agent.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional display name for the agent.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AgentRegistration[AgentT]</code>           \u2013            <p>Agent registration info.</p> </li> </ul> Source code in <code>academy/exchange/client.py</code> <pre><code>async def register_agent(\n    self,\n    agent: type[AgentT],\n    *,\n    name: str | None = None,\n) -&gt; AgentRegistration[AgentT]:\n    \"\"\"Register a new agent and associated mailbox with the exchange.\n\n    Args:\n        agent: Agent type of the agent.\n        name: Optional display name for the agent.\n\n    Returns:\n        Agent registration info.\n    \"\"\"\n    registration = await self._transport.register_agent(\n        agent,\n        name=name,\n    )\n    logger.info(\n        'Registered %s in exchange',\n        registration.agent_id,\n        extra={'academy.agent_id': registration.agent_id},\n    )\n    return registration\n</code></pre>"},{"location":"api/exchange/#academy.exchange.UserExchangeClient.send","title":"send  <code>async</code>","text":"<pre><code>send(message: Message[Any]) -&gt; None\n</code></pre> <p>Send a message to a mailbox.</p> <p>Parameters:</p> <ul> <li> <code>message</code>               (<code>Message[Any]</code>)           \u2013            <p>Message to send.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BadEntityIdError</code>             \u2013            <p>If a mailbox for <code>message.dest</code> does not exist.</p> </li> <li> <code>MailboxTerminatedError</code>             \u2013            <p>If the mailbox was closed.</p> </li> </ul> Source code in <code>academy/exchange/client.py</code> <pre><code>async def send(self, message: Message[Any]) -&gt; None:\n    \"\"\"Send a message to a mailbox.\n\n    Args:\n        message: Message to send.\n\n    Raises:\n        BadEntityIdError: If a mailbox for `message.dest` does not exist.\n        MailboxTerminatedError: If the mailbox was closed.\n    \"\"\"\n    await self._transport.send(message)\n    logger.debug(\n        'Sent %s to %s',\n        type(message.body).__name__,\n        message.dest,\n        extra=message.log_extra(),\n    )\n</code></pre>"},{"location":"api/exchange/#academy.exchange.UserExchangeClient.status","title":"status  <code>async</code>","text":"<pre><code>status(uid: EntityId) -&gt; MailboxStatus\n</code></pre> <p>Check the status of a mailbox in the exchange.</p> <p>Parameters:</p> <ul> <li> <code>uid</code>               (<code>EntityId</code>)           \u2013            <p>Entity identifier of the mailbox to check.</p> </li> </ul> Source code in <code>academy/exchange/client.py</code> <pre><code>async def status(self, uid: EntityId) -&gt; MailboxStatus:\n    \"\"\"Check the status of a mailbox in the exchange.\n\n    Args:\n        uid: Entity identifier of the mailbox to check.\n    \"\"\"\n    return await self._transport.status(uid)\n</code></pre>"},{"location":"api/exchange/#academy.exchange.UserExchangeClient.terminate","title":"terminate  <code>async</code>","text":"<pre><code>terminate(uid: EntityId) -&gt; None\n</code></pre> <p>Terminate a mailbox in the exchange.</p> <p>Terminating a mailbox means that the corresponding entity will no longer be able to receive messages.</p> Note <p>This method is a no-op if the mailbox does not exist.</p> <p>Parameters:</p> <ul> <li> <code>uid</code>               (<code>EntityId</code>)           \u2013            <p>Entity identifier of the mailbox to close.</p> </li> </ul> Source code in <code>academy/exchange/client.py</code> <pre><code>async def terminate(self, uid: EntityId) -&gt; None:\n    \"\"\"Terminate a mailbox in the exchange.\n\n    Terminating a mailbox means that the corresponding entity will no\n    longer be able to receive messages.\n\n    Note:\n        This method is a no-op if the mailbox does not exist.\n\n    Args:\n        uid: Entity identifier of the mailbox to close.\n    \"\"\"\n    await self._transport.terminate(uid)\n</code></pre>"},{"location":"api/exchange/#academy.exchange.UserExchangeClient.close","title":"close  <code>async</code>","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the user client.</p> <p>This terminates the user's mailbox, closes the underlying exchange transport.</p> Source code in <code>academy/exchange/client.py</code> <pre><code>async def close(self) -&gt; None:\n    \"\"\"Close the user client.\n\n    This terminates the user's mailbox, closes the underlying exchange\n    transport.\n    \"\"\"\n    async with self._close_lock:\n        if self._closed:\n            return\n\n        await self._transport.terminate(self.client_id)\n        logger.info(\n            f'Terminated mailbox for {self.client_id}',\n            extra={'academy.mailbox_id': self.client_id},\n        )\n        await self._stop_listener_task()\n        await self._transport.close()\n        self._closed = True\n        logger.info(\n            'Closed exchange client for %s',\n            self.client_id,\n            extra={'academy.mailbox_id': self.client_id},\n        )\n</code></pre>"},{"location":"api/exchange/#academy.exchange.GlobusExchangeFactory","title":"GlobusExchangeFactory","text":"<pre><code>GlobusExchangeFactory(\n    project_id: UUID,\n    client_params: dict[str, Any] | None = None,\n)\n</code></pre> <p>               Bases: <code>ExchangeFactory[GlobusExchangeTransport]</code></p> <p>Globus exchange client factory.</p> <p>Parameters:</p> <ul> <li> <code>project_id</code>               (<code>UUID</code>)           \u2013            <p>Project to create new clients under. Must be able to authenticate as a administrator.</p> </li> <li> <code>client_params</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional parameters for globus client.</p> </li> </ul> Source code in <code>academy/exchange/cloud/globus.py</code> <pre><code>def __init__(\n    self,\n    project_id: uuid.UUID,\n    client_params: dict[str, Any] | None = None,\n) -&gt; None:\n    self.project = project_id\n    self.client_params = client_params\n</code></pre>"},{"location":"api/exchange/#academy.exchange.GlobusExchangeFactory.create_agent_client","title":"create_agent_client  <code>async</code>","text":"<pre><code>create_agent_client(\n    registration: AgentRegistration[AgentT],\n    request_handler: RequestHandler[RequestT_co],\n) -&gt; AgentExchangeClient[AgentT, ExchangeTransportT]\n</code></pre> <p>Create a new agent exchange client.</p> <p>An agent must be registered with the exchange before an exchange client can be created. For example: <pre><code>factory = ExchangeFactory(...)\nuser_client = factory.create_user_client()\nregistration = user_client.register_agent(...)\nagent_client = factory.create_agent_client(registration, ...)\n</code></pre></p> <p>Parameters:</p> <ul> <li> <code>registration</code>               (<code>AgentRegistration[AgentT]</code>)           \u2013            <p>Registration information returned by the exchange.</p> </li> <li> <code>request_handler</code>               (<code>RequestHandler[RequestT_co]</code>)           \u2013            <p>Agent request message handler.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AgentExchangeClient[AgentT, ExchangeTransportT]</code>           \u2013            <p>Agent exchange client.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BadEntityIdError</code>             \u2013            <p>If an agent with <code>registration.agent_id</code> is not already registered with the exchange.</p> </li> </ul> Source code in <code>academy/exchange/factory.py</code> <pre><code>async def create_agent_client(\n    self,\n    registration: AgentRegistration[AgentT],\n    request_handler: RequestHandler[RequestT_co],\n) -&gt; AgentExchangeClient[AgentT, ExchangeTransportT]:\n    \"\"\"Create a new agent exchange client.\n\n    An agent must be registered with the exchange before an exchange\n    client can be created. For example:\n    ```python\n    factory = ExchangeFactory(...)\n    user_client = factory.create_user_client()\n    registration = user_client.register_agent(...)\n    agent_client = factory.create_agent_client(registration, ...)\n    ```\n\n    Args:\n        registration: Registration information returned by the exchange.\n        request_handler: Agent request message handler.\n\n    Returns:\n        Agent exchange client.\n\n    Raises:\n        BadEntityIdError: If an agent with `registration.agent_id` is not\n            already registered with the exchange.\n    \"\"\"\n    agent_id: AgentId[AgentT] = registration.agent_id\n    transport = await self._create_transport(\n        mailbox_id=agent_id,\n        registration=registration,\n    )\n    assert transport.mailbox_id == agent_id\n    status = await transport.status(agent_id)\n    if status != MailboxStatus.ACTIVE:\n        await transport.close()\n        raise BadEntityIdError(agent_id)\n    return AgentExchangeClient(\n        agent_id,\n        transport,\n        request_handler=request_handler,\n    )\n</code></pre>"},{"location":"api/exchange/#academy.exchange.GlobusExchangeFactory.create_user_client","title":"create_user_client  <code>async</code>","text":"<pre><code>create_user_client(\n    *, name: str | None = None, start_listener: bool = True\n) -&gt; UserExchangeClient[ExchangeTransportT]\n</code></pre> <p>Create a new user in the exchange and associated client.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Display name of the client on the exchange.</p> </li> <li> <code>start_listener</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Start a message listener thread.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>UserExchangeClient[ExchangeTransportT]</code>           \u2013            <p>User exchange client.</p> </li> </ul> Source code in <code>academy/exchange/factory.py</code> <pre><code>async def create_user_client(\n    self,\n    *,\n    name: str | None = None,\n    start_listener: bool = True,\n) -&gt; UserExchangeClient[ExchangeTransportT]:\n    \"\"\"Create a new user in the exchange and associated client.\n\n    Args:\n        name: Display name of the client on the exchange.\n        start_listener: Start a message listener thread.\n\n    Returns:\n        User exchange client.\n    \"\"\"\n    transport = await self._create_transport(mailbox_id=None, name=name)\n    user_id = transport.mailbox_id\n    assert isinstance(user_id, UserId)\n    return UserExchangeClient(\n        user_id,\n        transport,\n        start_listener=start_listener,\n    )\n</code></pre>"},{"location":"api/exchange/#academy.exchange.GlobusExchangeTransport","title":"GlobusExchangeTransport","text":"<pre><code>GlobusExchangeTransport(\n    mailbox_id: EntityId,\n    *,\n    project_id: UUID,\n    app: GlobusApp | None = None,\n    authorizer: GlobusAuthorizer | None = None,\n    client_params: dict[str, Any] | None = None\n)\n</code></pre> <p>               Bases: <code>ExchangeTransportMixin</code>, <code>NoPickleMixin</code></p> <p>Globus exchange client.</p> <p>Parameters:</p> <ul> <li> <code>mailbox_id</code>               (<code>EntityId</code>)           \u2013            <p>Identifier of the mailbox on the exchange. If there is not an id provided, the exchange will create a new client mailbox.</p> </li> <li> <code>project_id</code>               (<code>UUID</code>)           \u2013            <p>Globus Identifier of project to create agents under.</p> </li> <li> <code>app</code>               (<code>GlobusApp | None</code>, default:                   <code>None</code> )           \u2013            <p>For user authorization through token retrieval.</p> </li> <li> <code>authorizer</code>               (<code>GlobusAuthorizer | None</code>, default:                   <code>None</code> )           \u2013            <p>For service authorization through token retrieval.</p> </li> <li> <code>client_params</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional parameters for globus client.</p> </li> </ul> Source code in <code>academy/exchange/cloud/globus.py</code> <pre><code>def __init__(\n    self,\n    mailbox_id: EntityId,\n    *,\n    project_id: uuid.UUID,\n    app: GlobusApp | None = None,\n    authorizer: GlobusAuthorizer | None = None,\n    client_params: dict[str, Any] | None = None,\n) -&gt; None:\n    self._mailbox_id = mailbox_id\n    self.project = project_id\n    self.child_clients: list[uuid.UUID] = []\n    self.client_params = client_params or {}\n\n    self.login_time = datetime.min\n    self._app = app\n    self._authorizer = authorizer\n    self._local_data = threading.local()\n    self.executor = ThreadPoolExecutor(\n        thread_name_prefix='exchange-globus-thread',\n    )\n</code></pre>"},{"location":"api/exchange/#academy.exchange.GlobusExchangeTransport.exchange_client","title":"exchange_client  <code>property</code>","text":"<pre><code>exchange_client: AcademyGlobusClient\n</code></pre> <p>A thread local copy of the Globus AuthClient.</p>"},{"location":"api/exchange/#academy.exchange.GlobusExchangeTransport.auth_client","title":"auth_client  <code>property</code>","text":"<pre><code>auth_client: AuthClient\n</code></pre> <p>A thread local copy of the Globus AuthClient.</p>"},{"location":"api/exchange/#academy.exchange.GlobusExchangeTransport.new","title":"new  <code>async</code> <code>classmethod</code>","text":"<pre><code>new(\n    *,\n    project_id: UUID,\n    app: GlobusApp | None = None,\n    authorizer: GlobusAuthorizer | None = None,\n    mailbox_id: EntityId | None = None,\n    name: str | None = None,\n    client_params: dict[str, Any] | None = None\n) -&gt; Self\n</code></pre> <p>Instantiate a new transport.</p> <p>Parameters:</p> <ul> <li> <code>project_id</code>               (<code>UUID</code>)           \u2013            <p>Globus Identifier of project to create agents under.</p> </li> <li> <code>app</code>               (<code>GlobusApp | None</code>, default:                   <code>None</code> )           \u2013            <p>For user authorization through token retrieval</p> </li> <li> <code>authorizer</code>               (<code>GlobusAuthorizer | None</code>, default:                   <code>None</code> )           \u2013            <p>For service authorization through token retrieval</p> </li> <li> <code>mailbox_id</code>               (<code>EntityId | None</code>, default:                   <code>None</code> )           \u2013            <p>Bind the transport to the specific mailbox. If <code>None</code>, a new user entity will be registered and the transport will be bound to that mailbox.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Display name of the registered entity if <code>mailbox_id</code> is <code>None</code>.</p> </li> <li> <code>client_params</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional parameters for globus client.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>An instantiated transport bound to a specific mailbox.</p> </li> </ul> Source code in <code>academy/exchange/cloud/globus.py</code> <pre><code>@classmethod\nasync def new(  # noqa: PLR0913\n    cls,\n    *,\n    project_id: uuid.UUID,\n    app: GlobusApp | None = None,\n    authorizer: GlobusAuthorizer | None = None,\n    mailbox_id: EntityId | None = None,\n    name: str | None = None,\n    client_params: dict[str, Any] | None = None,\n) -&gt; Self:\n    \"\"\"Instantiate a new transport.\n\n    Args:\n        project_id: Globus Identifier of project to create agents under.\n        app: For user authorization through token retrieval\n        authorizer: For service authorization through token retrieval\n        mailbox_id: Bind the transport to the specific mailbox. If `None`,\n            a new user entity will be registered and the transport will be\n            bound to that mailbox.\n        name: Display name of the registered entity if `mailbox_id` is\n            `None`.\n        client_params: Additional parameters for globus client.\n\n    Returns:\n        An instantiated transport bound to a specific mailbox.\n    \"\"\"\n    loop = asyncio.get_running_loop()\n\n    if mailbox_id is None:\n        mailbox_id = UserId.new(name=name)\n        client = cls(\n            mailbox_id,\n            project_id=project_id,\n            app=app,\n            authorizer=authorizer,\n            client_params=client_params,\n        )\n        await loop.run_in_executor(\n            client.executor,\n            client._register_client,\n        )\n        logger.info(\n            'Registered %s in exchange',\n            mailbox_id,\n            extra={'academy.mailbox_id': mailbox_id},\n        )\n        return client\n\n    return cls(\n        mailbox_id,\n        project_id=project_id,\n        app=app,\n        authorizer=authorizer,\n        client_params=client_params,\n    )\n</code></pre>"},{"location":"api/exchange/#academy.exchange.HttpExchangeFactory","title":"HttpExchangeFactory","text":"<pre><code>HttpExchangeFactory(\n    url: str,\n    auth_method: Literal[\"globus\"] | None = None,\n    additional_headers: dict[str, str] | None = None,\n    request_timeout_s: float = 60,\n    ssl_verify: bool | None = None,\n)\n</code></pre> <p>               Bases: <code>ExchangeFactory[HttpExchangeTransport]</code></p> <p>Http exchange client factory.</p> <p>Parameters:</p> <ul> <li> <code>url</code>               (<code>str</code>)           \u2013            <p>Address of HTTP exchange</p> </li> <li> <code>auth_method</code>               (<code>Literal['globus'] | None</code>, default:                   <code>None</code> )           \u2013            <p>Method to get authorization headers</p> </li> <li> <code>additional_headers</code>               (<code>dict[str, str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Any other information necessary to communicate with the exchange. Used for passing the Globus bearer token</p> </li> <li> <code>ssl_verify</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Same as requests.Session.verify. If the server's TLS certificate should be validated. Should be true if using HTTPS Only set to false for testing or local development.</p> </li> </ul> Source code in <code>academy/exchange/cloud/client.py</code> <pre><code>def __init__(\n    self,\n    url: str,\n    auth_method: Literal['globus'] | None = None,\n    additional_headers: dict[str, str] | None = None,\n    request_timeout_s: float = 60,\n    ssl_verify: bool | None = None,\n) -&gt; None:\n    if additional_headers is None:\n        additional_headers = {}\n    additional_headers |= get_auth_headers(auth_method)\n\n    self._info = _HttpConnectionInfo(\n        url=url,\n        additional_headers=additional_headers,\n        ssl_verify=ssl_verify,\n        request_timeout_s=request_timeout_s,\n    )\n</code></pre>"},{"location":"api/exchange/#academy.exchange.HttpExchangeFactory.create_agent_client","title":"create_agent_client  <code>async</code>","text":"<pre><code>create_agent_client(\n    registration: AgentRegistration[AgentT],\n    request_handler: RequestHandler[RequestT_co],\n) -&gt; AgentExchangeClient[AgentT, ExchangeTransportT]\n</code></pre> <p>Create a new agent exchange client.</p> <p>An agent must be registered with the exchange before an exchange client can be created. For example: <pre><code>factory = ExchangeFactory(...)\nuser_client = factory.create_user_client()\nregistration = user_client.register_agent(...)\nagent_client = factory.create_agent_client(registration, ...)\n</code></pre></p> <p>Parameters:</p> <ul> <li> <code>registration</code>               (<code>AgentRegistration[AgentT]</code>)           \u2013            <p>Registration information returned by the exchange.</p> </li> <li> <code>request_handler</code>               (<code>RequestHandler[RequestT_co]</code>)           \u2013            <p>Agent request message handler.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AgentExchangeClient[AgentT, ExchangeTransportT]</code>           \u2013            <p>Agent exchange client.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BadEntityIdError</code>             \u2013            <p>If an agent with <code>registration.agent_id</code> is not already registered with the exchange.</p> </li> </ul> Source code in <code>academy/exchange/factory.py</code> <pre><code>async def create_agent_client(\n    self,\n    registration: AgentRegistration[AgentT],\n    request_handler: RequestHandler[RequestT_co],\n) -&gt; AgentExchangeClient[AgentT, ExchangeTransportT]:\n    \"\"\"Create a new agent exchange client.\n\n    An agent must be registered with the exchange before an exchange\n    client can be created. For example:\n    ```python\n    factory = ExchangeFactory(...)\n    user_client = factory.create_user_client()\n    registration = user_client.register_agent(...)\n    agent_client = factory.create_agent_client(registration, ...)\n    ```\n\n    Args:\n        registration: Registration information returned by the exchange.\n        request_handler: Agent request message handler.\n\n    Returns:\n        Agent exchange client.\n\n    Raises:\n        BadEntityIdError: If an agent with `registration.agent_id` is not\n            already registered with the exchange.\n    \"\"\"\n    agent_id: AgentId[AgentT] = registration.agent_id\n    transport = await self._create_transport(\n        mailbox_id=agent_id,\n        registration=registration,\n    )\n    assert transport.mailbox_id == agent_id\n    status = await transport.status(agent_id)\n    if status != MailboxStatus.ACTIVE:\n        await transport.close()\n        raise BadEntityIdError(agent_id)\n    return AgentExchangeClient(\n        agent_id,\n        transport,\n        request_handler=request_handler,\n    )\n</code></pre>"},{"location":"api/exchange/#academy.exchange.HttpExchangeFactory.create_user_client","title":"create_user_client  <code>async</code>","text":"<pre><code>create_user_client(\n    *, name: str | None = None, start_listener: bool = True\n) -&gt; UserExchangeClient[ExchangeTransportT]\n</code></pre> <p>Create a new user in the exchange and associated client.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Display name of the client on the exchange.</p> </li> <li> <code>start_listener</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Start a message listener thread.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>UserExchangeClient[ExchangeTransportT]</code>           \u2013            <p>User exchange client.</p> </li> </ul> Source code in <code>academy/exchange/factory.py</code> <pre><code>async def create_user_client(\n    self,\n    *,\n    name: str | None = None,\n    start_listener: bool = True,\n) -&gt; UserExchangeClient[ExchangeTransportT]:\n    \"\"\"Create a new user in the exchange and associated client.\n\n    Args:\n        name: Display name of the client on the exchange.\n        start_listener: Start a message listener thread.\n\n    Returns:\n        User exchange client.\n    \"\"\"\n    transport = await self._create_transport(mailbox_id=None, name=name)\n    user_id = transport.mailbox_id\n    assert isinstance(user_id, UserId)\n    return UserExchangeClient(\n        user_id,\n        transport,\n        start_listener=start_listener,\n    )\n</code></pre>"},{"location":"api/exchange/#academy.exchange.HttpExchangeTransport","title":"HttpExchangeTransport","text":"<pre><code>HttpExchangeTransport(\n    mailbox_id: EntityId,\n    session: ClientSession,\n    connection_info: _HttpConnectionInfo,\n)\n</code></pre> <p>               Bases: <code>ExchangeTransportMixin</code>, <code>NoPickleMixin</code></p> <p>Http exchange client.</p> <p>Parameters:</p> <ul> <li> <code>mailbox_id</code>               (<code>EntityId</code>)           \u2013            <p>Identifier of the mailbox on the exchange. If there is not an id provided, the exchange will create a new client mailbox.</p> </li> <li> <code>session</code>               (<code>ClientSession</code>)           \u2013            <p>Http session.</p> </li> <li> <code>connection_info</code>               (<code>_HttpConnectionInfo</code>)           \u2013            <p>Exchange connection info.</p> </li> </ul> Source code in <code>academy/exchange/cloud/client.py</code> <pre><code>def __init__(\n    self,\n    mailbox_id: EntityId,\n    session: aiohttp.ClientSession,\n    connection_info: _HttpConnectionInfo,\n) -&gt; None:\n    self._mailbox_id = mailbox_id\n    self._session = session\n    self._info = connection_info\n\n    base_url = self._info.url\n    self._mailbox_url = f'{base_url}/mailbox'\n    self._message_url = f'{base_url}/message'\n    self._discover_url = f'{base_url}/discover'\n</code></pre>"},{"location":"api/exchange/#academy.exchange.HttpExchangeTransport.new","title":"new  <code>async</code> <code>classmethod</code>","text":"<pre><code>new(\n    *,\n    connection_info: _HttpConnectionInfo,\n    mailbox_id: EntityId | None = None,\n    name: str | None = None\n) -&gt; Self\n</code></pre> <p>Instantiate a new transport.</p> <p>Parameters:</p> <ul> <li> <code>connection_info</code>               (<code>_HttpConnectionInfo</code>)           \u2013            <p>Exchange connection information.</p> </li> <li> <code>mailbox_id</code>               (<code>EntityId | None</code>, default:                   <code>None</code> )           \u2013            <p>Bind the transport to the specific mailbox. If <code>None</code>, a new user entity will be registered and the transport will be bound to that mailbox.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Display name of the registered entity if <code>mailbox_id</code> is <code>None</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>An instantiated transport bound to a specific mailbox.</p> </li> </ul> Source code in <code>academy/exchange/cloud/client.py</code> <pre><code>@classmethod\nasync def new(\n    cls,\n    *,\n    connection_info: _HttpConnectionInfo,\n    mailbox_id: EntityId | None = None,\n    name: str | None = None,\n) -&gt; Self:\n    \"\"\"Instantiate a new transport.\n\n    Args:\n        connection_info: Exchange connection information.\n        mailbox_id: Bind the transport to the specific mailbox. If `None`,\n            a new user entity will be registered and the transport will be\n            bound to that mailbox.\n        name: Display name of the registered entity if `mailbox_id` is\n            `None`.\n\n    Returns:\n        An instantiated transport bound to a specific mailbox.\n    \"\"\"\n    ssl_verify = connection_info.ssl_verify\n    if ssl_verify is None:  # pragma: no branch\n        scheme = urlparse(connection_info.url).scheme\n        ssl_verify = scheme == 'https'\n\n    session = aiohttp.ClientSession(\n        connector=aiohttp.TCPConnector(ssl=ssl_verify),\n        headers=connection_info.additional_headers,\n        trust_env=True,\n    )\n\n    if mailbox_id is None:\n        mailbox_id = UserId.new(name=name)\n        async with session.post(\n            f'{connection_info.url}/mailbox',\n            json={'mailbox': mailbox_id.model_dump_json()},\n        ) as response:\n            _raise_for_status(response, mailbox_id)\n        logger.info(\n            'Registered %s in exchange',\n            mailbox_id,\n            extra={'academy.mailbox_id': mailbox_id},\n        )\n\n    return cls(mailbox_id, session, connection_info)\n</code></pre>"},{"location":"api/exchange/#academy.exchange.ExchangeFactory","title":"ExchangeFactory","text":"<p>               Bases: <code>ABC</code>, <code>Generic[ExchangeTransportT]</code></p> <p>Exchange client factory.</p> <p>An exchange factory is used to mint new exchange clients for users and agents, encapsulating the complexities of instantiating the underlying communication classes (the <code>ExchangeTransport</code>).</p> Warning <p>Factory implementations must be efficiently pickleable because factory instances are shared between user and agent processes so that all entities can create clients to the same exchange.</p>"},{"location":"api/exchange/#academy.exchange.ExchangeFactory.create_agent_client","title":"create_agent_client  <code>async</code>","text":"<pre><code>create_agent_client(\n    registration: AgentRegistration[AgentT],\n    request_handler: RequestHandler[RequestT_co],\n) -&gt; AgentExchangeClient[AgentT, ExchangeTransportT]\n</code></pre> <p>Create a new agent exchange client.</p> <p>An agent must be registered with the exchange before an exchange client can be created. For example: <pre><code>factory = ExchangeFactory(...)\nuser_client = factory.create_user_client()\nregistration = user_client.register_agent(...)\nagent_client = factory.create_agent_client(registration, ...)\n</code></pre></p> <p>Parameters:</p> <ul> <li> <code>registration</code>               (<code>AgentRegistration[AgentT]</code>)           \u2013            <p>Registration information returned by the exchange.</p> </li> <li> <code>request_handler</code>               (<code>RequestHandler[RequestT_co]</code>)           \u2013            <p>Agent request message handler.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AgentExchangeClient[AgentT, ExchangeTransportT]</code>           \u2013            <p>Agent exchange client.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BadEntityIdError</code>             \u2013            <p>If an agent with <code>registration.agent_id</code> is not already registered with the exchange.</p> </li> </ul> Source code in <code>academy/exchange/factory.py</code> <pre><code>async def create_agent_client(\n    self,\n    registration: AgentRegistration[AgentT],\n    request_handler: RequestHandler[RequestT_co],\n) -&gt; AgentExchangeClient[AgentT, ExchangeTransportT]:\n    \"\"\"Create a new agent exchange client.\n\n    An agent must be registered with the exchange before an exchange\n    client can be created. For example:\n    ```python\n    factory = ExchangeFactory(...)\n    user_client = factory.create_user_client()\n    registration = user_client.register_agent(...)\n    agent_client = factory.create_agent_client(registration, ...)\n    ```\n\n    Args:\n        registration: Registration information returned by the exchange.\n        request_handler: Agent request message handler.\n\n    Returns:\n        Agent exchange client.\n\n    Raises:\n        BadEntityIdError: If an agent with `registration.agent_id` is not\n            already registered with the exchange.\n    \"\"\"\n    agent_id: AgentId[AgentT] = registration.agent_id\n    transport = await self._create_transport(\n        mailbox_id=agent_id,\n        registration=registration,\n    )\n    assert transport.mailbox_id == agent_id\n    status = await transport.status(agent_id)\n    if status != MailboxStatus.ACTIVE:\n        await transport.close()\n        raise BadEntityIdError(agent_id)\n    return AgentExchangeClient(\n        agent_id,\n        transport,\n        request_handler=request_handler,\n    )\n</code></pre>"},{"location":"api/exchange/#academy.exchange.ExchangeFactory.create_user_client","title":"create_user_client  <code>async</code>","text":"<pre><code>create_user_client(\n    *, name: str | None = None, start_listener: bool = True\n) -&gt; UserExchangeClient[ExchangeTransportT]\n</code></pre> <p>Create a new user in the exchange and associated client.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Display name of the client on the exchange.</p> </li> <li> <code>start_listener</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Start a message listener thread.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>UserExchangeClient[ExchangeTransportT]</code>           \u2013            <p>User exchange client.</p> </li> </ul> Source code in <code>academy/exchange/factory.py</code> <pre><code>async def create_user_client(\n    self,\n    *,\n    name: str | None = None,\n    start_listener: bool = True,\n) -&gt; UserExchangeClient[ExchangeTransportT]:\n    \"\"\"Create a new user in the exchange and associated client.\n\n    Args:\n        name: Display name of the client on the exchange.\n        start_listener: Start a message listener thread.\n\n    Returns:\n        User exchange client.\n    \"\"\"\n    transport = await self._create_transport(mailbox_id=None, name=name)\n    user_id = transport.mailbox_id\n    assert isinstance(user_id, UserId)\n    return UserExchangeClient(\n        user_id,\n        transport,\n        start_listener=start_listener,\n    )\n</code></pre>"},{"location":"api/exchange/#academy.exchange.HybridExchangeFactory","title":"HybridExchangeFactory","text":"<pre><code>HybridExchangeFactory(\n    redis_host: str,\n    redis_port: int,\n    *,\n    redis_kwargs: dict[str, Any] | None = None,\n    interface: str | None = None,\n    namespace: str | None = \"default\",\n    ports: Iterable[int] | None = None\n)\n</code></pre> <p>               Bases: <code>ExchangeFactory[HybridExchangeTransport]</code></p> <p>Hybrid exchange client factory.</p> <p>The hybrid exchange uses peer-to-peer communication via TCP and a central Redis server for mailbox state and queueing messages for offline entities.</p> <p>Parameters:</p> <ul> <li> <code>redis_host</code>               (<code>str</code>)           \u2013            <p>Redis server hostname.</p> </li> <li> <code>redis_port</code>               (<code>int</code>)           \u2013            <p>Redis server port.</p> </li> <li> <code>redis_kwargs</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Extra keyword arguments to pass to <code>redis.Redis()</code>.</p> </li> <li> <code>interface</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Network interface use for peer-to-peer communication. If <code>None</code>, the hostname of the local host is used.</p> </li> <li> <code>namespace</code>               (<code>str | None</code>, default:                   <code>'default'</code> )           \u2013            <p>Redis key namespace. If <code>None</code> a random key prefix is generated.</p> </li> <li> <code>ports</code>               (<code>Iterable[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>An iterable of ports to give each client a unique port from a user defined set. A StopIteration exception will be raised in <code>create_*_client()</code> methods if the number of clients in the process is greater than the length of the iterable.</p> </li> </ul> Source code in <code>academy/exchange/hybrid.py</code> <pre><code>def __init__(  # noqa: PLR0913\n    self,\n    redis_host: str,\n    redis_port: int,\n    *,\n    redis_kwargs: dict[str, Any] | None = None,\n    interface: str | None = None,\n    namespace: str | None = 'default',\n    ports: Iterable[int] | None = None,\n) -&gt; None:\n    self._namespace = (\n        namespace\n        if namespace is not None\n        else uuid_to_base32(uuid.uuid4())\n    )\n    self._interface = interface\n    self._redis_info = _RedisConnectionInfo(\n        redis_host,\n        redis_port,\n        redis_kwargs if redis_kwargs is not None else {},\n    )\n    self._ports = None if ports is None else iter(ports)\n</code></pre>"},{"location":"api/exchange/#academy.exchange.HybridExchangeFactory.create_agent_client","title":"create_agent_client  <code>async</code>","text":"<pre><code>create_agent_client(\n    registration: AgentRegistration[AgentT],\n    request_handler: RequestHandler[RequestT_co],\n) -&gt; AgentExchangeClient[AgentT, ExchangeTransportT]\n</code></pre> <p>Create a new agent exchange client.</p> <p>An agent must be registered with the exchange before an exchange client can be created. For example: <pre><code>factory = ExchangeFactory(...)\nuser_client = factory.create_user_client()\nregistration = user_client.register_agent(...)\nagent_client = factory.create_agent_client(registration, ...)\n</code></pre></p> <p>Parameters:</p> <ul> <li> <code>registration</code>               (<code>AgentRegistration[AgentT]</code>)           \u2013            <p>Registration information returned by the exchange.</p> </li> <li> <code>request_handler</code>               (<code>RequestHandler[RequestT_co]</code>)           \u2013            <p>Agent request message handler.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AgentExchangeClient[AgentT, ExchangeTransportT]</code>           \u2013            <p>Agent exchange client.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BadEntityIdError</code>             \u2013            <p>If an agent with <code>registration.agent_id</code> is not already registered with the exchange.</p> </li> </ul> Source code in <code>academy/exchange/factory.py</code> <pre><code>async def create_agent_client(\n    self,\n    registration: AgentRegistration[AgentT],\n    request_handler: RequestHandler[RequestT_co],\n) -&gt; AgentExchangeClient[AgentT, ExchangeTransportT]:\n    \"\"\"Create a new agent exchange client.\n\n    An agent must be registered with the exchange before an exchange\n    client can be created. For example:\n    ```python\n    factory = ExchangeFactory(...)\n    user_client = factory.create_user_client()\n    registration = user_client.register_agent(...)\n    agent_client = factory.create_agent_client(registration, ...)\n    ```\n\n    Args:\n        registration: Registration information returned by the exchange.\n        request_handler: Agent request message handler.\n\n    Returns:\n        Agent exchange client.\n\n    Raises:\n        BadEntityIdError: If an agent with `registration.agent_id` is not\n            already registered with the exchange.\n    \"\"\"\n    agent_id: AgentId[AgentT] = registration.agent_id\n    transport = await self._create_transport(\n        mailbox_id=agent_id,\n        registration=registration,\n    )\n    assert transport.mailbox_id == agent_id\n    status = await transport.status(agent_id)\n    if status != MailboxStatus.ACTIVE:\n        await transport.close()\n        raise BadEntityIdError(agent_id)\n    return AgentExchangeClient(\n        agent_id,\n        transport,\n        request_handler=request_handler,\n    )\n</code></pre>"},{"location":"api/exchange/#academy.exchange.HybridExchangeFactory.create_user_client","title":"create_user_client  <code>async</code>","text":"<pre><code>create_user_client(\n    *, name: str | None = None, start_listener: bool = True\n) -&gt; UserExchangeClient[ExchangeTransportT]\n</code></pre> <p>Create a new user in the exchange and associated client.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Display name of the client on the exchange.</p> </li> <li> <code>start_listener</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Start a message listener thread.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>UserExchangeClient[ExchangeTransportT]</code>           \u2013            <p>User exchange client.</p> </li> </ul> Source code in <code>academy/exchange/factory.py</code> <pre><code>async def create_user_client(\n    self,\n    *,\n    name: str | None = None,\n    start_listener: bool = True,\n) -&gt; UserExchangeClient[ExchangeTransportT]:\n    \"\"\"Create a new user in the exchange and associated client.\n\n    Args:\n        name: Display name of the client on the exchange.\n        start_listener: Start a message listener thread.\n\n    Returns:\n        User exchange client.\n    \"\"\"\n    transport = await self._create_transport(mailbox_id=None, name=name)\n    user_id = transport.mailbox_id\n    assert isinstance(user_id, UserId)\n    return UserExchangeClient(\n        user_id,\n        transport,\n        start_listener=start_listener,\n    )\n</code></pre>"},{"location":"api/exchange/#academy.exchange.HybridExchangeTransport","title":"HybridExchangeTransport","text":"<pre><code>HybridExchangeTransport(\n    mailbox_id: EntityId,\n    redis_client: Redis,\n    *,\n    redis_info: _RedisConnectionInfo,\n    namespace: str,\n    host: str,\n    port: int,\n    interface: str | None = None\n)\n</code></pre> <p>               Bases: <code>ExchangeTransportMixin</code>, <code>NoPickleMixin</code></p> <p>Hybrid exchange transport bound to a specific mailbox.</p> Source code in <code>academy/exchange/hybrid.py</code> <pre><code>def __init__(  # noqa: PLR0913\n    self,\n    mailbox_id: EntityId,\n    redis_client: redis.asyncio.Redis,\n    *,\n    redis_info: _RedisConnectionInfo,\n    namespace: str,\n    host: str,\n    port: int,\n    interface: str | None = None,\n) -&gt; None:\n    self._mailbox_id = mailbox_id\n    self._redis_client = redis_client\n    self._redis_info = redis_info\n    self._namespace = namespace\n    self._host = host\n    self._port = port\n    self._interface = interface\n\n    self._address_cache: dict[EntityId, str] = {}\n    if sys.version_info &gt;= (3, 13):  # pragma: &gt;=3.13 cover\n        self._messages: AsyncQueue[Message[Any]] = Queue()\n    else:  # pragma: &lt;3.13 cover\n        self._messages: AsyncQueue[Message[Any]] = Queue().async_q\n    self._socket_pool = SocketPool()\n    self._started = asyncio.Event()\n    self._shutdown = asyncio.Event()\n\n    self._server = SimpleSocketServer(\n        handler=self._direct_message_handler,\n        host=host,\n        port=port,\n    )\n    self._server_task = spawn_guarded_background_task(\n        self._run_direct_server(),\n        name=f'hybrid-transport-direct-server-{self.mailbox_id}',\n    )\n    self._redis_task = spawn_guarded_background_task(\n        self._run_redis_listener(),\n        name=f'hybrid-transport-redis-watcher-{self.mailbox_id}',\n    )\n</code></pre>"},{"location":"api/exchange/#academy.exchange.HybridExchangeTransport.new","title":"new  <code>async</code> <code>classmethod</code>","text":"<pre><code>new(\n    *,\n    namespace: str,\n    redis_info: _RedisConnectionInfo,\n    interface: str | None = None,\n    mailbox_id: EntityId | None = None,\n    name: str | None = None,\n    port: int | None = None\n) -&gt; Self\n</code></pre> <p>Instantiate a new transport.</p> <p>Parameters:</p> <ul> <li> <code>namespace</code>               (<code>str</code>)           \u2013            <p>Redis key namespace.</p> </li> <li> <code>redis_info</code>               (<code>_RedisConnectionInfo</code>)           \u2013            <p>Redis connection information.</p> </li> <li> <code>interface</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Network interface use for peer-to-peer communication. If <code>None</code>, the hostname of the local host is used.</p> </li> <li> <code>mailbox_id</code>               (<code>EntityId | None</code>, default:                   <code>None</code> )           \u2013            <p>Bind the transport to the specific mailbox. If <code>None</code>, a new user entity will be registered and the transport will be bound to that mailbox.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Display name of the registered entity if <code>mailbox_id</code> is <code>None</code>.</p> </li> <li> <code>port</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Port to listen for peer connection on.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>An instantiated transport bound to a specific mailbox.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ConnectionError</code>             \u2013            <p>If the Redis server is not reachable.</p> </li> </ul> Source code in <code>academy/exchange/hybrid.py</code> <pre><code>@classmethod\nasync def new(  # noqa: PLR0913\n    cls,\n    *,\n    namespace: str,\n    redis_info: _RedisConnectionInfo,\n    interface: str | None = None,\n    mailbox_id: EntityId | None = None,\n    name: str | None = None,\n    port: int | None = None,\n) -&gt; Self:\n    \"\"\"Instantiate a new transport.\n\n    Args:\n        namespace: Redis key namespace.\n        redis_info: Redis connection information.\n        interface: Network interface use for peer-to-peer communication.\n            If `None`, the hostname of the local host is used.\n        mailbox_id: Bind the transport to the specific mailbox. If `None`,\n            a new user entity will be registered and the transport will be\n            bound to that mailbox.\n        name: Display name of the registered entity if `mailbox_id` is\n            `None`.\n        port: Port to listen for peer connection on.\n\n    Returns:\n        An instantiated transport bound to a specific mailbox.\n\n    Raises:\n        redis.exceptions.ConnectionError: If the Redis server is not\n            reachable.\n    \"\"\"\n    host = (\n        address_by_interface(interface)\n        if interface is not None\n        else address_by_hostname()\n    )\n    port = port if port is not None else open_port()\n\n    client = redis.asyncio.Redis(\n        host=redis_info.hostname,\n        port=redis_info.port,\n        decode_responses=False,\n        **redis_info.kwargs,\n    )\n    # Ensure the redis server is reachable else fail early\n    p = client.ping()\n    assert isinstance(p, Awaitable), (\n        'ping should be awaitable from an async redis instance'\n    )\n    await p\n\n    if mailbox_id is None:\n        mailbox_id = UserId.new(name=name)\n        await client.set(\n            f'{namespace}:status:{uuid_to_base32(mailbox_id.uid)}',\n            _MailboxState.ACTIVE.value,\n        )\n        logger.info(\n            'Registered %s in exchange',\n            mailbox_id,\n            extra={'academy.mailbox_id': mailbox_id},\n        )\n\n    await client.set(\n        f'{namespace}:address:{uuid_to_base32(mailbox_id.uid)}',\n        f'{host}:{port}',\n    )\n\n    transport = cls(\n        mailbox_id,\n        client,\n        redis_info=redis_info,\n        namespace=namespace,\n        interface=interface,\n        host=host,\n        port=port,\n    )\n    # Wait for the direct message server to start\n    await asyncio.wait_for(transport._started.wait(), timeout=5)\n    return transport\n</code></pre>"},{"location":"api/exchange/#academy.exchange.LocalExchangeFactory","title":"LocalExchangeFactory","text":"<pre><code>LocalExchangeFactory(\n    *, _state: _LocalExchangeState | None = None\n)\n</code></pre> <p>               Bases: <code>ExchangeFactory[LocalExchangeTransport]</code>, <code>NoPickleMixin</code></p> <p>Local exchange client factory.</p> <p>A thread exchange can be used to pass messages between agents running in separate threads of a single process.</p> Source code in <code>academy/exchange/local.py</code> <pre><code>def __init__(\n    self,\n    *,\n    _state: _LocalExchangeState | None = None,\n):\n    self._state = _LocalExchangeState() if _state is None else _state\n</code></pre>"},{"location":"api/exchange/#academy.exchange.LocalExchangeFactory.create_agent_client","title":"create_agent_client  <code>async</code>","text":"<pre><code>create_agent_client(\n    registration: AgentRegistration[AgentT],\n    request_handler: RequestHandler[RequestT_co],\n) -&gt; AgentExchangeClient[AgentT, ExchangeTransportT]\n</code></pre> <p>Create a new agent exchange client.</p> <p>An agent must be registered with the exchange before an exchange client can be created. For example: <pre><code>factory = ExchangeFactory(...)\nuser_client = factory.create_user_client()\nregistration = user_client.register_agent(...)\nagent_client = factory.create_agent_client(registration, ...)\n</code></pre></p> <p>Parameters:</p> <ul> <li> <code>registration</code>               (<code>AgentRegistration[AgentT]</code>)           \u2013            <p>Registration information returned by the exchange.</p> </li> <li> <code>request_handler</code>               (<code>RequestHandler[RequestT_co]</code>)           \u2013            <p>Agent request message handler.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AgentExchangeClient[AgentT, ExchangeTransportT]</code>           \u2013            <p>Agent exchange client.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BadEntityIdError</code>             \u2013            <p>If an agent with <code>registration.agent_id</code> is not already registered with the exchange.</p> </li> </ul> Source code in <code>academy/exchange/factory.py</code> <pre><code>async def create_agent_client(\n    self,\n    registration: AgentRegistration[AgentT],\n    request_handler: RequestHandler[RequestT_co],\n) -&gt; AgentExchangeClient[AgentT, ExchangeTransportT]:\n    \"\"\"Create a new agent exchange client.\n\n    An agent must be registered with the exchange before an exchange\n    client can be created. For example:\n    ```python\n    factory = ExchangeFactory(...)\n    user_client = factory.create_user_client()\n    registration = user_client.register_agent(...)\n    agent_client = factory.create_agent_client(registration, ...)\n    ```\n\n    Args:\n        registration: Registration information returned by the exchange.\n        request_handler: Agent request message handler.\n\n    Returns:\n        Agent exchange client.\n\n    Raises:\n        BadEntityIdError: If an agent with `registration.agent_id` is not\n            already registered with the exchange.\n    \"\"\"\n    agent_id: AgentId[AgentT] = registration.agent_id\n    transport = await self._create_transport(\n        mailbox_id=agent_id,\n        registration=registration,\n    )\n    assert transport.mailbox_id == agent_id\n    status = await transport.status(agent_id)\n    if status != MailboxStatus.ACTIVE:\n        await transport.close()\n        raise BadEntityIdError(agent_id)\n    return AgentExchangeClient(\n        agent_id,\n        transport,\n        request_handler=request_handler,\n    )\n</code></pre>"},{"location":"api/exchange/#academy.exchange.LocalExchangeFactory.create_user_client","title":"create_user_client  <code>async</code>","text":"<pre><code>create_user_client(\n    *, name: str | None = None, start_listener: bool = True\n) -&gt; UserExchangeClient[ExchangeTransportT]\n</code></pre> <p>Create a new user in the exchange and associated client.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Display name of the client on the exchange.</p> </li> <li> <code>start_listener</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Start a message listener thread.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>UserExchangeClient[ExchangeTransportT]</code>           \u2013            <p>User exchange client.</p> </li> </ul> Source code in <code>academy/exchange/factory.py</code> <pre><code>async def create_user_client(\n    self,\n    *,\n    name: str | None = None,\n    start_listener: bool = True,\n) -&gt; UserExchangeClient[ExchangeTransportT]:\n    \"\"\"Create a new user in the exchange and associated client.\n\n    Args:\n        name: Display name of the client on the exchange.\n        start_listener: Start a message listener thread.\n\n    Returns:\n        User exchange client.\n    \"\"\"\n    transport = await self._create_transport(mailbox_id=None, name=name)\n    user_id = transport.mailbox_id\n    assert isinstance(user_id, UserId)\n    return UserExchangeClient(\n        user_id,\n        transport,\n        start_listener=start_listener,\n    )\n</code></pre>"},{"location":"api/exchange/#academy.exchange.LocalExchangeTransport","title":"LocalExchangeTransport","text":"<pre><code>LocalExchangeTransport(\n    mailbox_id: EntityId, state: _LocalExchangeState\n)\n</code></pre> <p>               Bases: <code>ExchangeTransportMixin</code>, <code>NoPickleMixin</code></p> <p>Local exchange client bound to a specific mailbox.</p> Source code in <code>academy/exchange/local.py</code> <pre><code>def __init__(\n    self,\n    mailbox_id: EntityId,\n    state: _LocalExchangeState,\n) -&gt; None:\n    self._mailbox_id = mailbox_id\n    self._state = state\n</code></pre>"},{"location":"api/exchange/#academy.exchange.LocalExchangeTransport.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(\n    mailbox_id: EntityId | None = None,\n    *,\n    name: str | None = None,\n    state: _LocalExchangeState\n) -&gt; Self\n</code></pre> <p>Instantiate a new transport.</p> <p>Parameters:</p> <ul> <li> <code>mailbox_id</code>               (<code>EntityId | None</code>, default:                   <code>None</code> )           \u2013            <p>Bind the transport to the specific mailbox. If <code>None</code>, a new user entity will be registered and the transport will be bound to that mailbox.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Display name of the redistered entity if <code>mailbox_id</code> is <code>None</code>.</p> </li> <li> <code>state</code>               (<code>_LocalExchangeState</code>)           \u2013            <p>Shared state among exchange clients.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>An instantiated transport bound to a specific mailbox.</p> </li> </ul> Source code in <code>academy/exchange/local.py</code> <pre><code>@classmethod\ndef new(\n    cls,\n    mailbox_id: EntityId | None = None,\n    *,\n    name: str | None = None,\n    state: _LocalExchangeState,\n) -&gt; Self:\n    \"\"\"Instantiate a new transport.\n\n    Args:\n        mailbox_id: Bind the transport to the specific mailbox. If `None`,\n            a new user entity will be registered and the transport will be\n            bound to that mailbox.\n        name: Display name of the redistered entity if `mailbox_id` is\n            `None`.\n        state: Shared state among exchange clients.\n\n    Returns:\n        An instantiated transport bound to a specific mailbox.\n    \"\"\"\n    if mailbox_id is None:\n        mailbox_id = UserId.new(name=name)\n        state.queues[mailbox_id] = Queue().async_q\n        state.locks[mailbox_id] = Lock()\n        logger.info(\n            'Registered %s in exchange',\n            mailbox_id,\n            extra={'academy.mailbox_id': mailbox_id},\n        )\n    return cls(mailbox_id, state)\n</code></pre>"},{"location":"api/exchange/#academy.exchange.ProxyStoreExchangeFactory","title":"ProxyStoreExchangeFactory","text":"<pre><code>ProxyStoreExchangeFactory(\n    base: ExchangeFactory[ExchangeTransportT],\n    store: Store[Any] | None,\n    should_proxy: Callable[[Any], bool],\n    *,\n    resolve_async: bool = False\n)\n</code></pre> <p>               Bases: <code>ExchangeFactory[ProxyStoreExchangeTransport[ExchangeTransportT]]</code></p> <p>ProxStore exchange client factory.</p> <p>A ProxyStore exchange is used to wrap an underlying exchange so large objects may be passed by reference.</p> <p>Parameters:</p> <ul> <li> <code>base</code>               (<code>ExchangeFactory[ExchangeTransportT]</code>)           \u2013            <p>Base exchange factory.</p> </li> <li> <code>store</code>               (<code>Store[Any] | None</code>)           \u2013            <p>Store to use for proxying data.</p> </li> <li> <code>should_proxy</code>               (<code>Callable[[Any], bool]</code>)           \u2013            <p>A callable that returns <code>True</code> if an object should be proxied. This is applied to every positional and keyword argument and result value.</p> </li> <li> <code>resolve_async</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Resolve proxies asynchronously when received.</p> </li> </ul> Source code in <code>academy/exchange/proxystore.py</code> <pre><code>def __init__(\n    self,\n    base: ExchangeFactory[ExchangeTransportT],\n    store: Store[Any] | None,\n    should_proxy: Callable[[Any], bool],\n    *,\n    resolve_async: bool = False,\n) -&gt; None:\n    _assert_proxystore_available()\n    self.base = base\n    self.store = store\n    self.should_proxy = should_proxy\n    self.resolve_async = resolve_async\n</code></pre>"},{"location":"api/exchange/#academy.exchange.ProxyStoreExchangeFactory.create_agent_client","title":"create_agent_client  <code>async</code>","text":"<pre><code>create_agent_client(\n    registration: AgentRegistration[AgentT],\n    request_handler: RequestHandler[RequestT_co],\n) -&gt; AgentExchangeClient[AgentT, ExchangeTransportT]\n</code></pre> <p>Create a new agent exchange client.</p> <p>An agent must be registered with the exchange before an exchange client can be created. For example: <pre><code>factory = ExchangeFactory(...)\nuser_client = factory.create_user_client()\nregistration = user_client.register_agent(...)\nagent_client = factory.create_agent_client(registration, ...)\n</code></pre></p> <p>Parameters:</p> <ul> <li> <code>registration</code>               (<code>AgentRegistration[AgentT]</code>)           \u2013            <p>Registration information returned by the exchange.</p> </li> <li> <code>request_handler</code>               (<code>RequestHandler[RequestT_co]</code>)           \u2013            <p>Agent request message handler.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AgentExchangeClient[AgentT, ExchangeTransportT]</code>           \u2013            <p>Agent exchange client.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BadEntityIdError</code>             \u2013            <p>If an agent with <code>registration.agent_id</code> is not already registered with the exchange.</p> </li> </ul> Source code in <code>academy/exchange/factory.py</code> <pre><code>async def create_agent_client(\n    self,\n    registration: AgentRegistration[AgentT],\n    request_handler: RequestHandler[RequestT_co],\n) -&gt; AgentExchangeClient[AgentT, ExchangeTransportT]:\n    \"\"\"Create a new agent exchange client.\n\n    An agent must be registered with the exchange before an exchange\n    client can be created. For example:\n    ```python\n    factory = ExchangeFactory(...)\n    user_client = factory.create_user_client()\n    registration = user_client.register_agent(...)\n    agent_client = factory.create_agent_client(registration, ...)\n    ```\n\n    Args:\n        registration: Registration information returned by the exchange.\n        request_handler: Agent request message handler.\n\n    Returns:\n        Agent exchange client.\n\n    Raises:\n        BadEntityIdError: If an agent with `registration.agent_id` is not\n            already registered with the exchange.\n    \"\"\"\n    agent_id: AgentId[AgentT] = registration.agent_id\n    transport = await self._create_transport(\n        mailbox_id=agent_id,\n        registration=registration,\n    )\n    assert transport.mailbox_id == agent_id\n    status = await transport.status(agent_id)\n    if status != MailboxStatus.ACTIVE:\n        await transport.close()\n        raise BadEntityIdError(agent_id)\n    return AgentExchangeClient(\n        agent_id,\n        transport,\n        request_handler=request_handler,\n    )\n</code></pre>"},{"location":"api/exchange/#academy.exchange.ProxyStoreExchangeFactory.create_user_client","title":"create_user_client  <code>async</code>","text":"<pre><code>create_user_client(\n    *, name: str | None = None, start_listener: bool = True\n) -&gt; UserExchangeClient[ExchangeTransportT]\n</code></pre> <p>Create a new user in the exchange and associated client.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Display name of the client on the exchange.</p> </li> <li> <code>start_listener</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Start a message listener thread.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>UserExchangeClient[ExchangeTransportT]</code>           \u2013            <p>User exchange client.</p> </li> </ul> Source code in <code>academy/exchange/factory.py</code> <pre><code>async def create_user_client(\n    self,\n    *,\n    name: str | None = None,\n    start_listener: bool = True,\n) -&gt; UserExchangeClient[ExchangeTransportT]:\n    \"\"\"Create a new user in the exchange and associated client.\n\n    Args:\n        name: Display name of the client on the exchange.\n        start_listener: Start a message listener thread.\n\n    Returns:\n        User exchange client.\n    \"\"\"\n    transport = await self._create_transport(mailbox_id=None, name=name)\n    user_id = transport.mailbox_id\n    assert isinstance(user_id, UserId)\n    return UserExchangeClient(\n        user_id,\n        transport,\n        start_listener=start_listener,\n    )\n</code></pre>"},{"location":"api/exchange/#academy.exchange.ProxyStoreExchangeTransport","title":"ProxyStoreExchangeTransport","text":"<pre><code>ProxyStoreExchangeTransport(\n    transport: ExchangeTransportT,\n    store: Store[Any],\n    should_proxy: Callable[[Any], bool],\n    *,\n    resolve_async: bool = False\n)\n</code></pre> <p>               Bases: <code>ExchangeTransportMixin</code>, <code>NoPickleMixin</code>, <code>Generic[ExchangeTransportT]</code></p> <p>ProxyStore exchange client bound to a specific mailbox.</p> Source code in <code>academy/exchange/proxystore.py</code> <pre><code>def __init__(\n    self,\n    transport: ExchangeTransportT,\n    store: Store[Any],\n    should_proxy: Callable[[Any], bool],\n    *,\n    resolve_async: bool = False,\n) -&gt; None:\n    _assert_proxystore_available()\n    self.transport = transport\n    self.store = store\n    self.should_proxy = should_proxy\n    self.resolve_async = resolve_async\n    register_store(store, exist_ok=True)\n</code></pre>"},{"location":"api/exchange/#academy.exchange.RedisExchangeFactory","title":"RedisExchangeFactory","text":"<pre><code>RedisExchangeFactory(\n    hostname: str, port: int, **redis_kwargs: Any\n)\n</code></pre> <p>               Bases: <code>ExchangeFactory[RedisExchangeTransport]</code></p> <p>Redis exchange client factory.</p> <p>Parameters:</p> <ul> <li> <code>hostname</code>               (<code>str</code>)           \u2013            <p>Redis server hostname.</p> </li> <li> <code>port</code>               (<code>int</code>)           \u2013            <p>Redis server port.</p> </li> <li> <code>redis_kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Extra keyword arguments to pass to <code>redis.Redis()</code>.</p> </li> </ul> Source code in <code>academy/exchange/redis.py</code> <pre><code>def __init__(\n    self,\n    hostname: str,\n    port: int,\n    **redis_kwargs: Any,\n) -&gt; None:\n    self.redis_info = _RedisConnectionInfo(hostname, port, redis_kwargs)\n</code></pre>"},{"location":"api/exchange/#academy.exchange.RedisExchangeFactory.create_agent_client","title":"create_agent_client  <code>async</code>","text":"<pre><code>create_agent_client(\n    registration: AgentRegistration[AgentT],\n    request_handler: RequestHandler[RequestT_co],\n) -&gt; AgentExchangeClient[AgentT, ExchangeTransportT]\n</code></pre> <p>Create a new agent exchange client.</p> <p>An agent must be registered with the exchange before an exchange client can be created. For example: <pre><code>factory = ExchangeFactory(...)\nuser_client = factory.create_user_client()\nregistration = user_client.register_agent(...)\nagent_client = factory.create_agent_client(registration, ...)\n</code></pre></p> <p>Parameters:</p> <ul> <li> <code>registration</code>               (<code>AgentRegistration[AgentT]</code>)           \u2013            <p>Registration information returned by the exchange.</p> </li> <li> <code>request_handler</code>               (<code>RequestHandler[RequestT_co]</code>)           \u2013            <p>Agent request message handler.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AgentExchangeClient[AgentT, ExchangeTransportT]</code>           \u2013            <p>Agent exchange client.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BadEntityIdError</code>             \u2013            <p>If an agent with <code>registration.agent_id</code> is not already registered with the exchange.</p> </li> </ul> Source code in <code>academy/exchange/factory.py</code> <pre><code>async def create_agent_client(\n    self,\n    registration: AgentRegistration[AgentT],\n    request_handler: RequestHandler[RequestT_co],\n) -&gt; AgentExchangeClient[AgentT, ExchangeTransportT]:\n    \"\"\"Create a new agent exchange client.\n\n    An agent must be registered with the exchange before an exchange\n    client can be created. For example:\n    ```python\n    factory = ExchangeFactory(...)\n    user_client = factory.create_user_client()\n    registration = user_client.register_agent(...)\n    agent_client = factory.create_agent_client(registration, ...)\n    ```\n\n    Args:\n        registration: Registration information returned by the exchange.\n        request_handler: Agent request message handler.\n\n    Returns:\n        Agent exchange client.\n\n    Raises:\n        BadEntityIdError: If an agent with `registration.agent_id` is not\n            already registered with the exchange.\n    \"\"\"\n    agent_id: AgentId[AgentT] = registration.agent_id\n    transport = await self._create_transport(\n        mailbox_id=agent_id,\n        registration=registration,\n    )\n    assert transport.mailbox_id == agent_id\n    status = await transport.status(agent_id)\n    if status != MailboxStatus.ACTIVE:\n        await transport.close()\n        raise BadEntityIdError(agent_id)\n    return AgentExchangeClient(\n        agent_id,\n        transport,\n        request_handler=request_handler,\n    )\n</code></pre>"},{"location":"api/exchange/#academy.exchange.RedisExchangeFactory.create_user_client","title":"create_user_client  <code>async</code>","text":"<pre><code>create_user_client(\n    *, name: str | None = None, start_listener: bool = True\n) -&gt; UserExchangeClient[ExchangeTransportT]\n</code></pre> <p>Create a new user in the exchange and associated client.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Display name of the client on the exchange.</p> </li> <li> <code>start_listener</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Start a message listener thread.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>UserExchangeClient[ExchangeTransportT]</code>           \u2013            <p>User exchange client.</p> </li> </ul> Source code in <code>academy/exchange/factory.py</code> <pre><code>async def create_user_client(\n    self,\n    *,\n    name: str | None = None,\n    start_listener: bool = True,\n) -&gt; UserExchangeClient[ExchangeTransportT]:\n    \"\"\"Create a new user in the exchange and associated client.\n\n    Args:\n        name: Display name of the client on the exchange.\n        start_listener: Start a message listener thread.\n\n    Returns:\n        User exchange client.\n    \"\"\"\n    transport = await self._create_transport(mailbox_id=None, name=name)\n    user_id = transport.mailbox_id\n    assert isinstance(user_id, UserId)\n    return UserExchangeClient(\n        user_id,\n        transport,\n        start_listener=start_listener,\n    )\n</code></pre>"},{"location":"api/exchange/#academy.exchange.RedisExchangeTransport","title":"RedisExchangeTransport","text":"<pre><code>RedisExchangeTransport(\n    mailbox_id: EntityId,\n    redis_client: Redis,\n    *,\n    redis_info: _RedisConnectionInfo\n)\n</code></pre> <p>               Bases: <code>ExchangeTransportMixin</code>, <code>NoPickleMixin</code></p> <p>Redis exchange transport bound to a specific mailbox.</p> Source code in <code>academy/exchange/redis.py</code> <pre><code>def __init__(\n    self,\n    mailbox_id: EntityId,\n    redis_client: redis.asyncio.Redis,\n    *,\n    redis_info: _RedisConnectionInfo,\n) -&gt; None:\n    self._mailbox_id = mailbox_id\n    self._client = redis_client\n    self._redis_info = redis_info\n</code></pre>"},{"location":"api/exchange/#academy.exchange.RedisExchangeTransport.new","title":"new  <code>async</code> <code>classmethod</code>","text":"<pre><code>new(\n    *,\n    mailbox_id: EntityId | None = None,\n    name: str | None = None,\n    redis_info: _RedisConnectionInfo\n) -&gt; Self\n</code></pre> <p>Instantiate a new transport.</p> <p>Parameters:</p> <ul> <li> <code>mailbox_id</code>               (<code>EntityId | None</code>, default:                   <code>None</code> )           \u2013            <p>Bind the transport to the specific mailbox. If <code>None</code>, a new user entity will be registered and the transport will be bound to that mailbox.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Display name of the redistered entity if <code>mailbox_id</code> is <code>None</code>.</p> </li> <li> <code>redis_info</code>               (<code>_RedisConnectionInfo</code>)           \u2013            <p>Redis connection information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>An instantiated transport bound to a specific mailbox.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ConnectionError</code>             \u2013            <p>If the Redis server is not reachable.</p> </li> </ul> Source code in <code>academy/exchange/redis.py</code> <pre><code>@classmethod\nasync def new(\n    cls,\n    *,\n    mailbox_id: EntityId | None = None,\n    name: str | None = None,\n    redis_info: _RedisConnectionInfo,\n) -&gt; Self:\n    \"\"\"Instantiate a new transport.\n\n    Args:\n        mailbox_id: Bind the transport to the specific mailbox. If `None`,\n            a new user entity will be registered and the transport will be\n            bound to that mailbox.\n        name: Display name of the redistered entity if `mailbox_id` is\n            `None`.\n        redis_info: Redis connection information.\n\n    Returns:\n        An instantiated transport bound to a specific mailbox.\n\n    Raises:\n        redis.exceptions.ConnectionError: If the Redis server is not\n            reachable.\n    \"\"\"\n    client = redis.asyncio.Redis(\n        host=redis_info.hostname,\n        port=redis_info.port,\n        decode_responses=False,\n        **redis_info.kwargs,\n    )\n    # Ensure the redis server is reachable else fail early\n    p = client.ping()\n    assert isinstance(p, Awaitable), (\n        'ping should be awaitable from an async redis instance'\n    )\n    await p\n\n    if mailbox_id is None:\n        mailbox_id = UserId.new(name=name)\n        await client.set(\n            f'active:{mailbox_id.uid}',\n            _MailboxState.ACTIVE.value,\n        )\n        logger.info(\n            'Registered %s in exchange',\n            mailbox_id,\n            extra={'academy.mailbox_id': mailbox_id},\n        )\n    return cls(mailbox_id, client, redis_info=redis_info)\n</code></pre>"},{"location":"api/exchange/#academy.exchange.ExchangeTransport","title":"ExchangeTransport","text":"<p>               Bases: <code>Protocol[AgentRegistrationT_co]</code></p> <p>Low-level exchange communicator.</p> <p>A message exchange hosts mailboxes for each entity (i.e., agent or user) in a multi-agent system. This transport protocol defines mechanisms for entity management (e.g., registration, discovery, status, termination) and for sending/receiving messages from a mailbox. As such, each transport instance is \"bound\" to a specific mailbox in the exchange.</p> Warning <p>A specific exchange transport should not be replicated because multiple client instances receiving from the same mailbox produces undefined agent.</p>"},{"location":"api/exchange/#academy.exchange.ExchangeTransport.mailbox_id","title":"mailbox_id  <code>property</code>","text":"<pre><code>mailbox_id: EntityId\n</code></pre> <p>ID of the mailbox this client is bound to.</p>"},{"location":"api/exchange/#academy.exchange.ExchangeTransport.close","title":"close  <code>async</code>","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the exchange client.</p> Note <p>This does not alter the state of the mailbox this client is bound to. I.e., the mailbox will not be terminated.</p> Source code in <code>academy/exchange/transport.py</code> <pre><code>async def close(self) -&gt; None:\n    \"\"\"Close the exchange client.\n\n    Note:\n        This does not alter the state of the mailbox this client is bound\n        to. I.e., the mailbox will not be terminated.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/exchange/#academy.exchange.ExchangeTransport.discover","title":"discover  <code>async</code>","text":"<pre><code>discover(\n    agent: type[Agent], *, allow_subclasses: bool = True\n) -&gt; tuple[AgentId[Any], ...]\n</code></pre> <p>Discover peer agents with a given agent.</p> Warning <p>Implementations of this method are often O(n) and scan the types of all agents registered to the exchange.</p> <p>Parameters:</p> <ul> <li> <code>agent</code>               (<code>type[Agent]</code>)           \u2013            <p>Agent type of interest.</p> </li> <li> <code>allow_subclasses</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Return agents implementing subclasses of the agent.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[AgentId[Any], ...]</code>           \u2013            <p>Tuple of agent IDs implementing the agent.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ExchangeError</code>             \u2013            <p>Error returned by the exchange.</p> </li> </ul> Source code in <code>academy/exchange/transport.py</code> <pre><code>async def discover(\n    self,\n    agent: type[Agent],\n    *,\n    allow_subclasses: bool = True,\n) -&gt; tuple[AgentId[Any], ...]:\n    \"\"\"Discover peer agents with a given agent.\n\n    Warning:\n        Implementations of this method are often O(n) and scan the types\n        of all agents registered to the exchange.\n\n    Args:\n        agent: Agent type of interest.\n        allow_subclasses: Return agents implementing subclasses of the\n            agent.\n\n    Returns:\n        Tuple of agent IDs implementing the agent.\n\n    Raises:\n        ExchangeError: Error returned by the exchange.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/exchange/#academy.exchange.ExchangeTransport.factory","title":"factory","text":"<pre><code>factory() -&gt; ExchangeFactory[Self]\n</code></pre> <p>Get an exchange factory.</p> Source code in <code>academy/exchange/transport.py</code> <pre><code>def factory(self) -&gt; ExchangeFactory[Self]:\n    \"\"\"Get an exchange factory.\"\"\"\n    ...\n</code></pre>"},{"location":"api/exchange/#academy.exchange.ExchangeTransport.recv","title":"recv  <code>async</code>","text":"<pre><code>recv(timeout: float | None = None) -&gt; Message[Any]\n</code></pre> <p>Receive the next message sent to the mailbox.</p> <p>This blocks until the next message is received, there is a timeout, or the mailbox is terminated.</p> <p>Parameters:</p> <ul> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional timeout in seconds to wait for the next message. If <code>None</code>, the default, block forever until the next message or the mailbox is closed.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>MailboxTerminatedError</code>             \u2013            <p>If the mailbox was closed.</p> </li> <li> <code>ExchangeError</code>             \u2013            <p>Error returned by the exchange.</p> </li> <li> <code>TimeoutError</code>             \u2013            <p>If a <code>timeout</code> was specified and exceeded.</p> </li> </ul> Source code in <code>academy/exchange/transport.py</code> <pre><code>async def recv(self, timeout: float | None = None) -&gt; Message[Any]:\n    \"\"\"Receive the next message sent to the mailbox.\n\n    This blocks until the next message is received, there is a timeout, or\n    the mailbox is terminated.\n\n    Args:\n        timeout: Optional timeout in seconds to wait for the next\n            message. If `None`, the default, block forever until the\n            next message or the mailbox is closed.\n\n    Raises:\n        MailboxTerminatedError: If the mailbox was closed.\n        ExchangeError: Error returned by the exchange.\n        TimeoutError: If a `timeout` was specified and exceeded.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/exchange/#academy.exchange.ExchangeTransport.register_agent","title":"register_agent  <code>async</code>","text":"<pre><code>register_agent(\n    agent: type[AgentT], *, name: str | None = None\n) -&gt; AgentRegistrationT_co\n</code></pre> <p>Register a new agent and associated mailbox with the exchange.</p> <p>Parameters:</p> <ul> <li> <code>agent</code>               (<code>type[AgentT]</code>)           \u2013            <p>Agent type of the agent.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional display name for the agent.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AgentRegistrationT_co</code>           \u2013            <p>Agent registration info.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ExchangeError</code>             \u2013            <p>Error returned by the exchange.</p> </li> </ul> Source code in <code>academy/exchange/transport.py</code> <pre><code>async def register_agent(\n    self,\n    agent: type[AgentT],\n    *,\n    name: str | None = None,\n) -&gt; AgentRegistrationT_co:\n    \"\"\"Register a new agent and associated mailbox with the exchange.\n\n    Args:\n        agent: Agent type of the agent.\n        name: Optional display name for the agent.\n\n    Returns:\n        Agent registration info.\n\n    Raises:\n        ExchangeError: Error returned by the exchange.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/exchange/#academy.exchange.ExchangeTransport.send","title":"send  <code>async</code>","text":"<pre><code>send(message: Message[Any]) -&gt; None\n</code></pre> <p>Send a message to a mailbox.</p> <p>Parameters:</p> <ul> <li> <code>message</code>               (<code>Message[Any]</code>)           \u2013            <p>Message to send.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BadEntityIdError</code>             \u2013            <p>If a mailbox for <code>message.dest</code> does not exist.</p> </li> <li> <code>MailboxTerminatedError</code>             \u2013            <p>If the mailbox was closed.</p> </li> <li> <code>ExchangeError</code>             \u2013            <p>Error returned by the exchange.</p> </li> </ul> Source code in <code>academy/exchange/transport.py</code> <pre><code>async def send(self, message: Message[Any]) -&gt; None:\n    \"\"\"Send a message to a mailbox.\n\n    Args:\n        message: Message to send.\n\n    Raises:\n        BadEntityIdError: If a mailbox for `message.dest` does not exist.\n        MailboxTerminatedError: If the mailbox was closed.\n        ExchangeError: Error returned by the exchange.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/exchange/#academy.exchange.ExchangeTransport.status","title":"status  <code>async</code>","text":"<pre><code>status(uid: EntityId) -&gt; MailboxStatus\n</code></pre> <p>Check the status of a mailbox in the exchange.</p> <p>Parameters:</p> <ul> <li> <code>uid</code>               (<code>EntityId</code>)           \u2013            <p>Entity identifier of the mailbox to check.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ExchangeError</code>             \u2013            <p>Error returned by the exchange.</p> </li> </ul> Source code in <code>academy/exchange/transport.py</code> <pre><code>async def status(self, uid: EntityId) -&gt; MailboxStatus:\n    \"\"\"Check the status of a mailbox in the exchange.\n\n    Args:\n        uid: Entity identifier of the mailbox to check.\n\n    Raises:\n        ExchangeError: Error returned by the exchange.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/exchange/#academy.exchange.ExchangeTransport.terminate","title":"terminate  <code>async</code>","text":"<pre><code>terminate(uid: EntityId) -&gt; None\n</code></pre> <p>Terminate a mailbox in the exchange.</p> <p>Once an entity's mailbox is terminated:</p> <ul> <li>All request messages in the mailbox will be replied to with a   <code>MailboxTerminatedError</code>.</li> <li>All calls to   <code>recv()</code>   will raise a   <code>MailboxTerminatedError</code>.</li> <li>All attempts to   <code>send()</code>   to this mailbox by other entities will raise a   <code>MailboxTerminatedError</code>.</li> </ul> Note <p>This method is a no-op if the mailbox does not exist.</p> <p>Parameters:</p> <ul> <li> <code>uid</code>               (<code>EntityId</code>)           \u2013            <p>Entity identifier of the mailbox to close.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ExchangeError</code>             \u2013            <p>Error returned by the exchange.</p> </li> </ul> Source code in <code>academy/exchange/transport.py</code> <pre><code>async def terminate(self, uid: EntityId) -&gt; None:\n    \"\"\"Terminate a mailbox in the exchange.\n\n    Once an entity's mailbox is terminated:\n\n    * All request messages in the mailbox will be replied to with a\n      [`MailboxTerminatedError`][academy.exception.MailboxTerminatedError].\n    * All calls to\n      [`recv()`][academy.exchange.transport.ExchangeTransport.recv]\n      will raise a\n      [`MailboxTerminatedError`][academy.exception.MailboxTerminatedError].\n    * All attempts to\n      [`send()`][academy.exchange.transport.ExchangeTransport.send]\n      to this mailbox by other entities will raise a\n      [`MailboxTerminatedError`][academy.exception.MailboxTerminatedError].\n\n    Note:\n        This method is a no-op if the mailbox does not exist.\n\n    Args:\n        uid: Entity identifier of the mailbox to close.\n\n    Raises:\n        ExchangeError: Error returned by the exchange.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/exchange/#academy.exchange.MailboxStatus","title":"MailboxStatus","text":"<p>               Bases: <code>Enum</code></p> <p>Exchange mailbox status.</p>"},{"location":"api/exchange/#academy.exchange.MailboxStatus.MISSING","title":"MISSING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MISSING = 'MISSING'\n</code></pre> <p>Mailbox does not exist.</p>"},{"location":"api/exchange/#academy.exchange.MailboxStatus.ACTIVE","title":"ACTIVE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ACTIVE = 'ACTIVE'\n</code></pre> <p>Mailbox exists and is accepting messages.</p>"},{"location":"api/exchange/#academy.exchange.MailboxStatus.TERMINATED","title":"TERMINATED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TERMINATED = 'TERMINATED'\n</code></pre> <p>Mailbox was terminated and no longer accepts messages.</p>"},{"location":"api/exchange/client/","title":"academy.exchange.client","text":"<code>academy/exchange/client.py</code>"},{"location":"api/exchange/client/#academy.exchange.client.ExchangeClient","title":"ExchangeClient","text":"<pre><code>ExchangeClient(transport: ExchangeTransportT)\n</code></pre> <p>               Bases: <code>ABC</code>, <code>Generic[ExchangeTransportT]</code></p> <p>Base exchange client.</p> Warning <p>Exchange clients should only be created via <code>ExchangeFactory.create_agent_client()</code> or <code>ExchangeFactory.create_user_client()</code>!</p> <p>Parameters:</p> <ul> <li> <code>transport</code>               (<code>ExchangeTransportT</code>)           \u2013            <p>Exchange transport bound to a mailbox.</p> </li> </ul> Source code in <code>academy/exchange/client.py</code> <pre><code>def __init__(\n    self,\n    transport: ExchangeTransportT,\n) -&gt; None:\n    self._transport = transport\n    self._handles: WeakValueDictionary[uuid.UUID, Handle[Any]] = (\n        WeakValueDictionary()\n    )\n    self._close_lock = asyncio.Lock()\n    self._closed = False\n</code></pre>"},{"location":"api/exchange/client/#academy.exchange.client.ExchangeClient.client_id","title":"client_id  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>client_id: EntityId\n</code></pre> <p>Client ID as registered with the exchange.</p>"},{"location":"api/exchange/client/#academy.exchange.client.ExchangeClient.close","title":"close  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the transport.</p> Source code in <code>academy/exchange/client.py</code> <pre><code>@abc.abstractmethod\nasync def close(self) -&gt; None:\n    \"\"\"Close the transport.\"\"\"\n    ...\n</code></pre>"},{"location":"api/exchange/client/#academy.exchange.client.ExchangeClient.discover","title":"discover  <code>async</code>","text":"<pre><code>discover(\n    agent: type[Agent], *, allow_subclasses: bool = True\n) -&gt; tuple[AgentId[Any], ...]\n</code></pre> <p>Discover peer agents with a given agent.</p> <p>Parameters:</p> <ul> <li> <code>agent</code>               (<code>type[Agent]</code>)           \u2013            <p>Agent type of interest.</p> </li> <li> <code>allow_subclasses</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Return agents implementing subclasses of the agent.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[AgentId[Any], ...]</code>           \u2013            <p>Tuple of agent IDs implementing the agent.</p> </li> </ul> Source code in <code>academy/exchange/client.py</code> <pre><code>async def discover(\n    self,\n    agent: type[Agent],\n    *,\n    allow_subclasses: bool = True,\n) -&gt; tuple[AgentId[Any], ...]:\n    \"\"\"Discover peer agents with a given agent.\n\n    Args:\n        agent: Agent type of interest.\n        allow_subclasses: Return agents implementing subclasses of the\n            agent.\n\n    Returns:\n        Tuple of agent IDs implementing the agent.\n    \"\"\"\n    return await self._transport.discover(\n        agent,\n        allow_subclasses=allow_subclasses,\n    )\n</code></pre>"},{"location":"api/exchange/client/#academy.exchange.client.ExchangeClient.factory","title":"factory","text":"<pre><code>factory() -&gt; ExchangeFactory[ExchangeTransportT]\n</code></pre> <p>Get an exchange factory.</p> Source code in <code>academy/exchange/client.py</code> <pre><code>def factory(self) -&gt; ExchangeFactory[ExchangeTransportT]:\n    \"\"\"Get an exchange factory.\"\"\"\n    return self._transport.factory()\n</code></pre>"},{"location":"api/exchange/client/#academy.exchange.client.ExchangeClient.register_handle","title":"register_handle","text":"<pre><code>register_handle(handle: Handle[AgentT]) -&gt; None\n</code></pre> <p>Register an existing handle to receive messages.</p> <p>Parameters:</p> <ul> <li> <code>handle</code>               (<code>Handle[AgentT]</code>)           \u2013            <p>Handle to register.</p> </li> </ul> Source code in <code>academy/exchange/client.py</code> <pre><code>def register_handle(self, handle: Handle[AgentT]) -&gt; None:\n    \"\"\"Register an existing handle to receive messages.\n\n    Args:\n        handle: Handle to register.\n    \"\"\"\n    self._handles[handle.handle_id] = handle\n</code></pre>"},{"location":"api/exchange/client/#academy.exchange.client.ExchangeClient.register_agent","title":"register_agent  <code>async</code>","text":"<pre><code>register_agent(\n    agent: type[AgentT], *, name: str | None = None\n) -&gt; AgentRegistration[AgentT]\n</code></pre> <p>Register a new agent and associated mailbox with the exchange.</p> <p>Parameters:</p> <ul> <li> <code>agent</code>               (<code>type[AgentT]</code>)           \u2013            <p>Agent type of the agent.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional display name for the agent.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AgentRegistration[AgentT]</code>           \u2013            <p>Agent registration info.</p> </li> </ul> Source code in <code>academy/exchange/client.py</code> <pre><code>async def register_agent(\n    self,\n    agent: type[AgentT],\n    *,\n    name: str | None = None,\n) -&gt; AgentRegistration[AgentT]:\n    \"\"\"Register a new agent and associated mailbox with the exchange.\n\n    Args:\n        agent: Agent type of the agent.\n        name: Optional display name for the agent.\n\n    Returns:\n        Agent registration info.\n    \"\"\"\n    registration = await self._transport.register_agent(\n        agent,\n        name=name,\n    )\n    logger.info(\n        'Registered %s in exchange',\n        registration.agent_id,\n        extra={'academy.agent_id': registration.agent_id},\n    )\n    return registration\n</code></pre>"},{"location":"api/exchange/client/#academy.exchange.client.ExchangeClient.send","title":"send  <code>async</code>","text":"<pre><code>send(message: Message[Any]) -&gt; None\n</code></pre> <p>Send a message to a mailbox.</p> <p>Parameters:</p> <ul> <li> <code>message</code>               (<code>Message[Any]</code>)           \u2013            <p>Message to send.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BadEntityIdError</code>             \u2013            <p>If a mailbox for <code>message.dest</code> does not exist.</p> </li> <li> <code>MailboxTerminatedError</code>             \u2013            <p>If the mailbox was closed.</p> </li> </ul> Source code in <code>academy/exchange/client.py</code> <pre><code>async def send(self, message: Message[Any]) -&gt; None:\n    \"\"\"Send a message to a mailbox.\n\n    Args:\n        message: Message to send.\n\n    Raises:\n        BadEntityIdError: If a mailbox for `message.dest` does not exist.\n        MailboxTerminatedError: If the mailbox was closed.\n    \"\"\"\n    await self._transport.send(message)\n    logger.debug(\n        'Sent %s to %s',\n        type(message.body).__name__,\n        message.dest,\n        extra=message.log_extra(),\n    )\n</code></pre>"},{"location":"api/exchange/client/#academy.exchange.client.ExchangeClient.status","title":"status  <code>async</code>","text":"<pre><code>status(uid: EntityId) -&gt; MailboxStatus\n</code></pre> <p>Check the status of a mailbox in the exchange.</p> <p>Parameters:</p> <ul> <li> <code>uid</code>               (<code>EntityId</code>)           \u2013            <p>Entity identifier of the mailbox to check.</p> </li> </ul> Source code in <code>academy/exchange/client.py</code> <pre><code>async def status(self, uid: EntityId) -&gt; MailboxStatus:\n    \"\"\"Check the status of a mailbox in the exchange.\n\n    Args:\n        uid: Entity identifier of the mailbox to check.\n    \"\"\"\n    return await self._transport.status(uid)\n</code></pre>"},{"location":"api/exchange/client/#academy.exchange.client.ExchangeClient.terminate","title":"terminate  <code>async</code>","text":"<pre><code>terminate(uid: EntityId) -&gt; None\n</code></pre> <p>Terminate a mailbox in the exchange.</p> <p>Terminating a mailbox means that the corresponding entity will no longer be able to receive messages.</p> Note <p>This method is a no-op if the mailbox does not exist.</p> <p>Parameters:</p> <ul> <li> <code>uid</code>               (<code>EntityId</code>)           \u2013            <p>Entity identifier of the mailbox to close.</p> </li> </ul> Source code in <code>academy/exchange/client.py</code> <pre><code>async def terminate(self, uid: EntityId) -&gt; None:\n    \"\"\"Terminate a mailbox in the exchange.\n\n    Terminating a mailbox means that the corresponding entity will no\n    longer be able to receive messages.\n\n    Note:\n        This method is a no-op if the mailbox does not exist.\n\n    Args:\n        uid: Entity identifier of the mailbox to close.\n    \"\"\"\n    await self._transport.terminate(uid)\n</code></pre>"},{"location":"api/exchange/client/#academy.exchange.client.AgentExchangeClient","title":"AgentExchangeClient","text":"<pre><code>AgentExchangeClient(\n    agent_id: AgentId[AgentT],\n    transport: ExchangeTransportT,\n    request_handler: RequestHandler[RequestT_co],\n)\n</code></pre> <p>               Bases: <code>ExchangeClient[ExchangeTransportT]</code>, <code>Generic[AgentT, ExchangeTransportT]</code></p> <p>Agent exchange client.</p> Warning <p>Agent exchange clients should only be created via <code>ExchangeFactory.create_agent_client()</code>!</p> <p>Parameters:</p> <ul> <li> <code>agent_id</code>               (<code>AgentId[AgentT]</code>)           \u2013            <p>Agent ID.</p> </li> <li> <code>transport</code>               (<code>ExchangeTransportT</code>)           \u2013            <p>Exchange transport bound to <code>agent_id</code>.</p> </li> <li> <code>request_handler</code>               (<code>RequestHandler[RequestT_co]</code>)           \u2013            <p>Request handler of the agent that will be called for each message received to this agent's mailbox. start_listener: Start a message listener thread.</p> </li> </ul> Source code in <code>academy/exchange/client.py</code> <pre><code>def __init__(\n    self,\n    agent_id: AgentId[AgentT],\n    transport: ExchangeTransportT,\n    request_handler: RequestHandler[RequestT_co],\n) -&gt; None:\n    super().__init__(transport)\n    self._agent_id = agent_id\n    self._request_handler = request_handler\n</code></pre>"},{"location":"api/exchange/client/#academy.exchange.client.AgentExchangeClient.client_id","title":"client_id  <code>property</code>","text":"<pre><code>client_id: AgentId[AgentT]\n</code></pre> <p>Agent ID of the client.</p>"},{"location":"api/exchange/client/#academy.exchange.client.AgentExchangeClient.close","title":"close  <code>async</code>","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the user client.</p> <p>This closes the underlying exchange transport and all handles created by this client. The agent's mailbox will not be terminated so the agent can be started again later.</p> Source code in <code>academy/exchange/client.py</code> <pre><code>async def close(self) -&gt; None:\n    \"\"\"Close the user client.\n\n    This closes the underlying exchange transport and all handles created\n    by this client. The agent's mailbox will not be terminated so the agent\n    can be started again later.\n    \"\"\"\n    async with self._close_lock:\n        if self._closed:\n            return\n\n        await self._transport.close()\n        self._closed = True\n        logger.info(\n            'Closed exchange client for %s',\n            self.client_id,\n            extra={'academy.mailbox_id': self.client_id},\n        )\n</code></pre>"},{"location":"api/exchange/client/#academy.exchange.client.AgentExchangeClient.discover","title":"discover  <code>async</code>","text":"<pre><code>discover(\n    agent: type[Agent], *, allow_subclasses: bool = True\n) -&gt; tuple[AgentId[Any], ...]\n</code></pre> <p>Discover peer agents with a given agent.</p> <p>Parameters:</p> <ul> <li> <code>agent</code>               (<code>type[Agent]</code>)           \u2013            <p>Agent type of interest.</p> </li> <li> <code>allow_subclasses</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Return agents implementing subclasses of the agent.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[AgentId[Any], ...]</code>           \u2013            <p>Tuple of agent IDs implementing the agent.</p> </li> </ul> Source code in <code>academy/exchange/client.py</code> <pre><code>async def discover(\n    self,\n    agent: type[Agent],\n    *,\n    allow_subclasses: bool = True,\n) -&gt; tuple[AgentId[Any], ...]:\n    \"\"\"Discover peer agents with a given agent.\n\n    Args:\n        agent: Agent type of interest.\n        allow_subclasses: Return agents implementing subclasses of the\n            agent.\n\n    Returns:\n        Tuple of agent IDs implementing the agent.\n    \"\"\"\n    return await self._transport.discover(\n        agent,\n        allow_subclasses=allow_subclasses,\n    )\n</code></pre>"},{"location":"api/exchange/client/#academy.exchange.client.AgentExchangeClient.factory","title":"factory","text":"<pre><code>factory() -&gt; ExchangeFactory[ExchangeTransportT]\n</code></pre> <p>Get an exchange factory.</p> Source code in <code>academy/exchange/client.py</code> <pre><code>def factory(self) -&gt; ExchangeFactory[ExchangeTransportT]:\n    \"\"\"Get an exchange factory.\"\"\"\n    return self._transport.factory()\n</code></pre>"},{"location":"api/exchange/client/#academy.exchange.client.AgentExchangeClient.register_handle","title":"register_handle","text":"<pre><code>register_handle(handle: Handle[AgentT]) -&gt; None\n</code></pre> <p>Register an existing handle to receive messages.</p> <p>Parameters:</p> <ul> <li> <code>handle</code>               (<code>Handle[AgentT]</code>)           \u2013            <p>Handle to register.</p> </li> </ul> Source code in <code>academy/exchange/client.py</code> <pre><code>def register_handle(self, handle: Handle[AgentT]) -&gt; None:\n    \"\"\"Register an existing handle to receive messages.\n\n    Args:\n        handle: Handle to register.\n    \"\"\"\n    self._handles[handle.handle_id] = handle\n</code></pre>"},{"location":"api/exchange/client/#academy.exchange.client.AgentExchangeClient.register_agent","title":"register_agent  <code>async</code>","text":"<pre><code>register_agent(\n    agent: type[AgentT], *, name: str | None = None\n) -&gt; AgentRegistration[AgentT]\n</code></pre> <p>Register a new agent and associated mailbox with the exchange.</p> <p>Parameters:</p> <ul> <li> <code>agent</code>               (<code>type[AgentT]</code>)           \u2013            <p>Agent type of the agent.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional display name for the agent.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AgentRegistration[AgentT]</code>           \u2013            <p>Agent registration info.</p> </li> </ul> Source code in <code>academy/exchange/client.py</code> <pre><code>async def register_agent(\n    self,\n    agent: type[AgentT],\n    *,\n    name: str | None = None,\n) -&gt; AgentRegistration[AgentT]:\n    \"\"\"Register a new agent and associated mailbox with the exchange.\n\n    Args:\n        agent: Agent type of the agent.\n        name: Optional display name for the agent.\n\n    Returns:\n        Agent registration info.\n    \"\"\"\n    registration = await self._transport.register_agent(\n        agent,\n        name=name,\n    )\n    logger.info(\n        'Registered %s in exchange',\n        registration.agent_id,\n        extra={'academy.agent_id': registration.agent_id},\n    )\n    return registration\n</code></pre>"},{"location":"api/exchange/client/#academy.exchange.client.AgentExchangeClient.send","title":"send  <code>async</code>","text":"<pre><code>send(message: Message[Any]) -&gt; None\n</code></pre> <p>Send a message to a mailbox.</p> <p>Parameters:</p> <ul> <li> <code>message</code>               (<code>Message[Any]</code>)           \u2013            <p>Message to send.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BadEntityIdError</code>             \u2013            <p>If a mailbox for <code>message.dest</code> does not exist.</p> </li> <li> <code>MailboxTerminatedError</code>             \u2013            <p>If the mailbox was closed.</p> </li> </ul> Source code in <code>academy/exchange/client.py</code> <pre><code>async def send(self, message: Message[Any]) -&gt; None:\n    \"\"\"Send a message to a mailbox.\n\n    Args:\n        message: Message to send.\n\n    Raises:\n        BadEntityIdError: If a mailbox for `message.dest` does not exist.\n        MailboxTerminatedError: If the mailbox was closed.\n    \"\"\"\n    await self._transport.send(message)\n    logger.debug(\n        'Sent %s to %s',\n        type(message.body).__name__,\n        message.dest,\n        extra=message.log_extra(),\n    )\n</code></pre>"},{"location":"api/exchange/client/#academy.exchange.client.AgentExchangeClient.status","title":"status  <code>async</code>","text":"<pre><code>status(uid: EntityId) -&gt; MailboxStatus\n</code></pre> <p>Check the status of a mailbox in the exchange.</p> <p>Parameters:</p> <ul> <li> <code>uid</code>               (<code>EntityId</code>)           \u2013            <p>Entity identifier of the mailbox to check.</p> </li> </ul> Source code in <code>academy/exchange/client.py</code> <pre><code>async def status(self, uid: EntityId) -&gt; MailboxStatus:\n    \"\"\"Check the status of a mailbox in the exchange.\n\n    Args:\n        uid: Entity identifier of the mailbox to check.\n    \"\"\"\n    return await self._transport.status(uid)\n</code></pre>"},{"location":"api/exchange/client/#academy.exchange.client.AgentExchangeClient.terminate","title":"terminate  <code>async</code>","text":"<pre><code>terminate(uid: EntityId) -&gt; None\n</code></pre> <p>Terminate a mailbox in the exchange.</p> <p>Terminating a mailbox means that the corresponding entity will no longer be able to receive messages.</p> Note <p>This method is a no-op if the mailbox does not exist.</p> <p>Parameters:</p> <ul> <li> <code>uid</code>               (<code>EntityId</code>)           \u2013            <p>Entity identifier of the mailbox to close.</p> </li> </ul> Source code in <code>academy/exchange/client.py</code> <pre><code>async def terminate(self, uid: EntityId) -&gt; None:\n    \"\"\"Terminate a mailbox in the exchange.\n\n    Terminating a mailbox means that the corresponding entity will no\n    longer be able to receive messages.\n\n    Note:\n        This method is a no-op if the mailbox does not exist.\n\n    Args:\n        uid: Entity identifier of the mailbox to close.\n    \"\"\"\n    await self._transport.terminate(uid)\n</code></pre>"},{"location":"api/exchange/client/#academy.exchange.client.UserExchangeClient","title":"UserExchangeClient","text":"<pre><code>UserExchangeClient(\n    user_id: UserId,\n    transport: ExchangeTransportT,\n    *,\n    start_listener: bool = True\n)\n</code></pre> <p>               Bases: <code>ExchangeClient[ExchangeTransportT]</code></p> <p>User exchange client.</p> Warning <p>User exchange clients should only be created via <code>ExchangeFactory.create_user_client()</code>!</p> <p>Parameters:</p> <ul> <li> <code>user_id</code>               (<code>UserId</code>)           \u2013            <p>User ID.</p> </li> <li> <code>transport</code>               (<code>ExchangeTransportT</code>)           \u2013            <p>Exchange transport bound to <code>user_id</code>.</p> </li> <li> <code>start_listener</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Start a message listener thread.</p> </li> </ul> Source code in <code>academy/exchange/client.py</code> <pre><code>def __init__(\n    self,\n    user_id: UserId,\n    transport: ExchangeTransportT,\n    *,\n    start_listener: bool = True,\n) -&gt; None:\n    super().__init__(transport)\n    self._user_id = user_id\n    self._listener_task: asyncio.Task[None] | None = None\n    if start_listener:\n        self._listener_task = spawn_guarded_background_task(\n            self._listen_for_messages(),\n            name=f'user-exchange-listener-{self.client_id}',\n        )\n</code></pre>"},{"location":"api/exchange/client/#academy.exchange.client.UserExchangeClient.client_id","title":"client_id  <code>property</code>","text":"<pre><code>client_id: UserId\n</code></pre> <p>User ID of the client.</p>"},{"location":"api/exchange/client/#academy.exchange.client.UserExchangeClient.close","title":"close  <code>async</code>","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the user client.</p> <p>This terminates the user's mailbox, closes the underlying exchange transport.</p> Source code in <code>academy/exchange/client.py</code> <pre><code>async def close(self) -&gt; None:\n    \"\"\"Close the user client.\n\n    This terminates the user's mailbox, closes the underlying exchange\n    transport.\n    \"\"\"\n    async with self._close_lock:\n        if self._closed:\n            return\n\n        await self._transport.terminate(self.client_id)\n        logger.info(\n            f'Terminated mailbox for {self.client_id}',\n            extra={'academy.mailbox_id': self.client_id},\n        )\n        await self._stop_listener_task()\n        await self._transport.close()\n        self._closed = True\n        logger.info(\n            'Closed exchange client for %s',\n            self.client_id,\n            extra={'academy.mailbox_id': self.client_id},\n        )\n</code></pre>"},{"location":"api/exchange/client/#academy.exchange.client.UserExchangeClient.discover","title":"discover  <code>async</code>","text":"<pre><code>discover(\n    agent: type[Agent], *, allow_subclasses: bool = True\n) -&gt; tuple[AgentId[Any], ...]\n</code></pre> <p>Discover peer agents with a given agent.</p> <p>Parameters:</p> <ul> <li> <code>agent</code>               (<code>type[Agent]</code>)           \u2013            <p>Agent type of interest.</p> </li> <li> <code>allow_subclasses</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Return agents implementing subclasses of the agent.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[AgentId[Any], ...]</code>           \u2013            <p>Tuple of agent IDs implementing the agent.</p> </li> </ul> Source code in <code>academy/exchange/client.py</code> <pre><code>async def discover(\n    self,\n    agent: type[Agent],\n    *,\n    allow_subclasses: bool = True,\n) -&gt; tuple[AgentId[Any], ...]:\n    \"\"\"Discover peer agents with a given agent.\n\n    Args:\n        agent: Agent type of interest.\n        allow_subclasses: Return agents implementing subclasses of the\n            agent.\n\n    Returns:\n        Tuple of agent IDs implementing the agent.\n    \"\"\"\n    return await self._transport.discover(\n        agent,\n        allow_subclasses=allow_subclasses,\n    )\n</code></pre>"},{"location":"api/exchange/client/#academy.exchange.client.UserExchangeClient.factory","title":"factory","text":"<pre><code>factory() -&gt; ExchangeFactory[ExchangeTransportT]\n</code></pre> <p>Get an exchange factory.</p> Source code in <code>academy/exchange/client.py</code> <pre><code>def factory(self) -&gt; ExchangeFactory[ExchangeTransportT]:\n    \"\"\"Get an exchange factory.\"\"\"\n    return self._transport.factory()\n</code></pre>"},{"location":"api/exchange/client/#academy.exchange.client.UserExchangeClient.register_handle","title":"register_handle","text":"<pre><code>register_handle(handle: Handle[AgentT]) -&gt; None\n</code></pre> <p>Register an existing handle to receive messages.</p> <p>Parameters:</p> <ul> <li> <code>handle</code>               (<code>Handle[AgentT]</code>)           \u2013            <p>Handle to register.</p> </li> </ul> Source code in <code>academy/exchange/client.py</code> <pre><code>def register_handle(self, handle: Handle[AgentT]) -&gt; None:\n    \"\"\"Register an existing handle to receive messages.\n\n    Args:\n        handle: Handle to register.\n    \"\"\"\n    self._handles[handle.handle_id] = handle\n</code></pre>"},{"location":"api/exchange/client/#academy.exchange.client.UserExchangeClient.register_agent","title":"register_agent  <code>async</code>","text":"<pre><code>register_agent(\n    agent: type[AgentT], *, name: str | None = None\n) -&gt; AgentRegistration[AgentT]\n</code></pre> <p>Register a new agent and associated mailbox with the exchange.</p> <p>Parameters:</p> <ul> <li> <code>agent</code>               (<code>type[AgentT]</code>)           \u2013            <p>Agent type of the agent.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional display name for the agent.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AgentRegistration[AgentT]</code>           \u2013            <p>Agent registration info.</p> </li> </ul> Source code in <code>academy/exchange/client.py</code> <pre><code>async def register_agent(\n    self,\n    agent: type[AgentT],\n    *,\n    name: str | None = None,\n) -&gt; AgentRegistration[AgentT]:\n    \"\"\"Register a new agent and associated mailbox with the exchange.\n\n    Args:\n        agent: Agent type of the agent.\n        name: Optional display name for the agent.\n\n    Returns:\n        Agent registration info.\n    \"\"\"\n    registration = await self._transport.register_agent(\n        agent,\n        name=name,\n    )\n    logger.info(\n        'Registered %s in exchange',\n        registration.agent_id,\n        extra={'academy.agent_id': registration.agent_id},\n    )\n    return registration\n</code></pre>"},{"location":"api/exchange/client/#academy.exchange.client.UserExchangeClient.send","title":"send  <code>async</code>","text":"<pre><code>send(message: Message[Any]) -&gt; None\n</code></pre> <p>Send a message to a mailbox.</p> <p>Parameters:</p> <ul> <li> <code>message</code>               (<code>Message[Any]</code>)           \u2013            <p>Message to send.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BadEntityIdError</code>             \u2013            <p>If a mailbox for <code>message.dest</code> does not exist.</p> </li> <li> <code>MailboxTerminatedError</code>             \u2013            <p>If the mailbox was closed.</p> </li> </ul> Source code in <code>academy/exchange/client.py</code> <pre><code>async def send(self, message: Message[Any]) -&gt; None:\n    \"\"\"Send a message to a mailbox.\n\n    Args:\n        message: Message to send.\n\n    Raises:\n        BadEntityIdError: If a mailbox for `message.dest` does not exist.\n        MailboxTerminatedError: If the mailbox was closed.\n    \"\"\"\n    await self._transport.send(message)\n    logger.debug(\n        'Sent %s to %s',\n        type(message.body).__name__,\n        message.dest,\n        extra=message.log_extra(),\n    )\n</code></pre>"},{"location":"api/exchange/client/#academy.exchange.client.UserExchangeClient.status","title":"status  <code>async</code>","text":"<pre><code>status(uid: EntityId) -&gt; MailboxStatus\n</code></pre> <p>Check the status of a mailbox in the exchange.</p> <p>Parameters:</p> <ul> <li> <code>uid</code>               (<code>EntityId</code>)           \u2013            <p>Entity identifier of the mailbox to check.</p> </li> </ul> Source code in <code>academy/exchange/client.py</code> <pre><code>async def status(self, uid: EntityId) -&gt; MailboxStatus:\n    \"\"\"Check the status of a mailbox in the exchange.\n\n    Args:\n        uid: Entity identifier of the mailbox to check.\n    \"\"\"\n    return await self._transport.status(uid)\n</code></pre>"},{"location":"api/exchange/client/#academy.exchange.client.UserExchangeClient.terminate","title":"terminate  <code>async</code>","text":"<pre><code>terminate(uid: EntityId) -&gt; None\n</code></pre> <p>Terminate a mailbox in the exchange.</p> <p>Terminating a mailbox means that the corresponding entity will no longer be able to receive messages.</p> Note <p>This method is a no-op if the mailbox does not exist.</p> <p>Parameters:</p> <ul> <li> <code>uid</code>               (<code>EntityId</code>)           \u2013            <p>Entity identifier of the mailbox to close.</p> </li> </ul> Source code in <code>academy/exchange/client.py</code> <pre><code>async def terminate(self, uid: EntityId) -&gt; None:\n    \"\"\"Terminate a mailbox in the exchange.\n\n    Terminating a mailbox means that the corresponding entity will no\n    longer be able to receive messages.\n\n    Note:\n        This method is a no-op if the mailbox does not exist.\n\n    Args:\n        uid: Entity identifier of the mailbox to close.\n    \"\"\"\n    await self._transport.terminate(uid)\n</code></pre>"},{"location":"api/exchange/factory/","title":"academy.exchange.factory","text":"<code>academy/exchange/factory.py</code>"},{"location":"api/exchange/factory/#academy.exchange.factory.ExchangeFactory","title":"ExchangeFactory","text":"<p>               Bases: <code>ABC</code>, <code>Generic[ExchangeTransportT]</code></p> <p>Exchange client factory.</p> <p>An exchange factory is used to mint new exchange clients for users and agents, encapsulating the complexities of instantiating the underlying communication classes (the <code>ExchangeTransport</code>).</p> Warning <p>Factory implementations must be efficiently pickleable because factory instances are shared between user and agent processes so that all entities can create clients to the same exchange.</p>"},{"location":"api/exchange/factory/#academy.exchange.factory.ExchangeFactory.create_agent_client","title":"create_agent_client  <code>async</code>","text":"<pre><code>create_agent_client(\n    registration: AgentRegistration[AgentT],\n    request_handler: RequestHandler[RequestT_co],\n) -&gt; AgentExchangeClient[AgentT, ExchangeTransportT]\n</code></pre> <p>Create a new agent exchange client.</p> <p>An agent must be registered with the exchange before an exchange client can be created. For example: <pre><code>factory = ExchangeFactory(...)\nuser_client = factory.create_user_client()\nregistration = user_client.register_agent(...)\nagent_client = factory.create_agent_client(registration, ...)\n</code></pre></p> <p>Parameters:</p> <ul> <li> <code>registration</code>               (<code>AgentRegistration[AgentT]</code>)           \u2013            <p>Registration information returned by the exchange.</p> </li> <li> <code>request_handler</code>               (<code>RequestHandler[RequestT_co]</code>)           \u2013            <p>Agent request message handler.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AgentExchangeClient[AgentT, ExchangeTransportT]</code>           \u2013            <p>Agent exchange client.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BadEntityIdError</code>             \u2013            <p>If an agent with <code>registration.agent_id</code> is not already registered with the exchange.</p> </li> </ul> Source code in <code>academy/exchange/factory.py</code> <pre><code>async def create_agent_client(\n    self,\n    registration: AgentRegistration[AgentT],\n    request_handler: RequestHandler[RequestT_co],\n) -&gt; AgentExchangeClient[AgentT, ExchangeTransportT]:\n    \"\"\"Create a new agent exchange client.\n\n    An agent must be registered with the exchange before an exchange\n    client can be created. For example:\n    ```python\n    factory = ExchangeFactory(...)\n    user_client = factory.create_user_client()\n    registration = user_client.register_agent(...)\n    agent_client = factory.create_agent_client(registration, ...)\n    ```\n\n    Args:\n        registration: Registration information returned by the exchange.\n        request_handler: Agent request message handler.\n\n    Returns:\n        Agent exchange client.\n\n    Raises:\n        BadEntityIdError: If an agent with `registration.agent_id` is not\n            already registered with the exchange.\n    \"\"\"\n    agent_id: AgentId[AgentT] = registration.agent_id\n    transport = await self._create_transport(\n        mailbox_id=agent_id,\n        registration=registration,\n    )\n    assert transport.mailbox_id == agent_id\n    status = await transport.status(agent_id)\n    if status != MailboxStatus.ACTIVE:\n        await transport.close()\n        raise BadEntityIdError(agent_id)\n    return AgentExchangeClient(\n        agent_id,\n        transport,\n        request_handler=request_handler,\n    )\n</code></pre>"},{"location":"api/exchange/factory/#academy.exchange.factory.ExchangeFactory.create_user_client","title":"create_user_client  <code>async</code>","text":"<pre><code>create_user_client(\n    *, name: str | None = None, start_listener: bool = True\n) -&gt; UserExchangeClient[ExchangeTransportT]\n</code></pre> <p>Create a new user in the exchange and associated client.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Display name of the client on the exchange.</p> </li> <li> <code>start_listener</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Start a message listener thread.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>UserExchangeClient[ExchangeTransportT]</code>           \u2013            <p>User exchange client.</p> </li> </ul> Source code in <code>academy/exchange/factory.py</code> <pre><code>async def create_user_client(\n    self,\n    *,\n    name: str | None = None,\n    start_listener: bool = True,\n) -&gt; UserExchangeClient[ExchangeTransportT]:\n    \"\"\"Create a new user in the exchange and associated client.\n\n    Args:\n        name: Display name of the client on the exchange.\n        start_listener: Start a message listener thread.\n\n    Returns:\n        User exchange client.\n    \"\"\"\n    transport = await self._create_transport(mailbox_id=None, name=name)\n    user_id = transport.mailbox_id\n    assert isinstance(user_id, UserId)\n    return UserExchangeClient(\n        user_id,\n        transport,\n        start_listener=start_listener,\n    )\n</code></pre>"},{"location":"api/exchange/hybrid/","title":"academy.exchange.hybrid","text":"<code>academy/exchange/hybrid.py</code>"},{"location":"api/exchange/hybrid/#academy.exchange.hybrid.HybridAgentRegistration","title":"HybridAgentRegistration  <code>dataclass</code>","text":"<pre><code>HybridAgentRegistration(agent_id: AgentId[AgentT])\n</code></pre> <p>               Bases: <code>Generic[AgentT]</code></p> <p>Agent registration for hybrid exchanges.</p>"},{"location":"api/exchange/hybrid/#academy.exchange.hybrid.HybridAgentRegistration.agent_id","title":"agent_id  <code>instance-attribute</code>","text":"<pre><code>agent_id: AgentId[AgentT]\n</code></pre> <p>Unique identifier for the agent created by the exchange.</p>"},{"location":"api/exchange/hybrid/#academy.exchange.hybrid.HybridExchangeTransport","title":"HybridExchangeTransport","text":"<pre><code>HybridExchangeTransport(\n    mailbox_id: EntityId,\n    redis_client: Redis,\n    *,\n    redis_info: _RedisConnectionInfo,\n    namespace: str,\n    host: str,\n    port: int,\n    interface: str | None = None\n)\n</code></pre> <p>               Bases: <code>ExchangeTransportMixin</code>, <code>NoPickleMixin</code></p> <p>Hybrid exchange transport bound to a specific mailbox.</p> Source code in <code>academy/exchange/hybrid.py</code> <pre><code>def __init__(  # noqa: PLR0913\n    self,\n    mailbox_id: EntityId,\n    redis_client: redis.asyncio.Redis,\n    *,\n    redis_info: _RedisConnectionInfo,\n    namespace: str,\n    host: str,\n    port: int,\n    interface: str | None = None,\n) -&gt; None:\n    self._mailbox_id = mailbox_id\n    self._redis_client = redis_client\n    self._redis_info = redis_info\n    self._namespace = namespace\n    self._host = host\n    self._port = port\n    self._interface = interface\n\n    self._address_cache: dict[EntityId, str] = {}\n    if sys.version_info &gt;= (3, 13):  # pragma: &gt;=3.13 cover\n        self._messages: AsyncQueue[Message[Any]] = Queue()\n    else:  # pragma: &lt;3.13 cover\n        self._messages: AsyncQueue[Message[Any]] = Queue().async_q\n    self._socket_pool = SocketPool()\n    self._started = asyncio.Event()\n    self._shutdown = asyncio.Event()\n\n    self._server = SimpleSocketServer(\n        handler=self._direct_message_handler,\n        host=host,\n        port=port,\n    )\n    self._server_task = spawn_guarded_background_task(\n        self._run_direct_server(),\n        name=f'hybrid-transport-direct-server-{self.mailbox_id}',\n    )\n    self._redis_task = spawn_guarded_background_task(\n        self._run_redis_listener(),\n        name=f'hybrid-transport-redis-watcher-{self.mailbox_id}',\n    )\n</code></pre>"},{"location":"api/exchange/hybrid/#academy.exchange.hybrid.HybridExchangeTransport.new","title":"new  <code>async</code> <code>classmethod</code>","text":"<pre><code>new(\n    *,\n    namespace: str,\n    redis_info: _RedisConnectionInfo,\n    interface: str | None = None,\n    mailbox_id: EntityId | None = None,\n    name: str | None = None,\n    port: int | None = None\n) -&gt; Self\n</code></pre> <p>Instantiate a new transport.</p> <p>Parameters:</p> <ul> <li> <code>namespace</code>               (<code>str</code>)           \u2013            <p>Redis key namespace.</p> </li> <li> <code>redis_info</code>               (<code>_RedisConnectionInfo</code>)           \u2013            <p>Redis connection information.</p> </li> <li> <code>interface</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Network interface use for peer-to-peer communication. If <code>None</code>, the hostname of the local host is used.</p> </li> <li> <code>mailbox_id</code>               (<code>EntityId | None</code>, default:                   <code>None</code> )           \u2013            <p>Bind the transport to the specific mailbox. If <code>None</code>, a new user entity will be registered and the transport will be bound to that mailbox.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Display name of the registered entity if <code>mailbox_id</code> is <code>None</code>.</p> </li> <li> <code>port</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Port to listen for peer connection on.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>An instantiated transport bound to a specific mailbox.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ConnectionError</code>             \u2013            <p>If the Redis server is not reachable.</p> </li> </ul> Source code in <code>academy/exchange/hybrid.py</code> <pre><code>@classmethod\nasync def new(  # noqa: PLR0913\n    cls,\n    *,\n    namespace: str,\n    redis_info: _RedisConnectionInfo,\n    interface: str | None = None,\n    mailbox_id: EntityId | None = None,\n    name: str | None = None,\n    port: int | None = None,\n) -&gt; Self:\n    \"\"\"Instantiate a new transport.\n\n    Args:\n        namespace: Redis key namespace.\n        redis_info: Redis connection information.\n        interface: Network interface use for peer-to-peer communication.\n            If `None`, the hostname of the local host is used.\n        mailbox_id: Bind the transport to the specific mailbox. If `None`,\n            a new user entity will be registered and the transport will be\n            bound to that mailbox.\n        name: Display name of the registered entity if `mailbox_id` is\n            `None`.\n        port: Port to listen for peer connection on.\n\n    Returns:\n        An instantiated transport bound to a specific mailbox.\n\n    Raises:\n        redis.exceptions.ConnectionError: If the Redis server is not\n            reachable.\n    \"\"\"\n    host = (\n        address_by_interface(interface)\n        if interface is not None\n        else address_by_hostname()\n    )\n    port = port if port is not None else open_port()\n\n    client = redis.asyncio.Redis(\n        host=redis_info.hostname,\n        port=redis_info.port,\n        decode_responses=False,\n        **redis_info.kwargs,\n    )\n    # Ensure the redis server is reachable else fail early\n    p = client.ping()\n    assert isinstance(p, Awaitable), (\n        'ping should be awaitable from an async redis instance'\n    )\n    await p\n\n    if mailbox_id is None:\n        mailbox_id = UserId.new(name=name)\n        await client.set(\n            f'{namespace}:status:{uuid_to_base32(mailbox_id.uid)}',\n            _MailboxState.ACTIVE.value,\n        )\n        logger.info(\n            'Registered %s in exchange',\n            mailbox_id,\n            extra={'academy.mailbox_id': mailbox_id},\n        )\n\n    await client.set(\n        f'{namespace}:address:{uuid_to_base32(mailbox_id.uid)}',\n        f'{host}:{port}',\n    )\n\n    transport = cls(\n        mailbox_id,\n        client,\n        redis_info=redis_info,\n        namespace=namespace,\n        interface=interface,\n        host=host,\n        port=port,\n    )\n    # Wait for the direct message server to start\n    await asyncio.wait_for(transport._started.wait(), timeout=5)\n    return transport\n</code></pre>"},{"location":"api/exchange/hybrid/#academy.exchange.hybrid.HybridExchangeFactory","title":"HybridExchangeFactory","text":"<pre><code>HybridExchangeFactory(\n    redis_host: str,\n    redis_port: int,\n    *,\n    redis_kwargs: dict[str, Any] | None = None,\n    interface: str | None = None,\n    namespace: str | None = \"default\",\n    ports: Iterable[int] | None = None\n)\n</code></pre> <p>               Bases: <code>ExchangeFactory[HybridExchangeTransport]</code></p> <p>Hybrid exchange client factory.</p> <p>The hybrid exchange uses peer-to-peer communication via TCP and a central Redis server for mailbox state and queueing messages for offline entities.</p> <p>Parameters:</p> <ul> <li> <code>redis_host</code>               (<code>str</code>)           \u2013            <p>Redis server hostname.</p> </li> <li> <code>redis_port</code>               (<code>int</code>)           \u2013            <p>Redis server port.</p> </li> <li> <code>redis_kwargs</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Extra keyword arguments to pass to <code>redis.Redis()</code>.</p> </li> <li> <code>interface</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Network interface use for peer-to-peer communication. If <code>None</code>, the hostname of the local host is used.</p> </li> <li> <code>namespace</code>               (<code>str | None</code>, default:                   <code>'default'</code> )           \u2013            <p>Redis key namespace. If <code>None</code> a random key prefix is generated.</p> </li> <li> <code>ports</code>               (<code>Iterable[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>An iterable of ports to give each client a unique port from a user defined set. A StopIteration exception will be raised in <code>create_*_client()</code> methods if the number of clients in the process is greater than the length of the iterable.</p> </li> </ul> Source code in <code>academy/exchange/hybrid.py</code> <pre><code>def __init__(  # noqa: PLR0913\n    self,\n    redis_host: str,\n    redis_port: int,\n    *,\n    redis_kwargs: dict[str, Any] | None = None,\n    interface: str | None = None,\n    namespace: str | None = 'default',\n    ports: Iterable[int] | None = None,\n) -&gt; None:\n    self._namespace = (\n        namespace\n        if namespace is not None\n        else uuid_to_base32(uuid.uuid4())\n    )\n    self._interface = interface\n    self._redis_info = _RedisConnectionInfo(\n        redis_host,\n        redis_port,\n        redis_kwargs if redis_kwargs is not None else {},\n    )\n    self._ports = None if ports is None else iter(ports)\n</code></pre>"},{"location":"api/exchange/hybrid/#academy.exchange.hybrid.HybridExchangeFactory.create_agent_client","title":"create_agent_client  <code>async</code>","text":"<pre><code>create_agent_client(\n    registration: AgentRegistration[AgentT],\n    request_handler: RequestHandler[RequestT_co],\n) -&gt; AgentExchangeClient[AgentT, ExchangeTransportT]\n</code></pre> <p>Create a new agent exchange client.</p> <p>An agent must be registered with the exchange before an exchange client can be created. For example: <pre><code>factory = ExchangeFactory(...)\nuser_client = factory.create_user_client()\nregistration = user_client.register_agent(...)\nagent_client = factory.create_agent_client(registration, ...)\n</code></pre></p> <p>Parameters:</p> <ul> <li> <code>registration</code>               (<code>AgentRegistration[AgentT]</code>)           \u2013            <p>Registration information returned by the exchange.</p> </li> <li> <code>request_handler</code>               (<code>RequestHandler[RequestT_co]</code>)           \u2013            <p>Agent request message handler.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AgentExchangeClient[AgentT, ExchangeTransportT]</code>           \u2013            <p>Agent exchange client.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BadEntityIdError</code>             \u2013            <p>If an agent with <code>registration.agent_id</code> is not already registered with the exchange.</p> </li> </ul> Source code in <code>academy/exchange/factory.py</code> <pre><code>async def create_agent_client(\n    self,\n    registration: AgentRegistration[AgentT],\n    request_handler: RequestHandler[RequestT_co],\n) -&gt; AgentExchangeClient[AgentT, ExchangeTransportT]:\n    \"\"\"Create a new agent exchange client.\n\n    An agent must be registered with the exchange before an exchange\n    client can be created. For example:\n    ```python\n    factory = ExchangeFactory(...)\n    user_client = factory.create_user_client()\n    registration = user_client.register_agent(...)\n    agent_client = factory.create_agent_client(registration, ...)\n    ```\n\n    Args:\n        registration: Registration information returned by the exchange.\n        request_handler: Agent request message handler.\n\n    Returns:\n        Agent exchange client.\n\n    Raises:\n        BadEntityIdError: If an agent with `registration.agent_id` is not\n            already registered with the exchange.\n    \"\"\"\n    agent_id: AgentId[AgentT] = registration.agent_id\n    transport = await self._create_transport(\n        mailbox_id=agent_id,\n        registration=registration,\n    )\n    assert transport.mailbox_id == agent_id\n    status = await transport.status(agent_id)\n    if status != MailboxStatus.ACTIVE:\n        await transport.close()\n        raise BadEntityIdError(agent_id)\n    return AgentExchangeClient(\n        agent_id,\n        transport,\n        request_handler=request_handler,\n    )\n</code></pre>"},{"location":"api/exchange/hybrid/#academy.exchange.hybrid.HybridExchangeFactory.create_user_client","title":"create_user_client  <code>async</code>","text":"<pre><code>create_user_client(\n    *, name: str | None = None, start_listener: bool = True\n) -&gt; UserExchangeClient[ExchangeTransportT]\n</code></pre> <p>Create a new user in the exchange and associated client.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Display name of the client on the exchange.</p> </li> <li> <code>start_listener</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Start a message listener thread.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>UserExchangeClient[ExchangeTransportT]</code>           \u2013            <p>User exchange client.</p> </li> </ul> Source code in <code>academy/exchange/factory.py</code> <pre><code>async def create_user_client(\n    self,\n    *,\n    name: str | None = None,\n    start_listener: bool = True,\n) -&gt; UserExchangeClient[ExchangeTransportT]:\n    \"\"\"Create a new user in the exchange and associated client.\n\n    Args:\n        name: Display name of the client on the exchange.\n        start_listener: Start a message listener thread.\n\n    Returns:\n        User exchange client.\n    \"\"\"\n    transport = await self._create_transport(mailbox_id=None, name=name)\n    user_id = transport.mailbox_id\n    assert isinstance(user_id, UserId)\n    return UserExchangeClient(\n        user_id,\n        transport,\n        start_listener=start_listener,\n    )\n</code></pre>"},{"location":"api/exchange/hybrid/#academy.exchange.hybrid.base32_to_uuid","title":"base32_to_uuid","text":"<pre><code>base32_to_uuid(uid: str) -&gt; UUID\n</code></pre> <p>Parse a base32 string as a UUID.</p> Source code in <code>academy/exchange/hybrid.py</code> <pre><code>def base32_to_uuid(uid: str) -&gt; uuid.UUID:\n    \"\"\"Parse a base32 string as a UUID.\"\"\"\n    padding = '=' * ((8 - len(uid) % 8) % 8)\n    padded = uid + padding\n    uid_bytes = base64.b32decode(padded)\n    return uuid.UUID(bytes=uid_bytes)\n</code></pre>"},{"location":"api/exchange/hybrid/#academy.exchange.hybrid.uuid_to_base32","title":"uuid_to_base32","text":"<pre><code>uuid_to_base32(uid: UUID) -&gt; str\n</code></pre> <p>Encode a UUID as a trimmed base32 string.</p> Source code in <code>academy/exchange/hybrid.py</code> <pre><code>def uuid_to_base32(uid: uuid.UUID) -&gt; str:\n    \"\"\"Encode a UUID as a trimmed base32 string.\"\"\"\n    uid_bytes = uid.bytes\n    base32_bytes = base64.b32encode(uid_bytes).rstrip(b'=')\n    return base32_bytes.decode('utf-8')\n</code></pre>"},{"location":"api/exchange/local/","title":"academy.exchange.local","text":"<code>academy/exchange/local.py</code>"},{"location":"api/exchange/local/#academy.exchange.local.LocalAgentRegistration","title":"LocalAgentRegistration  <code>dataclass</code>","text":"<pre><code>LocalAgentRegistration(agent_id: AgentId[AgentT])\n</code></pre> <p>               Bases: <code>Generic[AgentT]</code></p> <p>Agent registration for thread exchanges.</p>"},{"location":"api/exchange/local/#academy.exchange.local.LocalAgentRegistration.agent_id","title":"agent_id  <code>instance-attribute</code>","text":"<pre><code>agent_id: AgentId[AgentT]\n</code></pre> <p>Unique identifier for the agent created by the exchange.</p>"},{"location":"api/exchange/local/#academy.exchange.local.LocalExchangeTransport","title":"LocalExchangeTransport","text":"<pre><code>LocalExchangeTransport(\n    mailbox_id: EntityId, state: _LocalExchangeState\n)\n</code></pre> <p>               Bases: <code>ExchangeTransportMixin</code>, <code>NoPickleMixin</code></p> <p>Local exchange client bound to a specific mailbox.</p> Source code in <code>academy/exchange/local.py</code> <pre><code>def __init__(\n    self,\n    mailbox_id: EntityId,\n    state: _LocalExchangeState,\n) -&gt; None:\n    self._mailbox_id = mailbox_id\n    self._state = state\n</code></pre>"},{"location":"api/exchange/local/#academy.exchange.local.LocalExchangeTransport.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(\n    mailbox_id: EntityId | None = None,\n    *,\n    name: str | None = None,\n    state: _LocalExchangeState\n) -&gt; Self\n</code></pre> <p>Instantiate a new transport.</p> <p>Parameters:</p> <ul> <li> <code>mailbox_id</code>               (<code>EntityId | None</code>, default:                   <code>None</code> )           \u2013            <p>Bind the transport to the specific mailbox. If <code>None</code>, a new user entity will be registered and the transport will be bound to that mailbox.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Display name of the redistered entity if <code>mailbox_id</code> is <code>None</code>.</p> </li> <li> <code>state</code>               (<code>_LocalExchangeState</code>)           \u2013            <p>Shared state among exchange clients.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>An instantiated transport bound to a specific mailbox.</p> </li> </ul> Source code in <code>academy/exchange/local.py</code> <pre><code>@classmethod\ndef new(\n    cls,\n    mailbox_id: EntityId | None = None,\n    *,\n    name: str | None = None,\n    state: _LocalExchangeState,\n) -&gt; Self:\n    \"\"\"Instantiate a new transport.\n\n    Args:\n        mailbox_id: Bind the transport to the specific mailbox. If `None`,\n            a new user entity will be registered and the transport will be\n            bound to that mailbox.\n        name: Display name of the redistered entity if `mailbox_id` is\n            `None`.\n        state: Shared state among exchange clients.\n\n    Returns:\n        An instantiated transport bound to a specific mailbox.\n    \"\"\"\n    if mailbox_id is None:\n        mailbox_id = UserId.new(name=name)\n        state.queues[mailbox_id] = Queue().async_q\n        state.locks[mailbox_id] = Lock()\n        logger.info(\n            'Registered %s in exchange',\n            mailbox_id,\n            extra={'academy.mailbox_id': mailbox_id},\n        )\n    return cls(mailbox_id, state)\n</code></pre>"},{"location":"api/exchange/local/#academy.exchange.local.LocalExchangeFactory","title":"LocalExchangeFactory","text":"<pre><code>LocalExchangeFactory(\n    *, _state: _LocalExchangeState | None = None\n)\n</code></pre> <p>               Bases: <code>ExchangeFactory[LocalExchangeTransport]</code>, <code>NoPickleMixin</code></p> <p>Local exchange client factory.</p> <p>A thread exchange can be used to pass messages between agents running in separate threads of a single process.</p> Source code in <code>academy/exchange/local.py</code> <pre><code>def __init__(\n    self,\n    *,\n    _state: _LocalExchangeState | None = None,\n):\n    self._state = _LocalExchangeState() if _state is None else _state\n</code></pre>"},{"location":"api/exchange/local/#academy.exchange.local.LocalExchangeFactory.create_agent_client","title":"create_agent_client  <code>async</code>","text":"<pre><code>create_agent_client(\n    registration: AgentRegistration[AgentT],\n    request_handler: RequestHandler[RequestT_co],\n) -&gt; AgentExchangeClient[AgentT, ExchangeTransportT]\n</code></pre> <p>Create a new agent exchange client.</p> <p>An agent must be registered with the exchange before an exchange client can be created. For example: <pre><code>factory = ExchangeFactory(...)\nuser_client = factory.create_user_client()\nregistration = user_client.register_agent(...)\nagent_client = factory.create_agent_client(registration, ...)\n</code></pre></p> <p>Parameters:</p> <ul> <li> <code>registration</code>               (<code>AgentRegistration[AgentT]</code>)           \u2013            <p>Registration information returned by the exchange.</p> </li> <li> <code>request_handler</code>               (<code>RequestHandler[RequestT_co]</code>)           \u2013            <p>Agent request message handler.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AgentExchangeClient[AgentT, ExchangeTransportT]</code>           \u2013            <p>Agent exchange client.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BadEntityIdError</code>             \u2013            <p>If an agent with <code>registration.agent_id</code> is not already registered with the exchange.</p> </li> </ul> Source code in <code>academy/exchange/factory.py</code> <pre><code>async def create_agent_client(\n    self,\n    registration: AgentRegistration[AgentT],\n    request_handler: RequestHandler[RequestT_co],\n) -&gt; AgentExchangeClient[AgentT, ExchangeTransportT]:\n    \"\"\"Create a new agent exchange client.\n\n    An agent must be registered with the exchange before an exchange\n    client can be created. For example:\n    ```python\n    factory = ExchangeFactory(...)\n    user_client = factory.create_user_client()\n    registration = user_client.register_agent(...)\n    agent_client = factory.create_agent_client(registration, ...)\n    ```\n\n    Args:\n        registration: Registration information returned by the exchange.\n        request_handler: Agent request message handler.\n\n    Returns:\n        Agent exchange client.\n\n    Raises:\n        BadEntityIdError: If an agent with `registration.agent_id` is not\n            already registered with the exchange.\n    \"\"\"\n    agent_id: AgentId[AgentT] = registration.agent_id\n    transport = await self._create_transport(\n        mailbox_id=agent_id,\n        registration=registration,\n    )\n    assert transport.mailbox_id == agent_id\n    status = await transport.status(agent_id)\n    if status != MailboxStatus.ACTIVE:\n        await transport.close()\n        raise BadEntityIdError(agent_id)\n    return AgentExchangeClient(\n        agent_id,\n        transport,\n        request_handler=request_handler,\n    )\n</code></pre>"},{"location":"api/exchange/local/#academy.exchange.local.LocalExchangeFactory.create_user_client","title":"create_user_client  <code>async</code>","text":"<pre><code>create_user_client(\n    *, name: str | None = None, start_listener: bool = True\n) -&gt; UserExchangeClient[ExchangeTransportT]\n</code></pre> <p>Create a new user in the exchange and associated client.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Display name of the client on the exchange.</p> </li> <li> <code>start_listener</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Start a message listener thread.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>UserExchangeClient[ExchangeTransportT]</code>           \u2013            <p>User exchange client.</p> </li> </ul> Source code in <code>academy/exchange/factory.py</code> <pre><code>async def create_user_client(\n    self,\n    *,\n    name: str | None = None,\n    start_listener: bool = True,\n) -&gt; UserExchangeClient[ExchangeTransportT]:\n    \"\"\"Create a new user in the exchange and associated client.\n\n    Args:\n        name: Display name of the client on the exchange.\n        start_listener: Start a message listener thread.\n\n    Returns:\n        User exchange client.\n    \"\"\"\n    transport = await self._create_transport(mailbox_id=None, name=name)\n    user_id = transport.mailbox_id\n    assert isinstance(user_id, UserId)\n    return UserExchangeClient(\n        user_id,\n        transport,\n        start_listener=start_listener,\n    )\n</code></pre>"},{"location":"api/exchange/proxystore/","title":"academy.exchange.proxystore","text":"<code>academy/exchange/proxystore.py</code>"},{"location":"api/exchange/proxystore/#academy.exchange.proxystore.ProxyStoreExchangeTransport","title":"ProxyStoreExchangeTransport","text":"<pre><code>ProxyStoreExchangeTransport(\n    transport: ExchangeTransportT,\n    store: Store[Any],\n    should_proxy: Callable[[Any], bool],\n    *,\n    resolve_async: bool = False\n)\n</code></pre> <p>               Bases: <code>ExchangeTransportMixin</code>, <code>NoPickleMixin</code>, <code>Generic[ExchangeTransportT]</code></p> <p>ProxyStore exchange client bound to a specific mailbox.</p> Source code in <code>academy/exchange/proxystore.py</code> <pre><code>def __init__(\n    self,\n    transport: ExchangeTransportT,\n    store: Store[Any],\n    should_proxy: Callable[[Any], bool],\n    *,\n    resolve_async: bool = False,\n) -&gt; None:\n    _assert_proxystore_available()\n    self.transport = transport\n    self.store = store\n    self.should_proxy = should_proxy\n    self.resolve_async = resolve_async\n    register_store(store, exist_ok=True)\n</code></pre>"},{"location":"api/exchange/proxystore/#academy.exchange.proxystore.ProxyStoreExchangeFactory","title":"ProxyStoreExchangeFactory","text":"<pre><code>ProxyStoreExchangeFactory(\n    base: ExchangeFactory[ExchangeTransportT],\n    store: Store[Any] | None,\n    should_proxy: Callable[[Any], bool],\n    *,\n    resolve_async: bool = False\n)\n</code></pre> <p>               Bases: <code>ExchangeFactory[ProxyStoreExchangeTransport[ExchangeTransportT]]</code></p> <p>ProxStore exchange client factory.</p> <p>A ProxyStore exchange is used to wrap an underlying exchange so large objects may be passed by reference.</p> <p>Parameters:</p> <ul> <li> <code>base</code>               (<code>ExchangeFactory[ExchangeTransportT]</code>)           \u2013            <p>Base exchange factory.</p> </li> <li> <code>store</code>               (<code>Store[Any] | None</code>)           \u2013            <p>Store to use for proxying data.</p> </li> <li> <code>should_proxy</code>               (<code>Callable[[Any], bool]</code>)           \u2013            <p>A callable that returns <code>True</code> if an object should be proxied. This is applied to every positional and keyword argument and result value.</p> </li> <li> <code>resolve_async</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Resolve proxies asynchronously when received.</p> </li> </ul> Source code in <code>academy/exchange/proxystore.py</code> <pre><code>def __init__(\n    self,\n    base: ExchangeFactory[ExchangeTransportT],\n    store: Store[Any] | None,\n    should_proxy: Callable[[Any], bool],\n    *,\n    resolve_async: bool = False,\n) -&gt; None:\n    _assert_proxystore_available()\n    self.base = base\n    self.store = store\n    self.should_proxy = should_proxy\n    self.resolve_async = resolve_async\n</code></pre>"},{"location":"api/exchange/proxystore/#academy.exchange.proxystore.ProxyStoreExchangeFactory.create_agent_client","title":"create_agent_client  <code>async</code>","text":"<pre><code>create_agent_client(\n    registration: AgentRegistration[AgentT],\n    request_handler: RequestHandler[RequestT_co],\n) -&gt; AgentExchangeClient[AgentT, ExchangeTransportT]\n</code></pre> <p>Create a new agent exchange client.</p> <p>An agent must be registered with the exchange before an exchange client can be created. For example: <pre><code>factory = ExchangeFactory(...)\nuser_client = factory.create_user_client()\nregistration = user_client.register_agent(...)\nagent_client = factory.create_agent_client(registration, ...)\n</code></pre></p> <p>Parameters:</p> <ul> <li> <code>registration</code>               (<code>AgentRegistration[AgentT]</code>)           \u2013            <p>Registration information returned by the exchange.</p> </li> <li> <code>request_handler</code>               (<code>RequestHandler[RequestT_co]</code>)           \u2013            <p>Agent request message handler.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AgentExchangeClient[AgentT, ExchangeTransportT]</code>           \u2013            <p>Agent exchange client.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BadEntityIdError</code>             \u2013            <p>If an agent with <code>registration.agent_id</code> is not already registered with the exchange.</p> </li> </ul> Source code in <code>academy/exchange/factory.py</code> <pre><code>async def create_agent_client(\n    self,\n    registration: AgentRegistration[AgentT],\n    request_handler: RequestHandler[RequestT_co],\n) -&gt; AgentExchangeClient[AgentT, ExchangeTransportT]:\n    \"\"\"Create a new agent exchange client.\n\n    An agent must be registered with the exchange before an exchange\n    client can be created. For example:\n    ```python\n    factory = ExchangeFactory(...)\n    user_client = factory.create_user_client()\n    registration = user_client.register_agent(...)\n    agent_client = factory.create_agent_client(registration, ...)\n    ```\n\n    Args:\n        registration: Registration information returned by the exchange.\n        request_handler: Agent request message handler.\n\n    Returns:\n        Agent exchange client.\n\n    Raises:\n        BadEntityIdError: If an agent with `registration.agent_id` is not\n            already registered with the exchange.\n    \"\"\"\n    agent_id: AgentId[AgentT] = registration.agent_id\n    transport = await self._create_transport(\n        mailbox_id=agent_id,\n        registration=registration,\n    )\n    assert transport.mailbox_id == agent_id\n    status = await transport.status(agent_id)\n    if status != MailboxStatus.ACTIVE:\n        await transport.close()\n        raise BadEntityIdError(agent_id)\n    return AgentExchangeClient(\n        agent_id,\n        transport,\n        request_handler=request_handler,\n    )\n</code></pre>"},{"location":"api/exchange/proxystore/#academy.exchange.proxystore.ProxyStoreExchangeFactory.create_user_client","title":"create_user_client  <code>async</code>","text":"<pre><code>create_user_client(\n    *, name: str | None = None, start_listener: bool = True\n) -&gt; UserExchangeClient[ExchangeTransportT]\n</code></pre> <p>Create a new user in the exchange and associated client.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Display name of the client on the exchange.</p> </li> <li> <code>start_listener</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Start a message listener thread.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>UserExchangeClient[ExchangeTransportT]</code>           \u2013            <p>User exchange client.</p> </li> </ul> Source code in <code>academy/exchange/factory.py</code> <pre><code>async def create_user_client(\n    self,\n    *,\n    name: str | None = None,\n    start_listener: bool = True,\n) -&gt; UserExchangeClient[ExchangeTransportT]:\n    \"\"\"Create a new user in the exchange and associated client.\n\n    Args:\n        name: Display name of the client on the exchange.\n        start_listener: Start a message listener thread.\n\n    Returns:\n        User exchange client.\n    \"\"\"\n    transport = await self._create_transport(mailbox_id=None, name=name)\n    user_id = transport.mailbox_id\n    assert isinstance(user_id, UserId)\n    return UserExchangeClient(\n        user_id,\n        transport,\n        start_listener=start_listener,\n    )\n</code></pre>"},{"location":"api/exchange/redis/","title":"academy.exchange.redis","text":"<code>academy/exchange/redis.py</code>"},{"location":"api/exchange/redis/#academy.exchange.redis.RedisAgentRegistration","title":"RedisAgentRegistration  <code>dataclass</code>","text":"<pre><code>RedisAgentRegistration(agent_id: AgentId[AgentT])\n</code></pre> <p>               Bases: <code>Generic[AgentT]</code></p> <p>Agent registration for redis exchanges.</p>"},{"location":"api/exchange/redis/#academy.exchange.redis.RedisAgentRegistration.agent_id","title":"agent_id  <code>instance-attribute</code>","text":"<pre><code>agent_id: AgentId[AgentT]\n</code></pre> <p>Unique identifier for the agent created by the exchange.</p>"},{"location":"api/exchange/redis/#academy.exchange.redis.RedisExchangeTransport","title":"RedisExchangeTransport","text":"<pre><code>RedisExchangeTransport(\n    mailbox_id: EntityId,\n    redis_client: Redis,\n    *,\n    redis_info: _RedisConnectionInfo\n)\n</code></pre> <p>               Bases: <code>ExchangeTransportMixin</code>, <code>NoPickleMixin</code></p> <p>Redis exchange transport bound to a specific mailbox.</p> Source code in <code>academy/exchange/redis.py</code> <pre><code>def __init__(\n    self,\n    mailbox_id: EntityId,\n    redis_client: redis.asyncio.Redis,\n    *,\n    redis_info: _RedisConnectionInfo,\n) -&gt; None:\n    self._mailbox_id = mailbox_id\n    self._client = redis_client\n    self._redis_info = redis_info\n</code></pre>"},{"location":"api/exchange/redis/#academy.exchange.redis.RedisExchangeTransport.new","title":"new  <code>async</code> <code>classmethod</code>","text":"<pre><code>new(\n    *,\n    mailbox_id: EntityId | None = None,\n    name: str | None = None,\n    redis_info: _RedisConnectionInfo\n) -&gt; Self\n</code></pre> <p>Instantiate a new transport.</p> <p>Parameters:</p> <ul> <li> <code>mailbox_id</code>               (<code>EntityId | None</code>, default:                   <code>None</code> )           \u2013            <p>Bind the transport to the specific mailbox. If <code>None</code>, a new user entity will be registered and the transport will be bound to that mailbox.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Display name of the redistered entity if <code>mailbox_id</code> is <code>None</code>.</p> </li> <li> <code>redis_info</code>               (<code>_RedisConnectionInfo</code>)           \u2013            <p>Redis connection information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>An instantiated transport bound to a specific mailbox.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ConnectionError</code>             \u2013            <p>If the Redis server is not reachable.</p> </li> </ul> Source code in <code>academy/exchange/redis.py</code> <pre><code>@classmethod\nasync def new(\n    cls,\n    *,\n    mailbox_id: EntityId | None = None,\n    name: str | None = None,\n    redis_info: _RedisConnectionInfo,\n) -&gt; Self:\n    \"\"\"Instantiate a new transport.\n\n    Args:\n        mailbox_id: Bind the transport to the specific mailbox. If `None`,\n            a new user entity will be registered and the transport will be\n            bound to that mailbox.\n        name: Display name of the redistered entity if `mailbox_id` is\n            `None`.\n        redis_info: Redis connection information.\n\n    Returns:\n        An instantiated transport bound to a specific mailbox.\n\n    Raises:\n        redis.exceptions.ConnectionError: If the Redis server is not\n            reachable.\n    \"\"\"\n    client = redis.asyncio.Redis(\n        host=redis_info.hostname,\n        port=redis_info.port,\n        decode_responses=False,\n        **redis_info.kwargs,\n    )\n    # Ensure the redis server is reachable else fail early\n    p = client.ping()\n    assert isinstance(p, Awaitable), (\n        'ping should be awaitable from an async redis instance'\n    )\n    await p\n\n    if mailbox_id is None:\n        mailbox_id = UserId.new(name=name)\n        await client.set(\n            f'active:{mailbox_id.uid}',\n            _MailboxState.ACTIVE.value,\n        )\n        logger.info(\n            'Registered %s in exchange',\n            mailbox_id,\n            extra={'academy.mailbox_id': mailbox_id},\n        )\n    return cls(mailbox_id, client, redis_info=redis_info)\n</code></pre>"},{"location":"api/exchange/redis/#academy.exchange.redis.RedisExchangeFactory","title":"RedisExchangeFactory","text":"<pre><code>RedisExchangeFactory(\n    hostname: str, port: int, **redis_kwargs: Any\n)\n</code></pre> <p>               Bases: <code>ExchangeFactory[RedisExchangeTransport]</code></p> <p>Redis exchange client factory.</p> <p>Parameters:</p> <ul> <li> <code>hostname</code>               (<code>str</code>)           \u2013            <p>Redis server hostname.</p> </li> <li> <code>port</code>               (<code>int</code>)           \u2013            <p>Redis server port.</p> </li> <li> <code>redis_kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Extra keyword arguments to pass to <code>redis.Redis()</code>.</p> </li> </ul> Source code in <code>academy/exchange/redis.py</code> <pre><code>def __init__(\n    self,\n    hostname: str,\n    port: int,\n    **redis_kwargs: Any,\n) -&gt; None:\n    self.redis_info = _RedisConnectionInfo(hostname, port, redis_kwargs)\n</code></pre>"},{"location":"api/exchange/redis/#academy.exchange.redis.RedisExchangeFactory.create_agent_client","title":"create_agent_client  <code>async</code>","text":"<pre><code>create_agent_client(\n    registration: AgentRegistration[AgentT],\n    request_handler: RequestHandler[RequestT_co],\n) -&gt; AgentExchangeClient[AgentT, ExchangeTransportT]\n</code></pre> <p>Create a new agent exchange client.</p> <p>An agent must be registered with the exchange before an exchange client can be created. For example: <pre><code>factory = ExchangeFactory(...)\nuser_client = factory.create_user_client()\nregistration = user_client.register_agent(...)\nagent_client = factory.create_agent_client(registration, ...)\n</code></pre></p> <p>Parameters:</p> <ul> <li> <code>registration</code>               (<code>AgentRegistration[AgentT]</code>)           \u2013            <p>Registration information returned by the exchange.</p> </li> <li> <code>request_handler</code>               (<code>RequestHandler[RequestT_co]</code>)           \u2013            <p>Agent request message handler.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AgentExchangeClient[AgentT, ExchangeTransportT]</code>           \u2013            <p>Agent exchange client.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BadEntityIdError</code>             \u2013            <p>If an agent with <code>registration.agent_id</code> is not already registered with the exchange.</p> </li> </ul> Source code in <code>academy/exchange/factory.py</code> <pre><code>async def create_agent_client(\n    self,\n    registration: AgentRegistration[AgentT],\n    request_handler: RequestHandler[RequestT_co],\n) -&gt; AgentExchangeClient[AgentT, ExchangeTransportT]:\n    \"\"\"Create a new agent exchange client.\n\n    An agent must be registered with the exchange before an exchange\n    client can be created. For example:\n    ```python\n    factory = ExchangeFactory(...)\n    user_client = factory.create_user_client()\n    registration = user_client.register_agent(...)\n    agent_client = factory.create_agent_client(registration, ...)\n    ```\n\n    Args:\n        registration: Registration information returned by the exchange.\n        request_handler: Agent request message handler.\n\n    Returns:\n        Agent exchange client.\n\n    Raises:\n        BadEntityIdError: If an agent with `registration.agent_id` is not\n            already registered with the exchange.\n    \"\"\"\n    agent_id: AgentId[AgentT] = registration.agent_id\n    transport = await self._create_transport(\n        mailbox_id=agent_id,\n        registration=registration,\n    )\n    assert transport.mailbox_id == agent_id\n    status = await transport.status(agent_id)\n    if status != MailboxStatus.ACTIVE:\n        await transport.close()\n        raise BadEntityIdError(agent_id)\n    return AgentExchangeClient(\n        agent_id,\n        transport,\n        request_handler=request_handler,\n    )\n</code></pre>"},{"location":"api/exchange/redis/#academy.exchange.redis.RedisExchangeFactory.create_user_client","title":"create_user_client  <code>async</code>","text":"<pre><code>create_user_client(\n    *, name: str | None = None, start_listener: bool = True\n) -&gt; UserExchangeClient[ExchangeTransportT]\n</code></pre> <p>Create a new user in the exchange and associated client.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Display name of the client on the exchange.</p> </li> <li> <code>start_listener</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Start a message listener thread.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>UserExchangeClient[ExchangeTransportT]</code>           \u2013            <p>User exchange client.</p> </li> </ul> Source code in <code>academy/exchange/factory.py</code> <pre><code>async def create_user_client(\n    self,\n    *,\n    name: str | None = None,\n    start_listener: bool = True,\n) -&gt; UserExchangeClient[ExchangeTransportT]:\n    \"\"\"Create a new user in the exchange and associated client.\n\n    Args:\n        name: Display name of the client on the exchange.\n        start_listener: Start a message listener thread.\n\n    Returns:\n        User exchange client.\n    \"\"\"\n    transport = await self._create_transport(mailbox_id=None, name=name)\n    user_id = transport.mailbox_id\n    assert isinstance(user_id, UserId)\n    return UserExchangeClient(\n        user_id,\n        transport,\n        start_listener=start_listener,\n    )\n</code></pre>"},{"location":"api/exchange/transport/","title":"academy.exchange.transport","text":"<code>academy/exchange/transport.py</code>"},{"location":"api/exchange/transport/#academy.exchange.transport.AgentRegistrationT","title":"AgentRegistrationT  <code>module-attribute</code>","text":"<pre><code>AgentRegistrationT = TypeVar(\n    \"AgentRegistrationT\", bound=AgentRegistration[Any]\n)\n</code></pre> <p>Type variable bound <code>AgentRegistration</code>.</p>"},{"location":"api/exchange/transport/#academy.exchange.transport.ExchangeTransportT","title":"ExchangeTransportT  <code>module-attribute</code>","text":"<pre><code>ExchangeTransportT = TypeVar(\n    \"ExchangeTransportT\", bound=ExchangeTransport[Any]\n)\n</code></pre> <p>Type variable bound <code>ExchangeTransport</code>.</p>"},{"location":"api/exchange/transport/#academy.exchange.transport.MailboxStatus","title":"MailboxStatus","text":"<p>               Bases: <code>Enum</code></p> <p>Exchange mailbox status.</p>"},{"location":"api/exchange/transport/#academy.exchange.transport.MailboxStatus.MISSING","title":"MISSING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MISSING = 'MISSING'\n</code></pre> <p>Mailbox does not exist.</p>"},{"location":"api/exchange/transport/#academy.exchange.transport.MailboxStatus.ACTIVE","title":"ACTIVE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ACTIVE = 'ACTIVE'\n</code></pre> <p>Mailbox exists and is accepting messages.</p>"},{"location":"api/exchange/transport/#academy.exchange.transport.MailboxStatus.TERMINATED","title":"TERMINATED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TERMINATED = 'TERMINATED'\n</code></pre> <p>Mailbox was terminated and no longer accepts messages.</p>"},{"location":"api/exchange/transport/#academy.exchange.transport.AgentRegistration","title":"AgentRegistration","text":"<p>               Bases: <code>Protocol[AgentT]</code></p> <p>Agent exchange registration information.</p> <p>Attributes:</p> <ul> <li> <code>agent_id</code>               (<code>AgentId[AgentT]</code>)           \u2013            <p>Unique agent identifier returned by the exchange.</p> </li> </ul>"},{"location":"api/exchange/transport/#academy.exchange.transport.ExchangeTransport","title":"ExchangeTransport","text":"<p>               Bases: <code>Protocol[AgentRegistrationT_co]</code></p> <p>Low-level exchange communicator.</p> <p>A message exchange hosts mailboxes for each entity (i.e., agent or user) in a multi-agent system. This transport protocol defines mechanisms for entity management (e.g., registration, discovery, status, termination) and for sending/receiving messages from a mailbox. As such, each transport instance is \"bound\" to a specific mailbox in the exchange.</p> Warning <p>A specific exchange transport should not be replicated because multiple client instances receiving from the same mailbox produces undefined agent.</p>"},{"location":"api/exchange/transport/#academy.exchange.transport.ExchangeTransport.mailbox_id","title":"mailbox_id  <code>property</code>","text":"<pre><code>mailbox_id: EntityId\n</code></pre> <p>ID of the mailbox this client is bound to.</p>"},{"location":"api/exchange/transport/#academy.exchange.transport.ExchangeTransport.close","title":"close  <code>async</code>","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the exchange client.</p> Note <p>This does not alter the state of the mailbox this client is bound to. I.e., the mailbox will not be terminated.</p> Source code in <code>academy/exchange/transport.py</code> <pre><code>async def close(self) -&gt; None:\n    \"\"\"Close the exchange client.\n\n    Note:\n        This does not alter the state of the mailbox this client is bound\n        to. I.e., the mailbox will not be terminated.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/exchange/transport/#academy.exchange.transport.ExchangeTransport.discover","title":"discover  <code>async</code>","text":"<pre><code>discover(\n    agent: type[Agent], *, allow_subclasses: bool = True\n) -&gt; tuple[AgentId[Any], ...]\n</code></pre> <p>Discover peer agents with a given agent.</p> Warning <p>Implementations of this method are often O(n) and scan the types of all agents registered to the exchange.</p> <p>Parameters:</p> <ul> <li> <code>agent</code>               (<code>type[Agent]</code>)           \u2013            <p>Agent type of interest.</p> </li> <li> <code>allow_subclasses</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Return agents implementing subclasses of the agent.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[AgentId[Any], ...]</code>           \u2013            <p>Tuple of agent IDs implementing the agent.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ExchangeError</code>             \u2013            <p>Error returned by the exchange.</p> </li> </ul> Source code in <code>academy/exchange/transport.py</code> <pre><code>async def discover(\n    self,\n    agent: type[Agent],\n    *,\n    allow_subclasses: bool = True,\n) -&gt; tuple[AgentId[Any], ...]:\n    \"\"\"Discover peer agents with a given agent.\n\n    Warning:\n        Implementations of this method are often O(n) and scan the types\n        of all agents registered to the exchange.\n\n    Args:\n        agent: Agent type of interest.\n        allow_subclasses: Return agents implementing subclasses of the\n            agent.\n\n    Returns:\n        Tuple of agent IDs implementing the agent.\n\n    Raises:\n        ExchangeError: Error returned by the exchange.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/exchange/transport/#academy.exchange.transport.ExchangeTransport.factory","title":"factory","text":"<pre><code>factory() -&gt; ExchangeFactory[Self]\n</code></pre> <p>Get an exchange factory.</p> Source code in <code>academy/exchange/transport.py</code> <pre><code>def factory(self) -&gt; ExchangeFactory[Self]:\n    \"\"\"Get an exchange factory.\"\"\"\n    ...\n</code></pre>"},{"location":"api/exchange/transport/#academy.exchange.transport.ExchangeTransport.recv","title":"recv  <code>async</code>","text":"<pre><code>recv(timeout: float | None = None) -&gt; Message[Any]\n</code></pre> <p>Receive the next message sent to the mailbox.</p> <p>This blocks until the next message is received, there is a timeout, or the mailbox is terminated.</p> <p>Parameters:</p> <ul> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional timeout in seconds to wait for the next message. If <code>None</code>, the default, block forever until the next message or the mailbox is closed.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>MailboxTerminatedError</code>             \u2013            <p>If the mailbox was closed.</p> </li> <li> <code>ExchangeError</code>             \u2013            <p>Error returned by the exchange.</p> </li> <li> <code>TimeoutError</code>             \u2013            <p>If a <code>timeout</code> was specified and exceeded.</p> </li> </ul> Source code in <code>academy/exchange/transport.py</code> <pre><code>async def recv(self, timeout: float | None = None) -&gt; Message[Any]:\n    \"\"\"Receive the next message sent to the mailbox.\n\n    This blocks until the next message is received, there is a timeout, or\n    the mailbox is terminated.\n\n    Args:\n        timeout: Optional timeout in seconds to wait for the next\n            message. If `None`, the default, block forever until the\n            next message or the mailbox is closed.\n\n    Raises:\n        MailboxTerminatedError: If the mailbox was closed.\n        ExchangeError: Error returned by the exchange.\n        TimeoutError: If a `timeout` was specified and exceeded.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/exchange/transport/#academy.exchange.transport.ExchangeTransport.register_agent","title":"register_agent  <code>async</code>","text":"<pre><code>register_agent(\n    agent: type[AgentT], *, name: str | None = None\n) -&gt; AgentRegistrationT_co\n</code></pre> <p>Register a new agent and associated mailbox with the exchange.</p> <p>Parameters:</p> <ul> <li> <code>agent</code>               (<code>type[AgentT]</code>)           \u2013            <p>Agent type of the agent.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional display name for the agent.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AgentRegistrationT_co</code>           \u2013            <p>Agent registration info.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ExchangeError</code>             \u2013            <p>Error returned by the exchange.</p> </li> </ul> Source code in <code>academy/exchange/transport.py</code> <pre><code>async def register_agent(\n    self,\n    agent: type[AgentT],\n    *,\n    name: str | None = None,\n) -&gt; AgentRegistrationT_co:\n    \"\"\"Register a new agent and associated mailbox with the exchange.\n\n    Args:\n        agent: Agent type of the agent.\n        name: Optional display name for the agent.\n\n    Returns:\n        Agent registration info.\n\n    Raises:\n        ExchangeError: Error returned by the exchange.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/exchange/transport/#academy.exchange.transport.ExchangeTransport.send","title":"send  <code>async</code>","text":"<pre><code>send(message: Message[Any]) -&gt; None\n</code></pre> <p>Send a message to a mailbox.</p> <p>Parameters:</p> <ul> <li> <code>message</code>               (<code>Message[Any]</code>)           \u2013            <p>Message to send.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BadEntityIdError</code>             \u2013            <p>If a mailbox for <code>message.dest</code> does not exist.</p> </li> <li> <code>MailboxTerminatedError</code>             \u2013            <p>If the mailbox was closed.</p> </li> <li> <code>ExchangeError</code>             \u2013            <p>Error returned by the exchange.</p> </li> </ul> Source code in <code>academy/exchange/transport.py</code> <pre><code>async def send(self, message: Message[Any]) -&gt; None:\n    \"\"\"Send a message to a mailbox.\n\n    Args:\n        message: Message to send.\n\n    Raises:\n        BadEntityIdError: If a mailbox for `message.dest` does not exist.\n        MailboxTerminatedError: If the mailbox was closed.\n        ExchangeError: Error returned by the exchange.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/exchange/transport/#academy.exchange.transport.ExchangeTransport.status","title":"status  <code>async</code>","text":"<pre><code>status(uid: EntityId) -&gt; MailboxStatus\n</code></pre> <p>Check the status of a mailbox in the exchange.</p> <p>Parameters:</p> <ul> <li> <code>uid</code>               (<code>EntityId</code>)           \u2013            <p>Entity identifier of the mailbox to check.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ExchangeError</code>             \u2013            <p>Error returned by the exchange.</p> </li> </ul> Source code in <code>academy/exchange/transport.py</code> <pre><code>async def status(self, uid: EntityId) -&gt; MailboxStatus:\n    \"\"\"Check the status of a mailbox in the exchange.\n\n    Args:\n        uid: Entity identifier of the mailbox to check.\n\n    Raises:\n        ExchangeError: Error returned by the exchange.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/exchange/transport/#academy.exchange.transport.ExchangeTransport.terminate","title":"terminate  <code>async</code>","text":"<pre><code>terminate(uid: EntityId) -&gt; None\n</code></pre> <p>Terminate a mailbox in the exchange.</p> <p>Once an entity's mailbox is terminated:</p> <ul> <li>All request messages in the mailbox will be replied to with a   <code>MailboxTerminatedError</code>.</li> <li>All calls to   <code>recv()</code>   will raise a   <code>MailboxTerminatedError</code>.</li> <li>All attempts to   <code>send()</code>   to this mailbox by other entities will raise a   <code>MailboxTerminatedError</code>.</li> </ul> Note <p>This method is a no-op if the mailbox does not exist.</p> <p>Parameters:</p> <ul> <li> <code>uid</code>               (<code>EntityId</code>)           \u2013            <p>Entity identifier of the mailbox to close.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ExchangeError</code>             \u2013            <p>Error returned by the exchange.</p> </li> </ul> Source code in <code>academy/exchange/transport.py</code> <pre><code>async def terminate(self, uid: EntityId) -&gt; None:\n    \"\"\"Terminate a mailbox in the exchange.\n\n    Once an entity's mailbox is terminated:\n\n    * All request messages in the mailbox will be replied to with a\n      [`MailboxTerminatedError`][academy.exception.MailboxTerminatedError].\n    * All calls to\n      [`recv()`][academy.exchange.transport.ExchangeTransport.recv]\n      will raise a\n      [`MailboxTerminatedError`][academy.exception.MailboxTerminatedError].\n    * All attempts to\n      [`send()`][academy.exchange.transport.ExchangeTransport.send]\n      to this mailbox by other entities will raise a\n      [`MailboxTerminatedError`][academy.exception.MailboxTerminatedError].\n\n    Note:\n        This method is a no-op if the mailbox does not exist.\n\n    Args:\n        uid: Entity identifier of the mailbox to close.\n\n    Raises:\n        ExchangeError: Error returned by the exchange.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/exchange/transport/#academy.exchange.transport.ExchangeTransportMixin","title":"ExchangeTransportMixin","text":"<p>Magic method mixin for exchange transport implementations.</p> <p>Adds <code>__repr__</code>, <code>__str__</code>, and context manager support.</p>"},{"location":"api/exchange/cloud/","title":"academy.exchange.cloud","text":"<code>academy/exchange/cloud/__init__.py</code>"},{"location":"api/exchange/cloud/#academy.exchange.cloud.HttpExchangeFactory","title":"HttpExchangeFactory","text":"<pre><code>HttpExchangeFactory(\n    url: str,\n    auth_method: Literal[\"globus\"] | None = None,\n    additional_headers: dict[str, str] | None = None,\n    request_timeout_s: float = 60,\n    ssl_verify: bool | None = None,\n)\n</code></pre> <p>               Bases: <code>ExchangeFactory[HttpExchangeTransport]</code></p> <p>Http exchange client factory.</p> <p>Parameters:</p> <ul> <li> <code>url</code>               (<code>str</code>)           \u2013            <p>Address of HTTP exchange</p> </li> <li> <code>auth_method</code>               (<code>Literal['globus'] | None</code>, default:                   <code>None</code> )           \u2013            <p>Method to get authorization headers</p> </li> <li> <code>additional_headers</code>               (<code>dict[str, str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Any other information necessary to communicate with the exchange. Used for passing the Globus bearer token</p> </li> <li> <code>ssl_verify</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Same as requests.Session.verify. If the server's TLS certificate should be validated. Should be true if using HTTPS Only set to false for testing or local development.</p> </li> </ul> Source code in <code>academy/exchange/cloud/client.py</code> <pre><code>def __init__(\n    self,\n    url: str,\n    auth_method: Literal['globus'] | None = None,\n    additional_headers: dict[str, str] | None = None,\n    request_timeout_s: float = 60,\n    ssl_verify: bool | None = None,\n) -&gt; None:\n    if additional_headers is None:\n        additional_headers = {}\n    additional_headers |= get_auth_headers(auth_method)\n\n    self._info = _HttpConnectionInfo(\n        url=url,\n        additional_headers=additional_headers,\n        ssl_verify=ssl_verify,\n        request_timeout_s=request_timeout_s,\n    )\n</code></pre>"},{"location":"api/exchange/cloud/#academy.exchange.cloud.HttpExchangeFactory.create_agent_client","title":"create_agent_client  <code>async</code>","text":"<pre><code>create_agent_client(\n    registration: AgentRegistration[AgentT],\n    request_handler: RequestHandler[RequestT_co],\n) -&gt; AgentExchangeClient[AgentT, ExchangeTransportT]\n</code></pre> <p>Create a new agent exchange client.</p> <p>An agent must be registered with the exchange before an exchange client can be created. For example: <pre><code>factory = ExchangeFactory(...)\nuser_client = factory.create_user_client()\nregistration = user_client.register_agent(...)\nagent_client = factory.create_agent_client(registration, ...)\n</code></pre></p> <p>Parameters:</p> <ul> <li> <code>registration</code>               (<code>AgentRegistration[AgentT]</code>)           \u2013            <p>Registration information returned by the exchange.</p> </li> <li> <code>request_handler</code>               (<code>RequestHandler[RequestT_co]</code>)           \u2013            <p>Agent request message handler.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AgentExchangeClient[AgentT, ExchangeTransportT]</code>           \u2013            <p>Agent exchange client.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BadEntityIdError</code>             \u2013            <p>If an agent with <code>registration.agent_id</code> is not already registered with the exchange.</p> </li> </ul> Source code in <code>academy/exchange/factory.py</code> <pre><code>async def create_agent_client(\n    self,\n    registration: AgentRegistration[AgentT],\n    request_handler: RequestHandler[RequestT_co],\n) -&gt; AgentExchangeClient[AgentT, ExchangeTransportT]:\n    \"\"\"Create a new agent exchange client.\n\n    An agent must be registered with the exchange before an exchange\n    client can be created. For example:\n    ```python\n    factory = ExchangeFactory(...)\n    user_client = factory.create_user_client()\n    registration = user_client.register_agent(...)\n    agent_client = factory.create_agent_client(registration, ...)\n    ```\n\n    Args:\n        registration: Registration information returned by the exchange.\n        request_handler: Agent request message handler.\n\n    Returns:\n        Agent exchange client.\n\n    Raises:\n        BadEntityIdError: If an agent with `registration.agent_id` is not\n            already registered with the exchange.\n    \"\"\"\n    agent_id: AgentId[AgentT] = registration.agent_id\n    transport = await self._create_transport(\n        mailbox_id=agent_id,\n        registration=registration,\n    )\n    assert transport.mailbox_id == agent_id\n    status = await transport.status(agent_id)\n    if status != MailboxStatus.ACTIVE:\n        await transport.close()\n        raise BadEntityIdError(agent_id)\n    return AgentExchangeClient(\n        agent_id,\n        transport,\n        request_handler=request_handler,\n    )\n</code></pre>"},{"location":"api/exchange/cloud/#academy.exchange.cloud.HttpExchangeFactory.create_user_client","title":"create_user_client  <code>async</code>","text":"<pre><code>create_user_client(\n    *, name: str | None = None, start_listener: bool = True\n) -&gt; UserExchangeClient[ExchangeTransportT]\n</code></pre> <p>Create a new user in the exchange and associated client.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Display name of the client on the exchange.</p> </li> <li> <code>start_listener</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Start a message listener thread.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>UserExchangeClient[ExchangeTransportT]</code>           \u2013            <p>User exchange client.</p> </li> </ul> Source code in <code>academy/exchange/factory.py</code> <pre><code>async def create_user_client(\n    self,\n    *,\n    name: str | None = None,\n    start_listener: bool = True,\n) -&gt; UserExchangeClient[ExchangeTransportT]:\n    \"\"\"Create a new user in the exchange and associated client.\n\n    Args:\n        name: Display name of the client on the exchange.\n        start_listener: Start a message listener thread.\n\n    Returns:\n        User exchange client.\n    \"\"\"\n    transport = await self._create_transport(mailbox_id=None, name=name)\n    user_id = transport.mailbox_id\n    assert isinstance(user_id, UserId)\n    return UserExchangeClient(\n        user_id,\n        transport,\n        start_listener=start_listener,\n    )\n</code></pre>"},{"location":"api/exchange/cloud/#academy.exchange.cloud.HttpExchangeTransport","title":"HttpExchangeTransport","text":"<pre><code>HttpExchangeTransport(\n    mailbox_id: EntityId,\n    session: ClientSession,\n    connection_info: _HttpConnectionInfo,\n)\n</code></pre> <p>               Bases: <code>ExchangeTransportMixin</code>, <code>NoPickleMixin</code></p> <p>Http exchange client.</p> <p>Parameters:</p> <ul> <li> <code>mailbox_id</code>               (<code>EntityId</code>)           \u2013            <p>Identifier of the mailbox on the exchange. If there is not an id provided, the exchange will create a new client mailbox.</p> </li> <li> <code>session</code>               (<code>ClientSession</code>)           \u2013            <p>Http session.</p> </li> <li> <code>connection_info</code>               (<code>_HttpConnectionInfo</code>)           \u2013            <p>Exchange connection info.</p> </li> </ul> Source code in <code>academy/exchange/cloud/client.py</code> <pre><code>def __init__(\n    self,\n    mailbox_id: EntityId,\n    session: aiohttp.ClientSession,\n    connection_info: _HttpConnectionInfo,\n) -&gt; None:\n    self._mailbox_id = mailbox_id\n    self._session = session\n    self._info = connection_info\n\n    base_url = self._info.url\n    self._mailbox_url = f'{base_url}/mailbox'\n    self._message_url = f'{base_url}/message'\n    self._discover_url = f'{base_url}/discover'\n</code></pre>"},{"location":"api/exchange/cloud/#academy.exchange.cloud.HttpExchangeTransport.new","title":"new  <code>async</code> <code>classmethod</code>","text":"<pre><code>new(\n    *,\n    connection_info: _HttpConnectionInfo,\n    mailbox_id: EntityId | None = None,\n    name: str | None = None\n) -&gt; Self\n</code></pre> <p>Instantiate a new transport.</p> <p>Parameters:</p> <ul> <li> <code>connection_info</code>               (<code>_HttpConnectionInfo</code>)           \u2013            <p>Exchange connection information.</p> </li> <li> <code>mailbox_id</code>               (<code>EntityId | None</code>, default:                   <code>None</code> )           \u2013            <p>Bind the transport to the specific mailbox. If <code>None</code>, a new user entity will be registered and the transport will be bound to that mailbox.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Display name of the registered entity if <code>mailbox_id</code> is <code>None</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>An instantiated transport bound to a specific mailbox.</p> </li> </ul> Source code in <code>academy/exchange/cloud/client.py</code> <pre><code>@classmethod\nasync def new(\n    cls,\n    *,\n    connection_info: _HttpConnectionInfo,\n    mailbox_id: EntityId | None = None,\n    name: str | None = None,\n) -&gt; Self:\n    \"\"\"Instantiate a new transport.\n\n    Args:\n        connection_info: Exchange connection information.\n        mailbox_id: Bind the transport to the specific mailbox. If `None`,\n            a new user entity will be registered and the transport will be\n            bound to that mailbox.\n        name: Display name of the registered entity if `mailbox_id` is\n            `None`.\n\n    Returns:\n        An instantiated transport bound to a specific mailbox.\n    \"\"\"\n    ssl_verify = connection_info.ssl_verify\n    if ssl_verify is None:  # pragma: no branch\n        scheme = urlparse(connection_info.url).scheme\n        ssl_verify = scheme == 'https'\n\n    session = aiohttp.ClientSession(\n        connector=aiohttp.TCPConnector(ssl=ssl_verify),\n        headers=connection_info.additional_headers,\n        trust_env=True,\n    )\n\n    if mailbox_id is None:\n        mailbox_id = UserId.new(name=name)\n        async with session.post(\n            f'{connection_info.url}/mailbox',\n            json={'mailbox': mailbox_id.model_dump_json()},\n        ) as response:\n            _raise_for_status(response, mailbox_id)\n        logger.info(\n            'Registered %s in exchange',\n            mailbox_id,\n            extra={'academy.mailbox_id': mailbox_id},\n        )\n\n    return cls(mailbox_id, session, connection_info)\n</code></pre>"},{"location":"api/exchange/cloud/#academy.exchange.cloud.GlobusExchangeFactory","title":"GlobusExchangeFactory","text":"<pre><code>GlobusExchangeFactory(\n    project_id: UUID,\n    client_params: dict[str, Any] | None = None,\n)\n</code></pre> <p>               Bases: <code>ExchangeFactory[GlobusExchangeTransport]</code></p> <p>Globus exchange client factory.</p> <p>Parameters:</p> <ul> <li> <code>project_id</code>               (<code>UUID</code>)           \u2013            <p>Project to create new clients under. Must be able to authenticate as a administrator.</p> </li> <li> <code>client_params</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional parameters for globus client.</p> </li> </ul> Source code in <code>academy/exchange/cloud/globus.py</code> <pre><code>def __init__(\n    self,\n    project_id: uuid.UUID,\n    client_params: dict[str, Any] | None = None,\n) -&gt; None:\n    self.project = project_id\n    self.client_params = client_params\n</code></pre>"},{"location":"api/exchange/cloud/#academy.exchange.cloud.GlobusExchangeFactory.create_agent_client","title":"create_agent_client  <code>async</code>","text":"<pre><code>create_agent_client(\n    registration: AgentRegistration[AgentT],\n    request_handler: RequestHandler[RequestT_co],\n) -&gt; AgentExchangeClient[AgentT, ExchangeTransportT]\n</code></pre> <p>Create a new agent exchange client.</p> <p>An agent must be registered with the exchange before an exchange client can be created. For example: <pre><code>factory = ExchangeFactory(...)\nuser_client = factory.create_user_client()\nregistration = user_client.register_agent(...)\nagent_client = factory.create_agent_client(registration, ...)\n</code></pre></p> <p>Parameters:</p> <ul> <li> <code>registration</code>               (<code>AgentRegistration[AgentT]</code>)           \u2013            <p>Registration information returned by the exchange.</p> </li> <li> <code>request_handler</code>               (<code>RequestHandler[RequestT_co]</code>)           \u2013            <p>Agent request message handler.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AgentExchangeClient[AgentT, ExchangeTransportT]</code>           \u2013            <p>Agent exchange client.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BadEntityIdError</code>             \u2013            <p>If an agent with <code>registration.agent_id</code> is not already registered with the exchange.</p> </li> </ul> Source code in <code>academy/exchange/factory.py</code> <pre><code>async def create_agent_client(\n    self,\n    registration: AgentRegistration[AgentT],\n    request_handler: RequestHandler[RequestT_co],\n) -&gt; AgentExchangeClient[AgentT, ExchangeTransportT]:\n    \"\"\"Create a new agent exchange client.\n\n    An agent must be registered with the exchange before an exchange\n    client can be created. For example:\n    ```python\n    factory = ExchangeFactory(...)\n    user_client = factory.create_user_client()\n    registration = user_client.register_agent(...)\n    agent_client = factory.create_agent_client(registration, ...)\n    ```\n\n    Args:\n        registration: Registration information returned by the exchange.\n        request_handler: Agent request message handler.\n\n    Returns:\n        Agent exchange client.\n\n    Raises:\n        BadEntityIdError: If an agent with `registration.agent_id` is not\n            already registered with the exchange.\n    \"\"\"\n    agent_id: AgentId[AgentT] = registration.agent_id\n    transport = await self._create_transport(\n        mailbox_id=agent_id,\n        registration=registration,\n    )\n    assert transport.mailbox_id == agent_id\n    status = await transport.status(agent_id)\n    if status != MailboxStatus.ACTIVE:\n        await transport.close()\n        raise BadEntityIdError(agent_id)\n    return AgentExchangeClient(\n        agent_id,\n        transport,\n        request_handler=request_handler,\n    )\n</code></pre>"},{"location":"api/exchange/cloud/#academy.exchange.cloud.GlobusExchangeFactory.create_user_client","title":"create_user_client  <code>async</code>","text":"<pre><code>create_user_client(\n    *, name: str | None = None, start_listener: bool = True\n) -&gt; UserExchangeClient[ExchangeTransportT]\n</code></pre> <p>Create a new user in the exchange and associated client.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Display name of the client on the exchange.</p> </li> <li> <code>start_listener</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Start a message listener thread.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>UserExchangeClient[ExchangeTransportT]</code>           \u2013            <p>User exchange client.</p> </li> </ul> Source code in <code>academy/exchange/factory.py</code> <pre><code>async def create_user_client(\n    self,\n    *,\n    name: str | None = None,\n    start_listener: bool = True,\n) -&gt; UserExchangeClient[ExchangeTransportT]:\n    \"\"\"Create a new user in the exchange and associated client.\n\n    Args:\n        name: Display name of the client on the exchange.\n        start_listener: Start a message listener thread.\n\n    Returns:\n        User exchange client.\n    \"\"\"\n    transport = await self._create_transport(mailbox_id=None, name=name)\n    user_id = transport.mailbox_id\n    assert isinstance(user_id, UserId)\n    return UserExchangeClient(\n        user_id,\n        transport,\n        start_listener=start_listener,\n    )\n</code></pre>"},{"location":"api/exchange/cloud/#academy.exchange.cloud.GlobusExchangeTransport","title":"GlobusExchangeTransport","text":"<pre><code>GlobusExchangeTransport(\n    mailbox_id: EntityId,\n    *,\n    project_id: UUID,\n    app: GlobusApp | None = None,\n    authorizer: GlobusAuthorizer | None = None,\n    client_params: dict[str, Any] | None = None\n)\n</code></pre> <p>               Bases: <code>ExchangeTransportMixin</code>, <code>NoPickleMixin</code></p> <p>Globus exchange client.</p> <p>Parameters:</p> <ul> <li> <code>mailbox_id</code>               (<code>EntityId</code>)           \u2013            <p>Identifier of the mailbox on the exchange. If there is not an id provided, the exchange will create a new client mailbox.</p> </li> <li> <code>project_id</code>               (<code>UUID</code>)           \u2013            <p>Globus Identifier of project to create agents under.</p> </li> <li> <code>app</code>               (<code>GlobusApp | None</code>, default:                   <code>None</code> )           \u2013            <p>For user authorization through token retrieval.</p> </li> <li> <code>authorizer</code>               (<code>GlobusAuthorizer | None</code>, default:                   <code>None</code> )           \u2013            <p>For service authorization through token retrieval.</p> </li> <li> <code>client_params</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional parameters for globus client.</p> </li> </ul> Source code in <code>academy/exchange/cloud/globus.py</code> <pre><code>def __init__(\n    self,\n    mailbox_id: EntityId,\n    *,\n    project_id: uuid.UUID,\n    app: GlobusApp | None = None,\n    authorizer: GlobusAuthorizer | None = None,\n    client_params: dict[str, Any] | None = None,\n) -&gt; None:\n    self._mailbox_id = mailbox_id\n    self.project = project_id\n    self.child_clients: list[uuid.UUID] = []\n    self.client_params = client_params or {}\n\n    self.login_time = datetime.min\n    self._app = app\n    self._authorizer = authorizer\n    self._local_data = threading.local()\n    self.executor = ThreadPoolExecutor(\n        thread_name_prefix='exchange-globus-thread',\n    )\n</code></pre>"},{"location":"api/exchange/cloud/#academy.exchange.cloud.GlobusExchangeTransport.exchange_client","title":"exchange_client  <code>property</code>","text":"<pre><code>exchange_client: AcademyGlobusClient\n</code></pre> <p>A thread local copy of the Globus AuthClient.</p>"},{"location":"api/exchange/cloud/#academy.exchange.cloud.GlobusExchangeTransport.auth_client","title":"auth_client  <code>property</code>","text":"<pre><code>auth_client: AuthClient\n</code></pre> <p>A thread local copy of the Globus AuthClient.</p>"},{"location":"api/exchange/cloud/#academy.exchange.cloud.GlobusExchangeTransport.new","title":"new  <code>async</code> <code>classmethod</code>","text":"<pre><code>new(\n    *,\n    project_id: UUID,\n    app: GlobusApp | None = None,\n    authorizer: GlobusAuthorizer | None = None,\n    mailbox_id: EntityId | None = None,\n    name: str | None = None,\n    client_params: dict[str, Any] | None = None\n) -&gt; Self\n</code></pre> <p>Instantiate a new transport.</p> <p>Parameters:</p> <ul> <li> <code>project_id</code>               (<code>UUID</code>)           \u2013            <p>Globus Identifier of project to create agents under.</p> </li> <li> <code>app</code>               (<code>GlobusApp | None</code>, default:                   <code>None</code> )           \u2013            <p>For user authorization through token retrieval</p> </li> <li> <code>authorizer</code>               (<code>GlobusAuthorizer | None</code>, default:                   <code>None</code> )           \u2013            <p>For service authorization through token retrieval</p> </li> <li> <code>mailbox_id</code>               (<code>EntityId | None</code>, default:                   <code>None</code> )           \u2013            <p>Bind the transport to the specific mailbox. If <code>None</code>, a new user entity will be registered and the transport will be bound to that mailbox.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Display name of the registered entity if <code>mailbox_id</code> is <code>None</code>.</p> </li> <li> <code>client_params</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional parameters for globus client.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>An instantiated transport bound to a specific mailbox.</p> </li> </ul> Source code in <code>academy/exchange/cloud/globus.py</code> <pre><code>@classmethod\nasync def new(  # noqa: PLR0913\n    cls,\n    *,\n    project_id: uuid.UUID,\n    app: GlobusApp | None = None,\n    authorizer: GlobusAuthorizer | None = None,\n    mailbox_id: EntityId | None = None,\n    name: str | None = None,\n    client_params: dict[str, Any] | None = None,\n) -&gt; Self:\n    \"\"\"Instantiate a new transport.\n\n    Args:\n        project_id: Globus Identifier of project to create agents under.\n        app: For user authorization through token retrieval\n        authorizer: For service authorization through token retrieval\n        mailbox_id: Bind the transport to the specific mailbox. If `None`,\n            a new user entity will be registered and the transport will be\n            bound to that mailbox.\n        name: Display name of the registered entity if `mailbox_id` is\n            `None`.\n        client_params: Additional parameters for globus client.\n\n    Returns:\n        An instantiated transport bound to a specific mailbox.\n    \"\"\"\n    loop = asyncio.get_running_loop()\n\n    if mailbox_id is None:\n        mailbox_id = UserId.new(name=name)\n        client = cls(\n            mailbox_id,\n            project_id=project_id,\n            app=app,\n            authorizer=authorizer,\n            client_params=client_params,\n        )\n        await loop.run_in_executor(\n            client.executor,\n            client._register_client,\n        )\n        logger.info(\n            'Registered %s in exchange',\n            mailbox_id,\n            extra={'academy.mailbox_id': mailbox_id},\n        )\n        return client\n\n    return cls(\n        mailbox_id,\n        project_id=project_id,\n        app=app,\n        authorizer=authorizer,\n        client_params=client_params,\n    )\n</code></pre>"},{"location":"api/exchange/cloud/#academy.exchange.cloud.spawn_http_exchange","title":"spawn_http_exchange","text":"<pre><code>spawn_http_exchange(\n    host: str = \"0.0.0.0\",\n    port: int = 5463,\n    *,\n    level: int | str = WARNING,\n    timeout: float | None = None\n) -&gt; Generator[HttpExchangeFactory]\n</code></pre> <p>Context manager that spawns an HTTP exchange in a subprocess.</p> <p>This function spawns a new process (rather than forking) and wait to return until a connection with the exchange has been established. When exiting the context manager, <code>SIGINT</code> will be sent to the exchange process. If the process does not exit within 5 seconds, it will be killed.</p> Warning <p>The exclusion of authentication and ssl configuration is intentional. This method should only be used for temporary exchanges in trusted environments (i.e. the login node of a cluster).</p> <p>Parameters:</p> <ul> <li> <code>host</code>               (<code>str</code>, default:                   <code>'0.0.0.0'</code> )           \u2013            <p>Host the exchange should listen on.</p> </li> <li> <code>port</code>               (<code>int</code>, default:                   <code>5463</code> )           \u2013            <p>Port the exchange should listen on.</p> </li> <li> <code>level</code>               (<code>int | str</code>, default:                   <code>WARNING</code> )           \u2013            <p>Logging level.</p> </li> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Connection timeout when waiting for exchange to start.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Generator[HttpExchangeFactory]</code>           \u2013            <p>Exchange interface connected to the spawned exchange.</p> </li> </ul> Source code in <code>academy/exchange/cloud/client.py</code> <pre><code>@contextlib.contextmanager\ndef spawn_http_exchange(\n    host: str = '0.0.0.0',\n    port: int = 5463,\n    *,\n    level: int | str = logging.WARNING,\n    timeout: float | None = None,\n) -&gt; Generator[HttpExchangeFactory]:\n    \"\"\"Context manager that spawns an HTTP exchange in a subprocess.\n\n    This function spawns a new process (rather than forking) and wait to\n    return until a connection with the exchange has been established.\n    When exiting the context manager, `SIGINT` will be sent to the exchange\n    process. If the process does not exit within 5 seconds, it will be\n    killed.\n\n    Warning:\n        The exclusion of authentication and ssl configuration is\n        intentional. This method should only be used for temporary exchanges\n        in trusted environments (i.e. the login node of a cluster).\n\n    Args:\n        host: Host the exchange should listen on.\n        port: Port the exchange should listen on.\n        level: Logging level.\n        timeout: Connection timeout when waiting for exchange to start.\n\n    Returns:\n        Exchange interface connected to the spawned exchange.\n    \"\"\"\n    config = ExchangeServingConfig(host=host, port=port, log_level=level)\n\n    # Fork is not safe in multi-threaded context.\n    context = multiprocessing.get_context('spawn')\n    exchange_process = context.Process(target=_run, args=(config,))\n    exchange_process.start()\n\n    logger.info('Starting exchange server...')\n    wait_connection(host, port, timeout=timeout)\n    logger.info('Started exchange server!')\n\n    base_url = f'http://{host}:{port}'\n    factory = HttpExchangeFactory(base_url)\n    try:\n        yield factory\n    finally:\n        logger.info('Terminating exchange server...')\n        wait = 5\n        exchange_process.terminate()\n        exchange_process.join(timeout=wait)\n        if exchange_process.exitcode is None:  # pragma: no cover\n            logger.info(\n                'Killing exchange server after waiting %s seconds',\n                wait,\n                extra={'academy.delay': wait},\n            )\n            exchange_process.kill()\n            exchange_process.join()\n        else:\n            logger.info('Terminated exchange server!')\n        exchange_process.close()\n</code></pre>"},{"location":"api/exchange/cloud/app/","title":"academy.exchange.cloud.app","text":"<code>academy/exchange/cloud/app.py</code> <p>HTTP message exchange client and server.</p> <p>To start the exchange: <pre><code>python -m academy.exchange.cloud --config exchange.toml\n</code></pre></p> <p>Connect to the exchange through the client. <pre><code>from academy.exchange import HttpExchangeFactory\n\nwith HttpExchangeFactory(\n    'http://localhost:1234'\n).create_user_client() as exchange:\n    aid, agent_info = exchange.register_agent()\n    ...\n</code></pre></p>"},{"location":"api/exchange/cloud/app/#academy.exchange.cloud.app.StatusCode","title":"StatusCode","text":"<p>               Bases: <code>Enum</code></p> <p>Http status codes.</p>"},{"location":"api/exchange/cloud/app/#academy.exchange.cloud.app.get_client_info","title":"get_client_info","text":"<pre><code>get_client_info(request: Request) -&gt; ClientInfo\n</code></pre> <p>Reconstitute client info from Request.</p> Source code in <code>academy/exchange/cloud/app.py</code> <pre><code>def get_client_info(request: Request) -&gt; ClientInfo:\n    \"\"\"Reconstitute client info from Request.\"\"\"\n    client_info = ClientInfo(\n        client_id=request.headers.get('client_id', ''),\n        group_memberships=set(\n            request.headers.get('client_groups', '').split(','),\n        ),\n    )\n    return client_info\n</code></pre>"},{"location":"api/exchange/cloud/app/#academy.exchange.cloud.app.authenticate_factory","title":"authenticate_factory","text":"<pre><code>authenticate_factory(authenticator: Authenticator) -&gt; Any\n</code></pre> <p>Create an authentication middleware for a given authenticator.</p> <p>Parameters:</p> <ul> <li> <code>authenticator</code>               (<code>Authenticator</code>)           \u2013            <p>Used to validate client id and transform token into id.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any</code>           \u2013            <p>A aiohttp.web.middleware function that will only allow authenticated requests.</p> </li> </ul> Source code in <code>academy/exchange/cloud/app.py</code> <pre><code>def authenticate_factory(\n    authenticator: Authenticator,\n) -&gt; Any:\n    \"\"\"Create an authentication middleware for a given authenticator.\n\n    Args:\n        authenticator: Used to validate client id and transform token into id.\n\n    Returns:\n        A aiohttp.web.middleware function that will only allow authenticated\n            requests.\n    \"\"\"\n\n    @middleware\n    async def authenticate(\n        request: Request,\n        handler: Callable[[Request], Awaitable[Response]],\n    ) -&gt; Response:\n        try:\n            client_info: ClientInfo = await authenticator.authenticate_user(\n                request.headers,\n            )\n        except ForbiddenError:\n            logger.exception('Could not authenticate.')\n            return Response(\n                status=StatusCode.FORBIDDEN.value,\n                text='Token expired or revoked.',\n            )\n        except UnauthorizedError:\n            logger.exception('Could not authenticate.')\n            return Response(\n                status=StatusCode.UNAUTHORIZED.value,\n                text='Missing required headers.',\n            )\n\n        headers = request.headers.copy()\n        headers['client_id'] = client_info.client_id\n        headers['client_groups'] = ','.join(client_info.group_memberships)\n\n        # Handle early client-side disconnect in Issue #142\n        # This is somewhat hard to reproduce in tests:\n        # https://github.com/aio-libs/aiohttp/issues/6978\n        if (\n            request.transport is None or request.transport.is_closing()\n        ):  # pragma: no cover\n            return Response(status=StatusCode.NO_RESPONSE.value)\n\n        request = request.clone(headers=headers)\n        return await handler(request)\n\n    return authenticate\n</code></pre>"},{"location":"api/exchange/cloud/app/#academy.exchange.cloud.app.create_app","title":"create_app","text":"<pre><code>create_app(\n    backend_config: BackendConfig | None = None,\n    auth_config: ExchangeAuthConfig | None = None,\n) -&gt; Application\n</code></pre> <p>Create a new server application.</p> Source code in <code>academy/exchange/cloud/app.py</code> <pre><code>def create_app(\n    backend_config: BackendConfig | None = None,\n    auth_config: ExchangeAuthConfig | None = None,\n) -&gt; Application:\n    \"\"\"Create a new server application.\"\"\"\n    if backend_config is not None:\n        backend = backend_config.get_backend()\n    else:\n        backend = PythonBackend()\n\n    middlewares = []\n    if auth_config is not None:\n        authenticator = get_authenticator(auth_config)\n        middlewares.append(authenticate_factory(authenticator))\n\n    app = Application(middlewares=middlewares)\n    app[MANAGER_KEY] = backend\n\n    app.router.add_post('/mailbox', _create_mailbox_route)\n    app.router.add_post('/mailbox/share', _share_mailbox_route)\n    app.router.add_get('/mailbox/share', _get_mailbox_shares_route)\n    app.router.add_delete('/mailbox', _terminate_route)\n    app.router.add_get('/mailbox', _check_mailbox_route)\n    app.router.add_put('/message', _send_message_route)\n    app.router.add_get('/message', _recv_message_route)\n    app.router.add_get('/discover', _discover_route)\n\n    return app\n</code></pre>"},{"location":"api/exchange/cloud/authenticate/","title":"academy.exchange.cloud.authenticate","text":"<code>academy/exchange/cloud/authenticate.py</code> <p>Authenticate users from request headers.</p>"},{"location":"api/exchange/cloud/authenticate/#academy.exchange.cloud.authenticate.Authenticator","title":"Authenticator","text":"<p>               Bases: <code>Protocol</code></p> <p>Authenticate users from request headers.</p>"},{"location":"api/exchange/cloud/authenticate/#academy.exchange.cloud.authenticate.Authenticator.authenticate_user","title":"authenticate_user  <code>async</code>","text":"<pre><code>authenticate_user(headers: Mapping[str, str]) -&gt; ClientInfo\n</code></pre> <p>Authenticate user from request headers.</p> Warning <p>This method must be thread safe!</p> <p>Parameters:</p> <ul> <li> <code>headers</code>               (<code>Mapping[str, str]</code>)           \u2013            <p>Request headers.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ClientInfo</code>           \u2013            <p>A user id upon authentication success.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ForbiddenError</code>             \u2013            <p>user is authenticated but is missing permissions or accessing forbidden resources.</p> </li> <li> <code>UnauthorizedError</code>             \u2013            <p>user authentication fails.</p> </li> </ul> Source code in <code>academy/exchange/cloud/authenticate.py</code> <pre><code>async def authenticate_user(\n    self,\n    headers: Mapping[str, str],\n) -&gt; ClientInfo:\n    \"\"\"Authenticate user from request headers.\n\n    Warning:\n        This method must be thread safe!\n\n    Args:\n        headers: Request headers.\n\n    Returns:\n        A user id upon authentication success.\n\n    Raises:\n        ForbiddenError: user is authenticated but is missing permissions\n            or accessing forbidden resources.\n        UnauthorizedError: user authentication fails.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/exchange/cloud/authenticate/#academy.exchange.cloud.authenticate.NullAuthenticator","title":"NullAuthenticator","text":"<p>Authenticator that implements no authentication.</p>"},{"location":"api/exchange/cloud/authenticate/#academy.exchange.cloud.authenticate.NullAuthenticator.authenticate_user","title":"authenticate_user  <code>async</code>","text":"<pre><code>authenticate_user(headers: Mapping[str, str]) -&gt; ClientInfo\n</code></pre> <p>Authenticate user from request headers.</p> <p>Parameters:</p> <ul> <li> <code>headers</code>               (<code>Mapping[str, str]</code>)           \u2013            <p>Request headers.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ClientInfo</code>           \u2013            <p>Null user regardless of provided headers.</p> </li> </ul> Source code in <code>academy/exchange/cloud/authenticate.py</code> <pre><code>async def authenticate_user(\n    self,\n    headers: Mapping[str, str],\n) -&gt; ClientInfo:\n    \"\"\"Authenticate user from request headers.\n\n    Args:\n        headers: Request headers.\n\n    Returns:\n        Null user regardless of provided headers.\n    \"\"\"\n    return ClientInfo(client_id='', group_memberships=set())\n</code></pre>"},{"location":"api/exchange/cloud/authenticate/#academy.exchange.cloud.authenticate.GlobusAuthenticator","title":"GlobusAuthenticator","text":"<pre><code>GlobusAuthenticator(\n    client_id: str | None = None,\n    client_secret: str | None = None,\n    *,\n    token_cache_limit: int = 1024,\n    token_ttl_s: int = 60,\n    group_info_cache_ttl_s: int = 60\n)\n</code></pre> <p>Globus Auth authorizer.</p> <p>Parameters:</p> <ul> <li> <code>client_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Globus application client ID. If either <code>client_id</code> or <code>client_secret</code> is <code>None</code>, the values will be read from the environment variables as described in <code>get_confidential_app_auth_client</code>. Ignored if <code>auth_client</code> is provided.</p> </li> <li> <code>client_secret</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Globus application client secret. See <code>client_id</code> for details. Ignored if <code>auth_client</code> is provided.</p> </li> <li> <code>token_cache_limit</code>               (<code>int</code>, default:                   <code>1024</code> )           \u2013            <p>Maximum number of (token, identity) mappings to store in memory.</p> </li> <li> <code>token_ttl_s</code>               (<code>int</code>, default:                   <code>60</code> )           \u2013            <p>Time in seconds before invalidating cached tokens.</p> </li> </ul> Source code in <code>academy/exchange/cloud/authenticate.py</code> <pre><code>def __init__(\n    self,\n    client_id: str | None = None,\n    client_secret: str | None = None,\n    *,\n    token_cache_limit: int = 1024,\n    token_ttl_s: int = 60,\n    group_info_cache_ttl_s: int = 60,\n) -&gt; None:\n    self._local_data = threading.local()\n    self.executor = ThreadPoolExecutor(\n        thread_name_prefix='exchange-auth-thread',\n    )\n    self.client_id = client_id or get_academy_exchange_client_id()\n    self.client_secret = client_secret or get_academy_exchange_secret()\n    self.audience = AcademyExchangeScopes.resource_server\n\n    self.token_cache = TTLCache(\n        maxsize=token_cache_limit,\n        ttl=token_ttl_s,\n    )\n    self.dependent_token_cache = TTLCache(\n        maxsize=token_cache_limit,\n        ttl=group_info_cache_ttl_s,\n    )\n    self.groups_info_cache = TTLCache(\n        maxsize=token_cache_limit,\n        ttl=group_info_cache_ttl_s,\n    )\n</code></pre>"},{"location":"api/exchange/cloud/authenticate/#academy.exchange.cloud.authenticate.GlobusAuthenticator.auth_client","title":"auth_client  <code>property</code>","text":"<pre><code>auth_client: ConfidentialAppAuthClient\n</code></pre> <p>A thread local copy of the Globus AuthClient.</p>"},{"location":"api/exchange/cloud/authenticate/#academy.exchange.cloud.authenticate.GlobusAuthenticator.authenticate_user","title":"authenticate_user  <code>async</code>","text":"<pre><code>authenticate_user(headers: Mapping[str, str]) -&gt; ClientInfo\n</code></pre> <p>Authenticate a Globus Auth user from request header.</p> <p>This follows from the Globus Sample Data Portal example.</p> <p>The underlying auth client is not thread safe, but this method is made thread safe using a lock.</p> <p>Parameters:</p> <ul> <li> <code>headers</code>               (<code>Mapping[str, str]</code>)           \u2013            <p>Request headers to extract tokens from.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ClientInfo</code>           \u2013            <p>Globus Auth identity returned via             token introspection.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>UnauthorizedError</code>             \u2013            <p>if the authorization header is missing or the header is malformed.</p> </li> <li> <code>ForbiddenError</code>             \u2013            <p>if the tokens have expired or been revoked.</p> </li> <li> <code>ForbiddenError</code>             \u2013            <p>if <code>audience</code> is not included in the token's audience.</p> </li> </ul> Source code in <code>academy/exchange/cloud/authenticate.py</code> <pre><code>async def authenticate_user(\n    self,\n    headers: Mapping[str, str],\n) -&gt; ClientInfo:\n    \"\"\"Authenticate a Globus Auth user from request header.\n\n    This follows from the [Globus Sample Data Portal](https://github.com/globus/globus-sample-data-portal/blob/30e30cd418ee9b103e04916e19deb9902d3aafd8/service/decorators.py)\n    example.\n\n    The underlying auth client is not thread safe, but this method is made\n    thread safe using a lock.\n\n    Args:\n        headers: Request headers to extract tokens from.\n\n    Returns:\n        Globus Auth identity returned via \\\n        [token introspection](https://docs.globus.org/api/auth/reference/#token-introspect).\n\n    Raises:\n        UnauthorizedError: if the authorization header is missing or\n            the header is malformed.\n        ForbiddenError: if the tokens have expired or been revoked.\n        ForbiddenError: if `audience` is not included in the token's\n            audience.\n    \"\"\"\n    token = get_token_from_headers(headers)\n    loop = asyncio.get_running_loop()\n    token_meta = await loop.run_in_executor(\n        self.executor,\n        self._token_introspect,\n        token,\n    )\n\n    if not token_meta.get('active'):\n        raise ForbiddenError('Token is expired or has been revoked.')\n\n    if self.audience is not None and self.audience not in token_meta.get(\n        'aud',\n        [],\n    ):\n        raise ForbiddenError(\n            f'Token audience does not include \"{self.audience}\". This '\n            'could result in a confused deputy attack. Ensure the correct '\n            'scopes are requested when the token is created.',\n        )\n\n    dependent_tokens = await loop.run_in_executor(\n        self.executor,\n        self._get_dependent_tokens,\n        token,\n    )\n\n    groups_info = await loop.run_in_executor(\n        self.executor,\n        self._get_groups_and_memberships,\n        dependent_tokens,\n    )\n\n    client_info = ClientInfo(\n        client_id=token_meta.get('username'),\n        group_memberships=groups_info,\n    )\n    return client_info\n</code></pre>"},{"location":"api/exchange/cloud/authenticate/#academy.exchange.cloud.authenticate.get_authenticator","title":"get_authenticator","text":"<pre><code>get_authenticator(\n    config: ExchangeAuthConfig,\n) -&gt; Authenticator\n</code></pre> <p>Create an authenticator from a configuration.</p> <p>Parameters:</p> <ul> <li> <code>config</code>               (<code>ExchangeAuthConfig</code>)           \u2013            <p>Configuration.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Authenticator</code>           \u2013            <p>Authenticator.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>if the authentication method in the config is unknown.</p> </li> </ul> Source code in <code>academy/exchange/cloud/authenticate.py</code> <pre><code>def get_authenticator(config: ExchangeAuthConfig) -&gt; Authenticator:\n    \"\"\"Create an authenticator from a configuration.\n\n    Args:\n        config: Configuration.\n\n    Returns:\n        Authenticator.\n\n    Raises:\n        ValueError: if the authentication method in the config is unknown.\n    \"\"\"\n    if config.method is None:\n        return NullAuthenticator()\n    elif config.method == 'globus':\n        return GlobusAuthenticator(**config.kwargs)\n    else:\n        raise ValueError(f'Unknown authentication method \"{config.method}.\"')\n</code></pre>"},{"location":"api/exchange/cloud/authenticate/#academy.exchange.cloud.authenticate.get_token_from_headers","title":"get_token_from_headers","text":"<pre><code>get_token_from_headers(headers: Mapping[str, str]) -&gt; str\n</code></pre> <p>Extract token from websockets headers.</p> <p>The header is expected to have the format <code>Authorization: Bearer &lt;TOKEN&gt;</code>.</p> <p>Parameters:</p> <ul> <li> <code>headers</code>               (<code>Mapping[str, str]</code>)           \u2013            <p>Request headers to extract tokens from.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>String token.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>UnauthorizedError</code>             \u2013            <p>if the authorization header is missing.</p> </li> <li> <code>UnauthorizedError</code>             \u2013            <p>if the authorization header is malformed.</p> </li> </ul> Source code in <code>academy/exchange/cloud/authenticate.py</code> <pre><code>def get_token_from_headers(headers: Mapping[str, str]) -&gt; str:\n    \"\"\"Extract token from websockets headers.\n\n    The header is expected to have the format `Authorization: Bearer &lt;TOKEN&gt;`.\n\n    Args:\n         headers: Request headers to extract tokens from.\n\n    Returns:\n        String token.\n\n    Raises:\n        UnauthorizedError: if the authorization header is missing.\n        UnauthorizedError: if the authorization header is malformed.\n    \"\"\"\n    if 'Authorization' not in headers:\n        raise UnauthorizedError(\n            'Request headers are missing authorization header.',\n        )\n\n    auth_header_parts = headers['Authorization'].split(' ')\n\n    if len(auth_header_parts) != 2 or auth_header_parts[0] != 'Bearer':  # noqa: PLR2004\n        raise UnauthorizedError(\n            'Bearer token in authorization header is malformed.',\n        )\n\n    return auth_header_parts[1]\n</code></pre>"},{"location":"api/exchange/cloud/backend/","title":"academy.exchange.cloud.backend","text":"<code>academy/exchange/cloud/backend.py</code>"},{"location":"api/exchange/cloud/backend/#academy.exchange.cloud.backend.MailboxBackend","title":"MailboxBackend","text":"<p>               Bases: <code>Protocol</code></p> <p>Backend protocol for storing mailboxes on server.</p>"},{"location":"api/exchange/cloud/backend/#academy.exchange.cloud.backend.MailboxBackend.check_mailbox","title":"check_mailbox  <code>async</code>","text":"<pre><code>check_mailbox(\n    client: ClientInfo, uid: EntityId\n) -&gt; MailboxStatus\n</code></pre> <p>Check if a mailbox exists, or is terminated.</p> <p>Parameters:</p> <ul> <li> <code>client</code>               (<code>ClientInfo</code>)           \u2013            <p>Client making the request.</p> </li> <li> <code>uid</code>               (<code>EntityId</code>)           \u2013            <p>Mailbox id to check.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>MailboxStatus</code>           \u2013            <p>The mailbox status.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ForbiddenError</code>             \u2013            <p>If the client does not have the right permissions.</p> </li> </ul> Source code in <code>academy/exchange/cloud/backend.py</code> <pre><code>async def check_mailbox(\n    self,\n    client: ClientInfo,\n    uid: EntityId,\n) -&gt; MailboxStatus:\n    \"\"\"Check if a mailbox exists, or is terminated.\n\n    Args:\n        client: Client making the request.\n        uid: Mailbox id to check.\n\n    Returns:\n        The mailbox status.\n\n    Raises:\n        ForbiddenError: If the client does not have the right permissions.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/exchange/cloud/backend/#academy.exchange.cloud.backend.MailboxBackend.create_mailbox","title":"create_mailbox  <code>async</code>","text":"<pre><code>create_mailbox(\n    client: ClientInfo,\n    uid: EntityId,\n    agent: tuple[str, ...] | None = None,\n) -&gt; None\n</code></pre> <p>Create a mailbox is not exists.</p> <p>This method should be idempotent.</p> <p>Parameters:</p> <ul> <li> <code>client</code>               (<code>ClientInfo</code>)           \u2013            <p>Client making the request.</p> </li> <li> <code>uid</code>               (<code>EntityId</code>)           \u2013            <p>Mailbox id to check.</p> </li> <li> <code>agent</code>               (<code>tuple[str, ...] | None</code>, default:                   <code>None</code> )           \u2013            <p>The agent_mro for behavior discovery.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ForbiddenError</code>             \u2013            <p>If the client does not have the right permissions.</p> </li> </ul> Source code in <code>academy/exchange/cloud/backend.py</code> <pre><code>async def create_mailbox(\n    self,\n    client: ClientInfo,\n    uid: EntityId,\n    agent: tuple[str, ...] | None = None,\n) -&gt; None:\n    \"\"\"Create a mailbox is not exists.\n\n    This method should be idempotent.\n\n    Args:\n        client: Client making the request.\n        uid: Mailbox id to check.\n        agent: The agent_mro for behavior discovery.\n\n    Raises:\n        ForbiddenError: If the client does not have the right permissions.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/exchange/cloud/backend/#academy.exchange.cloud.backend.MailboxBackend.terminate","title":"terminate  <code>async</code>","text":"<pre><code>terminate(client: ClientInfo, uid: EntityId) -&gt; None\n</code></pre> <p>Close a mailbox.</p> <p>For security, the manager should keep a gravestone so the same id cannot be re-registered.</p> <p>Parameters:</p> <ul> <li> <code>client</code>               (<code>ClientInfo</code>)           \u2013            <p>Client making the request.</p> </li> <li> <code>uid</code>               (<code>EntityId</code>)           \u2013            <p>Mailbox id to close.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ForbiddenError</code>             \u2013            <p>If the client does not have the right permissions.</p> </li> </ul> Source code in <code>academy/exchange/cloud/backend.py</code> <pre><code>async def terminate(self, client: ClientInfo, uid: EntityId) -&gt; None:\n    \"\"\"Close a mailbox.\n\n    For security, the manager should keep a gravestone so the same id\n    cannot be re-registered.\n\n    Args:\n        client: Client making the request.\n        uid: Mailbox id to close.\n\n    Raises:\n        ForbiddenError: If the client does not have the right permissions.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/exchange/cloud/backend/#academy.exchange.cloud.backend.MailboxBackend.discover","title":"discover  <code>async</code>","text":"<pre><code>discover(\n    client: ClientInfo, agent: str, allow_subclasses: bool\n) -&gt; list[AgentId[Any]]\n</code></pre> <p>Find mailboxes of matching agent class.</p> <p>Parameters:</p> <ul> <li> <code>client</code>               (<code>ClientInfo</code>)           \u2013            <p>Client making the request.</p> </li> <li> <code>agent</code>               (<code>str</code>)           \u2013            <p>Agent class to search for.</p> </li> <li> <code>allow_subclasses</code>               (<code>bool</code>)           \u2013            <p>Include agents that inherit from the target.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ForbiddenError</code>             \u2013            <p>If the client does not have the right permissions.</p> </li> </ul> Source code in <code>academy/exchange/cloud/backend.py</code> <pre><code>async def discover(\n    self,\n    client: ClientInfo,\n    agent: str,\n    allow_subclasses: bool,\n) -&gt; list[AgentId[Any]]:\n    \"\"\"Find mailboxes of matching agent class.\n\n    Args:\n        client: Client making the request.\n        agent: Agent class to search for.\n        allow_subclasses: Include agents that inherit from the target.\n\n    Raises:\n        ForbiddenError: If the client does not have the right permissions.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/exchange/cloud/backend/#academy.exchange.cloud.backend.MailboxBackend.get","title":"get  <code>async</code>","text":"<pre><code>get(\n    client: ClientInfo,\n    uid: EntityId,\n    *,\n    timeout: float | None = None\n) -&gt; Message[Any]\n</code></pre> <p>Get messages from a mailbox.</p> <p>Parameters:</p> <ul> <li> <code>client</code>               (<code>ClientInfo</code>)           \u2013            <p>Client making the request.</p> </li> <li> <code>uid</code>               (<code>EntityId</code>)           \u2013            <p>Mailbox id to get messages.</p> </li> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Time in seconds to wait for message. If None, wait indefinitely.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ForbiddenError</code>             \u2013            <p>If the client does not have the right permissions.</p> </li> <li> <code>BadEntityIdError</code>             \u2013            <p>The mailbox requested does not exist.</p> </li> <li> <code>MailboxTerminatedError</code>             \u2013            <p>The mailbox is closed.</p> </li> <li> <code>TimeoutError</code>             \u2013            <p>There was not message received during the timeout.</p> </li> </ul> Source code in <code>academy/exchange/cloud/backend.py</code> <pre><code>async def get(\n    self,\n    client: ClientInfo,\n    uid: EntityId,\n    *,\n    timeout: float | None = None,\n) -&gt; Message[Any]:\n    \"\"\"Get messages from a mailbox.\n\n    Args:\n        client: Client making the request.\n        uid: Mailbox id to get messages.\n        timeout: Time in seconds to wait for message.\n            If None, wait indefinitely.\n\n    Raises:\n        ForbiddenError: If the client does not have the right permissions.\n        BadEntityIdError: The mailbox requested does not exist.\n        MailboxTerminatedError: The mailbox is closed.\n        TimeoutError: There was not message received during the timeout.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/exchange/cloud/backend/#academy.exchange.cloud.backend.MailboxBackend.put","title":"put  <code>async</code>","text":"<pre><code>put(client: ClientInfo, message: Message[Any]) -&gt; None\n</code></pre> <p>Put a message in a mailbox.</p> <p>Parameters:</p> <ul> <li> <code>client</code>               (<code>ClientInfo</code>)           \u2013            <p>Client making the request.</p> </li> <li> <code>message</code>               (<code>Message[Any]</code>)           \u2013            <p>Message to put in mailbox.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ForbiddenError</code>             \u2013            <p>If the client does not have the right permissions.</p> </li> <li> <code>BadEntityIdError</code>             \u2013            <p>The mailbox requested does not exist.</p> </li> <li> <code>MailboxTerminatedError</code>             \u2013            <p>The mailbox is closed.</p> </li> <li> <code>MessageTooLargeError</code>             \u2013            <p>The message is larger than the message size limit for this exchange.</p> </li> </ul> Source code in <code>academy/exchange/cloud/backend.py</code> <pre><code>async def put(self, client: ClientInfo, message: Message[Any]) -&gt; None:\n    \"\"\"Put a message in a mailbox.\n\n    Args:\n        client: Client making the request.\n        message: Message to put in mailbox.\n\n    Raises:\n        ForbiddenError: If the client does not have the right permissions.\n        BadEntityIdError: The mailbox requested does not exist.\n        MailboxTerminatedError: The mailbox is closed.\n        MessageTooLargeError: The message is larger than the message\n            size limit for this exchange.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/exchange/cloud/backend/#academy.exchange.cloud.backend.MailboxBackend.share_mailbox","title":"share_mailbox  <code>async</code>","text":"<pre><code>share_mailbox(\n    client: ClientInfo, uid: EntityId, group_uid: str\n) -&gt; None\n</code></pre> <p>Share a mailbox with a Globus Group.</p> <p>Only the owner of the Mailbox is allowed to share with a Globus Group. This method should be idempotent.</p> <p>Parameters:</p> <ul> <li> <code>client</code>               (<code>ClientInfo</code>)           \u2013            <p>Client making the request.</p> </li> <li> <code>uid</code>               (<code>EntityId</code>)           \u2013            <p>Mailbox id to share.</p> </li> <li> <code>group_uid</code>               (<code>str</code>)           \u2013            <p>Globus Group id to share.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ForbiddenError</code>             \u2013            <p>If the client does not have the right permissions.</p> </li> <li> <code>BadEntityIdError</code>             \u2013            <p>The mailbox to share does not exist.</p> </li> <li> <code>MailboxTerminatedError</code>             \u2013            <p>The mailbox is closed.</p> </li> </ul> Source code in <code>academy/exchange/cloud/backend.py</code> <pre><code>async def share_mailbox(\n    self,\n    client: ClientInfo,\n    uid: EntityId,\n    group_uid: str,\n) -&gt; None:\n    \"\"\"Share a mailbox with a Globus Group.\n\n    Only the owner of the Mailbox is allowed to share with a Globus Group.\n    This method should be idempotent.\n\n    Args:\n        client: Client making the request.\n        uid: Mailbox id to share.\n        group_uid: Globus Group id to share.\n\n    Raises:\n        ForbiddenError: If the client does not have the right permissions.\n        BadEntityIdError: The mailbox to share does not exist.\n        MailboxTerminatedError: The mailbox is closed.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/exchange/cloud/backend/#academy.exchange.cloud.backend.MailboxBackend.get_mailbox_shares","title":"get_mailbox_shares  <code>async</code>","text":"<pre><code>get_mailbox_shares(\n    client: ClientInfo, uid: EntityId\n) -&gt; list[str]\n</code></pre> <p>Get list of globus groups the mailbox is shared with.</p> <p>Only the owner of the Mailbox is allowed to share with a Globus Group. This method should be idempotent.</p> <p>Parameters:</p> <ul> <li> <code>client</code>               (<code>ClientInfo</code>)           \u2013            <p>Client making the request.</p> </li> <li> <code>uid</code>               (<code>EntityId</code>)           \u2013            <p>Mailbox id to share.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>List of globus groups id strings</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ForbiddenError</code>             \u2013            <p>If the client does not have the right permissions.</p> </li> <li> <code>BadEntityIdError</code>             \u2013            <p>The mailbox requested does not exist.</p> </li> <li> <code>MailboxTerminatedError</code>             \u2013            <p>The mailbox is closed.</p> </li> </ul> Source code in <code>academy/exchange/cloud/backend.py</code> <pre><code>async def get_mailbox_shares(\n    self,\n    client: ClientInfo,\n    uid: EntityId,\n) -&gt; list[str]:\n    \"\"\"Get list of globus groups the mailbox is shared with.\n\n    Only the owner of the Mailbox is allowed to share with a Globus Group.\n    This method should be idempotent.\n\n    Args:\n        client: Client making the request.\n        uid: Mailbox id to share.\n\n    Returns:\n        List of globus groups id strings\n\n    Raises:\n        ForbiddenError: If the client does not have the right permissions.\n        BadEntityIdError: The mailbox requested does not exist.\n        MailboxTerminatedError: The mailbox is closed.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/exchange/cloud/backend/#academy.exchange.cloud.backend.PythonBackend","title":"PythonBackend","text":"<pre><code>PythonBackend(message_size_limit_kb: int = 1024)\n</code></pre> <p>Mailbox backend using in-memory python data structures.</p> <p>Parameters:</p> <ul> <li> <code>message_size_limit_kb</code>               (<code>int</code>, default:                   <code>1024</code> )           \u2013            <p>Maximum message size to allow.</p> </li> </ul> Source code in <code>academy/exchange/cloud/backend.py</code> <pre><code>def __init__(\n    self,\n    message_size_limit_kb: int = 1024,\n) -&gt; None:\n    self._owners: dict[EntityId, str | None] = {}\n    self._shares: dict[EntityId, set[str]] = {}\n    self._mailboxes: dict[EntityId, AsyncQueue[Message[Any]]] = {}\n    self._terminated: set[EntityId] = set()\n    self._agents: dict[AgentId[Any], tuple[str, ...]] = {}\n    self._locks: dict[EntityId, asyncio.Lock] = {}\n    self.message_size_limit = message_size_limit_kb * KB_TO_BYTES\n</code></pre>"},{"location":"api/exchange/cloud/backend/#academy.exchange.cloud.backend.PythonBackend.check_mailbox","title":"check_mailbox  <code>async</code>","text":"<pre><code>check_mailbox(\n    client: ClientInfo, uid: EntityId\n) -&gt; MailboxStatus\n</code></pre> <p>Check if a mailbox exists, or is terminated.</p> <p>Parameters:</p> <ul> <li> <code>client</code>               (<code>ClientInfo</code>)           \u2013            <p>Client making the request.</p> </li> <li> <code>uid</code>               (<code>EntityId</code>)           \u2013            <p>Mailbox id to check.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>MailboxStatus</code>           \u2013            <p>The mailbox status.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ForbiddenError</code>             \u2013            <p>If the client does not have the right permissions.</p> </li> </ul> Source code in <code>academy/exchange/cloud/backend.py</code> <pre><code>async def check_mailbox(\n    self,\n    client: ClientInfo,\n    uid: EntityId,\n) -&gt; MailboxStatus:\n    \"\"\"Check if a mailbox exists, or is terminated.\n\n    Args:\n        client: Client making the request.\n        uid: Mailbox id to check.\n\n    Returns:\n        The mailbox status.\n\n    Raises:\n        ForbiddenError: If the client does not have the right permissions.\n    \"\"\"\n    if uid not in self._mailboxes:\n        return MailboxStatus.MISSING\n    elif not self._has_permissions(client, uid):\n        raise ForbiddenError(\n            'Client does not have correct permissions.',\n        )\n\n    async with self._locks[uid]:\n        if uid in self._terminated:\n            return MailboxStatus.TERMINATED\n        else:\n            return MailboxStatus.ACTIVE\n</code></pre>"},{"location":"api/exchange/cloud/backend/#academy.exchange.cloud.backend.PythonBackend.create_mailbox","title":"create_mailbox  <code>async</code>","text":"<pre><code>create_mailbox(\n    client: ClientInfo,\n    uid: EntityId,\n    agent: tuple[str, ...] | None = None,\n) -&gt; None\n</code></pre> <p>Create a mailbox is not exists.</p> <p>This method should be idempotent.</p> <p>Parameters:</p> <ul> <li> <code>client</code>               (<code>ClientInfo</code>)           \u2013            <p>Client making the request.</p> </li> <li> <code>uid</code>               (<code>EntityId</code>)           \u2013            <p>Mailbox id to check.</p> </li> <li> <code>agent</code>               (<code>tuple[str, ...] | None</code>, default:                   <code>None</code> )           \u2013            <p>The agent_mro for behavior discovery.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ForbiddenError</code>             \u2013            <p>If the client does not have the right permissions.</p> </li> </ul> Source code in <code>academy/exchange/cloud/backend.py</code> <pre><code>async def create_mailbox(\n    self,\n    client: ClientInfo,\n    uid: EntityId,\n    agent: tuple[str, ...] | None = None,\n) -&gt; None:\n    \"\"\"Create a mailbox is not exists.\n\n    This method should be idempotent.\n\n    Args:\n        client: Client making the request.\n        uid: Mailbox id to check.\n        agent: The agent_mro for behavior discovery.\n\n    Raises:\n        ForbiddenError: If the client does not have the right permissions.\n    \"\"\"\n    if not self._has_permissions(client, uid):\n        raise ForbiddenError(\n            'Client does not have correct permissions.',\n        )\n\n    mailbox = self._mailboxes.get(uid, None)\n    if mailbox is None:\n        if sys.version_info &gt;= (3, 13):  # pragma: &gt;=3.13 cover\n            queue: AsyncQueue[Message[Any]] = Queue()\n        else:  # pragma: &lt;3.13 cover\n            queue: AsyncQueue[Message[Any]] = Queue().async_q\n        self._mailboxes[uid] = queue\n        self._terminated.discard(uid)\n        self._owners[uid] = client.client_id\n        self._locks[uid] = asyncio.Lock()\n        if agent is not None and isinstance(uid, AgentId):\n            self._agents[uid] = agent\n        logger.info(\n            'Created mailbox for %s',\n            uid,\n            extra={'academy.mailbox_id': uid},\n        )\n</code></pre>"},{"location":"api/exchange/cloud/backend/#academy.exchange.cloud.backend.PythonBackend.terminate","title":"terminate  <code>async</code>","text":"<pre><code>terminate(client: ClientInfo, uid: EntityId) -&gt; None\n</code></pre> <p>Close a mailbox.</p> <p>For security, the manager should keep a gravestone so the same id cannot be re-registered.</p> <p>Parameters:</p> <ul> <li> <code>client</code>               (<code>ClientInfo</code>)           \u2013            <p>Client making the request.</p> </li> <li> <code>uid</code>               (<code>EntityId</code>)           \u2013            <p>Mailbox id to close.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ForbiddenError</code>             \u2013            <p>If the client does not have the right permissions.</p> </li> </ul> Source code in <code>academy/exchange/cloud/backend.py</code> <pre><code>async def terminate(self, client: ClientInfo, uid: EntityId) -&gt; None:\n    \"\"\"Close a mailbox.\n\n    For security, the manager should keep a gravestone so the same id\n    cannot be re-registered.\n\n    Args:\n        client: Client making the request.\n        uid: Mailbox id to close.\n\n    Raises:\n        ForbiddenError: If the client does not have the right permissions.\n\n    \"\"\"\n    if not self._has_permissions(client, uid):\n        raise ForbiddenError(\n            'Client does not have correct permissions.',\n        )\n\n    self._terminated.add(uid)\n    mailbox = self._mailboxes.get(uid, None)\n    if mailbox is None:\n        return\n\n    async with self._locks[uid]:\n        messages = await _drain_queue(mailbox)\n        for message in messages:\n            if message.is_request():\n                error = MailboxTerminatedError(uid)\n                body = ErrorResponse(exception=error)\n                response = message.create_response(body)\n                with contextlib.suppress(Exception):\n                    await self.put(client, response)\n\n        mailbox.shutdown(immediate=True)\n        logger.info(\n            'Closed mailbox for %s',\n            uid,\n            extra={'academy.mailbox_id': uid},\n        )\n</code></pre>"},{"location":"api/exchange/cloud/backend/#academy.exchange.cloud.backend.PythonBackend.discover","title":"discover  <code>async</code>","text":"<pre><code>discover(\n    client: ClientInfo, agent: str, allow_subclasses: bool\n) -&gt; list[AgentId[Any]]\n</code></pre> <p>Find mailboxes of matching agent class.</p> <p>Parameters:</p> <ul> <li> <code>client</code>               (<code>ClientInfo</code>)           \u2013            <p>Client making the request.</p> </li> <li> <code>agent</code>               (<code>str</code>)           \u2013            <p>Agent class to search for.</p> </li> <li> <code>allow_subclasses</code>               (<code>bool</code>)           \u2013            <p>Include agents that inherit from the target.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ForbiddenError</code>             \u2013            <p>If the client does not have the right permissions.</p> </li> </ul> Source code in <code>academy/exchange/cloud/backend.py</code> <pre><code>async def discover(\n    self,\n    client: ClientInfo,\n    agent: str,\n    allow_subclasses: bool,\n) -&gt; list[AgentId[Any]]:\n    \"\"\"Find mailboxes of matching agent class.\n\n    Args:\n        client: Client making the request.\n        agent: Agent class to search for.\n        allow_subclasses: Include agents that inherit from the target.\n\n    Raises:\n        ForbiddenError: If the client does not have the right permissions.\n    \"\"\"\n    found: list[AgentId[Any]] = []\n    for aid, agents in self._agents.items():\n        if not self._has_permissions(client, aid):\n            continue\n        if aid in self._terminated:\n            continue\n        if agent == agents[0] or (allow_subclasses and agent in agents):\n            found.append(aid)\n    return found\n</code></pre>"},{"location":"api/exchange/cloud/backend/#academy.exchange.cloud.backend.PythonBackend.get","title":"get  <code>async</code>","text":"<pre><code>get(\n    client: ClientInfo,\n    uid: EntityId,\n    *,\n    timeout: float | None = None\n) -&gt; Message[Any]\n</code></pre> <p>Get messages from a mailbox.</p> <p>Parameters:</p> <ul> <li> <code>client</code>               (<code>ClientInfo</code>)           \u2013            <p>Client making the request.</p> </li> <li> <code>uid</code>               (<code>EntityId</code>)           \u2013            <p>Mailbox id to get messages.</p> </li> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Time in seconds to wait for message. If None, wait indefinitely.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ForbiddenError</code>             \u2013            <p>If the client does not have the right permissions.</p> </li> <li> <code>BadEntityIdError</code>             \u2013            <p>The mailbox requested does not exist.</p> </li> <li> <code>MailboxTerminatedError</code>             \u2013            <p>The mailbox is closed.</p> </li> <li> <code>TimeoutError</code>             \u2013            <p>There was not message received during the timeout.</p> </li> </ul> Source code in <code>academy/exchange/cloud/backend.py</code> <pre><code>async def get(\n    self,\n    client: ClientInfo,\n    uid: EntityId,\n    *,\n    timeout: float | None = None,\n) -&gt; Message[Any]:\n    \"\"\"Get messages from a mailbox.\n\n    Args:\n        client: Client making the request.\n        uid: Mailbox id to get messages.\n        timeout: Time in seconds to wait for message.\n            If None, wait indefinitely.\n\n    Raises:\n        ForbiddenError: If the client does not have the right permissions.\n        BadEntityIdError: The mailbox requested does not exist.\n        MailboxTerminatedError: The mailbox is closed.\n        TimeoutError: There was not message received during the timeout.\n    \"\"\"\n    if not self._has_permissions(client, uid):\n        raise ForbiddenError(\n            'Client does not have correct permissions.',\n        )\n\n    try:\n        queue = self._mailboxes[uid]\n    except KeyError as e:\n        raise BadEntityIdError(uid) from e\n    try:\n        return await asyncio.wait_for(queue.get(), timeout=timeout)\n    except QueueShutDown:\n        raise MailboxTerminatedError(uid) from None\n    except asyncio.TimeoutError:\n        # In Python 3.10 and older, asyncio.TimeoutError and TimeoutError\n        # are different error types.\n        raise TimeoutError(\n            f'No message retrieved within {timeout} seconds.',\n        ) from None\n</code></pre>"},{"location":"api/exchange/cloud/backend/#academy.exchange.cloud.backend.PythonBackend.put","title":"put  <code>async</code>","text":"<pre><code>put(client: ClientInfo, message: Message[Any]) -&gt; None\n</code></pre> <p>Put a message in a mailbox.</p> <p>Parameters:</p> <ul> <li> <code>client</code>               (<code>ClientInfo</code>)           \u2013            <p>Client making the request.</p> </li> <li> <code>message</code>               (<code>Message[Any]</code>)           \u2013            <p>Message to put in mailbox.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ForbiddenError</code>             \u2013            <p>If the client does not have the right permissions.</p> </li> <li> <code>BadEntityIdError</code>             \u2013            <p>The mailbox requested does not exist.</p> </li> <li> <code>MailboxTerminatedError</code>             \u2013            <p>The mailbox is closed.</p> </li> <li> <code>MessageTooLargeError</code>             \u2013            <p>The message is larger than the message size limit for this exchange.</p> </li> </ul> Source code in <code>academy/exchange/cloud/backend.py</code> <pre><code>async def put(self, client: ClientInfo, message: Message[Any]) -&gt; None:\n    \"\"\"Put a message in a mailbox.\n\n    Args:\n        client: Client making the request.\n        message: Message to put in mailbox.\n\n    Raises:\n        ForbiddenError: If the client does not have the right permissions.\n        BadEntityIdError: The mailbox requested does not exist.\n        MailboxTerminatedError: The mailbox is closed.\n        MessageTooLargeError: The message is larger than the message\n            size limit for this exchange.\n    \"\"\"\n    if not self._has_permissions(client, message.dest):\n        raise ForbiddenError(\n            'Client does not have correct permissions.',\n        )\n\n    if sys.getsizeof(message.body) &gt; self.message_size_limit:\n        raise MessageTooLargeError(\n            sys.getsizeof(message.body),\n            self.message_size_limit,\n        )\n\n    try:\n        queue = self._mailboxes[message.dest]\n    except KeyError as e:\n        raise BadEntityIdError(message.dest) from e\n\n    async with self._locks[message.dest]:\n        try:\n            await queue.put(message)\n        except QueueShutDown:\n            raise MailboxTerminatedError(message.dest) from None\n</code></pre>"},{"location":"api/exchange/cloud/backend/#academy.exchange.cloud.backend.PythonBackend.share_mailbox","title":"share_mailbox  <code>async</code>","text":"<pre><code>share_mailbox(\n    client: ClientInfo, uid: EntityId, group_uid: str\n) -&gt; None\n</code></pre> <p>Share a mailbox with a Globus group.</p> <p>Parameters:</p> <ul> <li> <code>client</code>               (<code>ClientInfo</code>)           \u2013            <p>Client making the request.</p> </li> <li> <code>uid</code>               (<code>EntityId</code>)           \u2013            <p>Target Mailbox for sharing</p> </li> <li> <code>group_uid</code>               (<code>str</code>)           \u2013            <p>Group id to share mailbox with.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ForbiddenError</code>             \u2013            <p>If the client does not have the right permissions.</p> </li> </ul> Source code in <code>academy/exchange/cloud/backend.py</code> <pre><code>async def share_mailbox(\n    self,\n    client: ClientInfo,\n    uid: EntityId,\n    group_uid: str,\n) -&gt; None:\n    \"\"\"Share a mailbox with a Globus group.\n\n    Args:\n        client: Client making the request.\n        uid: Target Mailbox for sharing\n        group_uid: Group id to share mailbox with.\n\n    Raises:\n        ForbiddenError: If the client does not have the right permissions.\n    \"\"\"\n    if uid not in self._mailboxes:\n        raise BadEntityIdError(uid)\n\n    if uid in self._terminated:\n        raise MailboxTerminatedError(uid)\n\n    if not self._has_mailbox_ownership(client, uid):\n        raise ForbiddenError(\n            f'{client.client_id} cannot share mailbox '\n            f'{uid} it does not own.',\n        )\n\n    if group_uid not in client.group_memberships:\n        raise ForbiddenError(\n            f'Owner does not belong to the group {group_uid}',\n        )\n\n    if uid not in self._shares:\n        self._shares[uid] = set()\n\n    self._shares[uid].add(group_uid)\n    logger.info('Mailbox %s shared with group %s', uid, group_uid)\n</code></pre>"},{"location":"api/exchange/cloud/backend/#academy.exchange.cloud.backend.PythonBackend.get_mailbox_shares","title":"get_mailbox_shares  <code>async</code>","text":"<pre><code>get_mailbox_shares(\n    client: ClientInfo, uid: EntityId\n) -&gt; list[str]\n</code></pre> <p>Get list of globus groups the mailbox is shared with.</p> <p>Only the owner of the Mailbox is allowed to share with a Globus Group. This method should be idempotent.</p> <p>Parameters:</p> <ul> <li> <code>client</code>               (<code>ClientInfo</code>)           \u2013            <p>Client making the request.</p> </li> <li> <code>uid</code>               (<code>EntityId</code>)           \u2013            <p>Mailbox id to share.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>List of globus groups id strings</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ForbiddenError</code>             \u2013            <p>If the client does not have the right permissions.</p> </li> <li> <code>BadEntityIdError</code>             \u2013            <p>The mailbox requested does not exist.</p> </li> <li> <code>MailboxTerminatedError</code>             \u2013            <p>The mailbox is closed.</p> </li> </ul> Source code in <code>academy/exchange/cloud/backend.py</code> <pre><code>async def get_mailbox_shares(\n    self,\n    client: ClientInfo,\n    uid: EntityId,\n) -&gt; list[str]:\n    \"\"\"Get list of globus groups the mailbox is shared with.\n\n    Only the owner of the Mailbox is allowed to share with a Globus Group.\n    This method should be idempotent.\n\n    Args:\n        client: Client making the request.\n        uid: Mailbox id to share.\n\n    Returns:\n        List of globus groups id strings\n\n    Raises:\n        ForbiddenError: If the client does not have the right permissions.\n        BadEntityIdError: The mailbox requested does not exist.\n        MailboxTerminatedError: The mailbox is closed.\n    \"\"\"\n    if uid not in self._mailboxes:\n        raise BadEntityIdError(uid)\n\n    if uid in self._terminated:\n        raise MailboxTerminatedError(uid)\n\n    if not self._has_mailbox_ownership(client, uid):\n        raise ForbiddenError(\n            'Viewing shared groups requires ownership',\n        )\n\n    return list(self._shares.get(uid, set()))\n</code></pre>"},{"location":"api/exchange/cloud/backend/#academy.exchange.cloud.backend.RedisBackend","title":"RedisBackend","text":"<pre><code>RedisBackend(\n    hostname: str = \"localhost\",\n    port: int = 6379,\n    *,\n    message_size_limit_kb: int = 1024,\n    kwargs: dict[str, Any] | None = None,\n    mailbox_expiration_s: int | None = None,\n    gravestone_expiration_s: int | None = None\n)\n</code></pre> <p>Redis backend of mailboxes.</p> <p>Parameters:</p> <ul> <li> <code>hostname</code>               (<code>str</code>, default:                   <code>'localhost'</code> )           \u2013            <p>Host address of redis.</p> </li> <li> <code>port</code>               (<code>int</code>, default:                   <code>6379</code> )           \u2013            <p>Redis port.</p> </li> <li> <code>message_size_limit_kb</code>               (<code>int</code>, default:                   <code>1024</code> )           \u2013            <p>Maximum message size to allow.</p> </li> <li> <code>kwargs</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Addition arguments to pass to redis session.</p> </li> </ul> Source code in <code>academy/exchange/cloud/backend.py</code> <pre><code>def __init__(  # noqa: PLR0913\n    self,\n    hostname: str = 'localhost',\n    port: int = 6379,\n    *,\n    message_size_limit_kb: int = 1024,\n    kwargs: dict[str, Any] | None = None,\n    mailbox_expiration_s: int | None = None,\n    gravestone_expiration_s: int | None = None,\n) -&gt; None:\n    self.message_size_limit = message_size_limit_kb * KB_TO_BYTES\n\n    if kwargs is None:  # pragma: no branch\n        kwargs = {}\n\n    self._client = redis.asyncio.Redis(\n        host=hostname,\n        port=port,\n        decode_responses=False,\n        **kwargs,\n    )\n    self.mailbox_expiration_s = mailbox_expiration_s\n    self.gravestone_expiration_s = gravestone_expiration_s\n</code></pre>"},{"location":"api/exchange/cloud/backend/#academy.exchange.cloud.backend.RedisBackend.check_mailbox","title":"check_mailbox  <code>async</code>","text":"<pre><code>check_mailbox(\n    client: ClientInfo, uid: EntityId\n) -&gt; MailboxStatus\n</code></pre> <p>Check if a mailbox exists, or is terminated.</p> <p>Parameters:</p> <ul> <li> <code>client</code>               (<code>ClientInfo</code>)           \u2013            <p>Client making the request.</p> </li> <li> <code>uid</code>               (<code>EntityId</code>)           \u2013            <p>Mailbox id to check.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>MailboxStatus</code>           \u2013            <p>The mailbox status.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ForbiddenError</code>             \u2013            <p>If the client does not have the right permissions.</p> </li> </ul> Source code in <code>academy/exchange/cloud/backend.py</code> <pre><code>async def check_mailbox(\n    self,\n    client: ClientInfo,\n    uid: EntityId,\n) -&gt; MailboxStatus:\n    \"\"\"Check if a mailbox exists, or is terminated.\n\n    Args:\n        client: Client making the request.\n        uid: Mailbox id to check.\n\n    Returns:\n        The mailbox status.\n\n    Raises:\n        ForbiddenError: If the client does not have the right permissions.\n    \"\"\"\n    if not await self._has_permissions(client, uid):\n        raise ForbiddenError(\n            'Client does not have correct permissions.',\n        )\n\n    status = await self._client.get(self._active_key(uid))\n    if status is None:\n        return MailboxStatus.MISSING\n    elif status.decode() == MailboxStatus.TERMINATED.value:\n        return MailboxStatus.TERMINATED\n    else:\n        return MailboxStatus.ACTIVE\n</code></pre>"},{"location":"api/exchange/cloud/backend/#academy.exchange.cloud.backend.RedisBackend.create_mailbox","title":"create_mailbox  <code>async</code>","text":"<pre><code>create_mailbox(\n    client: ClientInfo,\n    uid: EntityId,\n    agent: tuple[str, ...] | None = None,\n) -&gt; None\n</code></pre> <p>Create a mailbox is not exists.</p> <p>This method should be idempotent.</p> <p>Parameters:</p> <ul> <li> <code>client</code>               (<code>ClientInfo</code>)           \u2013            <p>Client making the request.</p> </li> <li> <code>uid</code>               (<code>EntityId</code>)           \u2013            <p>Mailbox id to check.</p> </li> <li> <code>agent</code>               (<code>tuple[str, ...] | None</code>, default:                   <code>None</code> )           \u2013            <p>The agent_mro for behavior discovery.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ForbiddenError</code>             \u2013            <p>If the client does not have the right permissions.</p> </li> </ul> Source code in <code>academy/exchange/cloud/backend.py</code> <pre><code>async def create_mailbox(\n    self,\n    client: ClientInfo,\n    uid: EntityId,\n    agent: tuple[str, ...] | None = None,\n) -&gt; None:\n    \"\"\"Create a mailbox is not exists.\n\n    This method should be idempotent.\n\n    Args:\n        client: Client making the request.\n        uid: Mailbox id to check.\n        agent: The agent_mro for behavior discovery.\n\n    Raises:\n        ForbiddenError: If the client does not have the right permissions.\n    \"\"\"\n    if not await self._has_permissions(client, uid):\n        raise ForbiddenError(\n            'Client does not have correct permissions.',\n        )\n\n    await self._client.set(\n        self._active_key(uid),\n        MailboxStatus.ACTIVE.value,\n    )\n\n    if agent is not None:\n        await self._client.set(\n            self._agent_key(uid),\n            ','.join(agent),\n        )\n\n    await self._client.set(\n        self._owner_key(uid),\n        f'{client.client_id}{_OWNER_SUFFIX}',\n    )\n    await self._update_expirations(uid)\n</code></pre>"},{"location":"api/exchange/cloud/backend/#academy.exchange.cloud.backend.RedisBackend.terminate","title":"terminate  <code>async</code>","text":"<pre><code>terminate(client: ClientInfo, uid: EntityId) -&gt; None\n</code></pre> <p>Close a mailbox.</p> <p>For security, the manager should keep a gravestone so the same id cannot be re-registered.</p> <p>Parameters:</p> <ul> <li> <code>client</code>               (<code>ClientInfo</code>)           \u2013            <p>Client making the request.</p> </li> <li> <code>uid</code>               (<code>EntityId</code>)           \u2013            <p>Mailbox id to close.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ForbiddenError</code>             \u2013            <p>If the client does not have the right permissions.</p> </li> </ul> Source code in <code>academy/exchange/cloud/backend.py</code> <pre><code>async def terminate(self, client: ClientInfo, uid: EntityId) -&gt; None:\n    \"\"\"Close a mailbox.\n\n    For security, the manager should keep a gravestone so the same id\n    cannot be re-registered.\n\n    Args:\n        client: Client making the request.\n        uid: Mailbox id to close.\n\n    Raises:\n        ForbiddenError: If the client does not have the right permissions.\n\n    \"\"\"\n    if not await self._has_permissions(client, uid):\n        raise ForbiddenError(\n            'Client does not have correct permissions.',\n        )\n\n    status = await self.check_mailbox(client, uid)\n\n    if status in {MailboxStatus.MISSING, MailboxStatus.TERMINATED}:\n        return\n\n    await self._client.set(\n        self._active_key(uid),\n        MailboxStatus.TERMINATED.value,\n    )\n\n    pending = await self._client.lrange(self._queue_key(uid), 0, -1)  # type: ignore[misc]\n    if self.gravestone_expiration_s is not None:\n        await self._client.expire(\n            self._active_key(uid),\n            self.gravestone_expiration_s,\n        )\n\n    await self._client.delete(self._queue_key(uid))\n    # Sending a close sentinel to the queue is a quick way to force\n    # the entity waiting on messages to the mailbox to stop blocking.\n    # This assumes that only one entity is reading from the mailbox.\n    await self._client.rpush(self._queue_key(uid), _CLOSE_SENTINEL)  # type: ignore[misc]\n    if isinstance(uid, AgentId):\n        await self._client.delete(self._agent_key(uid))\n\n    for raw in pending:\n        message: Message[Any] = Message.model_deserialize(raw)\n        if message.is_request():\n            error = MailboxTerminatedError(uid)\n            body = ErrorResponse(exception=error)\n            response = message.create_response(body)\n            with contextlib.suppress(Exception):\n                await self.put(client, response)\n</code></pre>"},{"location":"api/exchange/cloud/backend/#academy.exchange.cloud.backend.RedisBackend.discover","title":"discover  <code>async</code>","text":"<pre><code>discover(\n    client: ClientInfo, agent: str, allow_subclasses: bool\n) -&gt; list[AgentId[Any]]\n</code></pre> <p>Find mailboxes of matching agent class.</p> <p>Parameters:</p> <ul> <li> <code>client</code>               (<code>ClientInfo</code>)           \u2013            <p>Client making the request.</p> </li> <li> <code>agent</code>               (<code>str</code>)           \u2013            <p>Agent class to search for.</p> </li> <li> <code>allow_subclasses</code>               (<code>bool</code>)           \u2013            <p>Include agents that inherit from the target.</p> </li> </ul> Source code in <code>academy/exchange/cloud/backend.py</code> <pre><code>async def discover(\n    self,\n    client: ClientInfo,\n    agent: str,\n    allow_subclasses: bool,\n) -&gt; list[AgentId[Any]]:\n    \"\"\"Find mailboxes of matching agent class.\n\n    Args:\n        client: Client making the request.\n        agent: Agent class to search for.\n        allow_subclasses: Include agents that inherit from the target.\n    \"\"\"\n    found: list[AgentId[Any]] = []\n    async for key in self._client.scan_iter(\n        'agent:*',\n    ):  # pragma: no branch\n        mro_str = (await self._client.get(key)).decode()\n        assert isinstance(mro_str, str)\n        mro = mro_str.split(',')\n        if agent == mro[0] or (allow_subclasses and agent in mro):\n            aid: AgentId[Any] = AgentId(\n                uid=uuid.UUID(key.decode().split(':')[-1]),\n            )\n            found.append(aid)\n\n    active: list[AgentId[Any]] = []\n    for aid in found:\n        if await self._has_permissions(client, aid):\n            status = await self._client.get(self._active_key(aid))\n            if (\n                status.decode() == MailboxStatus.ACTIVE.value\n            ):  # pragma: no branch\n                active.append(aid)\n\n    return active\n</code></pre>"},{"location":"api/exchange/cloud/backend/#academy.exchange.cloud.backend.RedisBackend.get","title":"get  <code>async</code>","text":"<pre><code>get(\n    client: ClientInfo,\n    uid: EntityId,\n    *,\n    timeout: float | None = None\n) -&gt; Message[Any]\n</code></pre> <p>Get messages from a mailbox.</p> <p>Parameters:</p> <ul> <li> <code>client</code>               (<code>ClientInfo</code>)           \u2013            <p>Client making the request.</p> </li> <li> <code>uid</code>               (<code>EntityId</code>)           \u2013            <p>Mailbox id to get messages.</p> </li> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Time in seconds to wait for message. If None, wait indefinitely.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ForbiddenError</code>             \u2013            <p>If the client does not have the right permissions.</p> </li> <li> <code>BadEntityIdError</code>             \u2013            <p>The mailbox requested does not exist.</p> </li> <li> <code>MailboxTerminatedError</code>             \u2013            <p>The mailbox is closed.</p> </li> <li> <code>TimeoutError</code>             \u2013            <p>There was not message received during the timeout.</p> </li> </ul> Source code in <code>academy/exchange/cloud/backend.py</code> <pre><code>async def get(\n    self,\n    client: ClientInfo,\n    uid: EntityId,\n    *,\n    timeout: float | None = None,\n) -&gt; Message[Any]:\n    \"\"\"Get messages from a mailbox.\n\n    Args:\n        client: Client making the request.\n        uid: Mailbox id to get messages.\n        timeout: Time in seconds to wait for message.\n            If None, wait indefinitely.\n\n    Raises:\n        ForbiddenError: If the client does not have the right permissions.\n        BadEntityIdError: The mailbox requested does not exist.\n        MailboxTerminatedError: The mailbox is closed.\n        TimeoutError: There was not message received during the timeout.\n    \"\"\"\n    if not await self._has_permissions(client, uid):\n        raise ForbiddenError(\n            'Client does not have correct permissions.',\n        )\n\n    _timeout = timeout if timeout is not None else 0\n    status = await self._client.get(\n        self._active_key(uid),\n    )\n    if status is None:\n        raise BadEntityIdError(uid)\n    elif status.decode() == MailboxStatus.TERMINATED.value:\n        raise MailboxTerminatedError(uid)\n\n    await self._update_expirations(uid)\n    if self.mailbox_expiration_s:\n        await self._client.expire(\n            self._queue_key(uid),\n            self.mailbox_expiration_s,\n        )\n\n    raw = await self._client.blpop(  # type: ignore[misc]\n        [self._queue_key(uid)],\n        timeout=_timeout,\n    )\n    if raw is None:\n        raise TimeoutError(\n            f'Timeout waiting for next message for {uid} '\n            f'after {timeout} seconds.',\n        )\n\n    # Only passed one key to blpop to result is [key, item]\n    assert len(raw) == 2  # noqa: PLR2004\n    if raw[1] == _CLOSE_SENTINEL:  # pragma: no cover\n        raise MailboxTerminatedError(uid)\n    return Message.model_deserialize(raw[1])\n</code></pre>"},{"location":"api/exchange/cloud/backend/#academy.exchange.cloud.backend.RedisBackend.put","title":"put  <code>async</code>","text":"<pre><code>put(client: ClientInfo, message: Message[Any]) -&gt; None\n</code></pre> <p>Put a message in a mailbox.</p> <p>Parameters:</p> <ul> <li> <code>client</code>               (<code>ClientInfo</code>)           \u2013            <p>Client making the request.</p> </li> <li> <code>message</code>               (<code>Message[Any]</code>)           \u2013            <p>Message to put in mailbox.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ForbiddenError</code>             \u2013            <p>If the client does not have the right permissions.</p> </li> <li> <code>BadEntityIdError</code>             \u2013            <p>The mailbox requested does not exist.</p> </li> <li> <code>MailboxTerminatedError</code>             \u2013            <p>The mailbox is closed.</p> </li> <li> <code>MessageTooLargeError</code>             \u2013            <p>The message is larger than the message size limit for this exchange.</p> </li> </ul> Source code in <code>academy/exchange/cloud/backend.py</code> <pre><code>async def put(self, client: ClientInfo, message: Message[Any]) -&gt; None:\n    \"\"\"Put a message in a mailbox.\n\n    Args:\n        client: Client making the request.\n        message: Message to put in mailbox.\n\n    Raises:\n        ForbiddenError: If the client does not have the right permissions.\n        BadEntityIdError: The mailbox requested does not exist.\n        MailboxTerminatedError: The mailbox is closed.\n        MessageTooLargeError: The message is larger than the message\n            size limit for this exchange.\n    \"\"\"\n    if not await self._has_permissions(client, message.dest):\n        raise ForbiddenError(\n            'Client does not have correct permissions.',\n        )\n\n    status = await self._client.get(self._active_key(message.dest))\n    if status is None:\n        raise BadEntityIdError(message.dest)\n    elif status.decode() == MailboxStatus.TERMINATED.value:\n        raise MailboxTerminatedError(message.dest)\n\n    serialized = message.model_serialize()\n    if len(serialized) &gt; self.message_size_limit:\n        raise MessageTooLargeError(\n            len(serialized),\n            self.message_size_limit,\n        )\n\n    await self._client.rpush(  # type: ignore[misc]\n        self._queue_key(message.dest),\n        serialized,\n    )\n\n    if self.mailbox_expiration_s:\n        await self._client.expire(\n            self._queue_key(message.dest),\n            self.mailbox_expiration_s,\n            nx=True,\n        )\n</code></pre>"},{"location":"api/exchange/cloud/backend/#academy.exchange.cloud.backend.RedisBackend.share_mailbox","title":"share_mailbox  <code>async</code>","text":"<pre><code>share_mailbox(\n    client: ClientInfo, uid: EntityId, group_uid: str\n) -&gt; None\n</code></pre> <p>Share a mailbox with a Globus group.</p> <p>Parameters:</p> <ul> <li> <code>client</code>               (<code>ClientInfo</code>)           \u2013            <p>Client making the request.</p> </li> <li> <code>group_uid</code>               (<code>str</code>)           \u2013            <p>Group id to share mailbox with.</p> </li> <li> <code>uid</code>               (<code>EntityId</code>)           \u2013            <p>Target Mailbox for sharing</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ForbiddenError</code>             \u2013            <p>If the client does not have the right permissions.</p> </li> </ul> Source code in <code>academy/exchange/cloud/backend.py</code> <pre><code>async def share_mailbox(\n    self,\n    client: ClientInfo,\n    uid: EntityId,\n    group_uid: str,\n) -&gt; None:\n    \"\"\"Share a mailbox with a Globus group.\n\n    Args:\n         client: Client making the request.\n         group_uid: Group id to share mailbox with.\n         uid: Target Mailbox for sharing\n\n    Raises:\n        ForbiddenError: If the client does not have the right permissions.\n    \"\"\"\n    status = await self._client.get(self._active_key(uid))\n    if status is None:\n        raise BadEntityIdError(uid)\n    elif status.decode() == MailboxStatus.TERMINATED.value:\n        raise MailboxTerminatedError(uid)\n\n    if not await self._has_mailbox_ownership(client, uid):\n        raise ForbiddenError(\n            f'{client.client_id} cannot share mailbox '\n            f'{uid} it does not own.',\n        )\n    if group_uid not in client.group_memberships:\n        raise ForbiddenError(\n            f'Owner does not belong to the group {group_uid}',\n        )\n\n    await self._client.sadd(self._share_key(uid), group_uid)  # type: ignore[misc]\n</code></pre>"},{"location":"api/exchange/cloud/backend/#academy.exchange.cloud.backend.RedisBackend.get_mailbox_shares","title":"get_mailbox_shares  <code>async</code>","text":"<pre><code>get_mailbox_shares(\n    client: ClientInfo, uid: EntityId\n) -&gt; list[str]\n</code></pre> <p>Get list of globus groups the mailbox is shared with.</p> <p>Only the owner of the Mailbox is allowed to share with a Globus Group. This method should be idempotent.</p> <p>Parameters:</p> <ul> <li> <code>client</code>               (<code>ClientInfo</code>)           \u2013            <p>Client making the request.</p> </li> <li> <code>uid</code>               (<code>EntityId</code>)           \u2013            <p>Mailbox id to share.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>List of globus groups id strings</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ForbiddenError</code>             \u2013            <p>If the client does not have the right permissions.</p> </li> <li> <code>BadEntityIdError</code>             \u2013            <p>The mailbox requested does not exist.</p> </li> <li> <code>MailboxTerminatedError</code>             \u2013            <p>The mailbox is closed.</p> </li> </ul> Source code in <code>academy/exchange/cloud/backend.py</code> <pre><code>async def get_mailbox_shares(\n    self,\n    client: ClientInfo,\n    uid: EntityId,\n) -&gt; list[str]:\n    \"\"\"Get list of globus groups the mailbox is shared with.\n\n    Only the owner of the Mailbox is allowed to share with a Globus Group.\n    This method should be idempotent.\n\n    Args:\n        client: Client making the request.\n        uid: Mailbox id to share.\n\n    Returns:\n        List of globus groups id strings\n\n    Raises:\n        ForbiddenError: If the client does not have the right permissions.\n        BadEntityIdError: The mailbox requested does not exist.\n        MailboxTerminatedError: The mailbox is closed.\n    \"\"\"\n    status = await self._client.get(self._active_key(uid))\n    if status is None:\n        raise BadEntityIdError(uid)\n    elif status.decode() == MailboxStatus.TERMINATED.value:\n        raise MailboxTerminatedError(uid)\n\n    if not await self._has_mailbox_ownership(client, uid):\n        raise ForbiddenError(\n            'Viewing shared groups requires ownership',\n        )\n\n    _groups = await self._client.smembers(self._share_key(uid))  # type: ignore[misc]\n    groups = [g.decode() for g in _groups]\n    return groups\n</code></pre>"},{"location":"api/exchange/cloud/client/","title":"academy.exchange.cloud.client","text":"<code>academy/exchange/cloud/client.py</code>"},{"location":"api/exchange/cloud/client/#academy.exchange.cloud.client.HttpAgentRegistration","title":"HttpAgentRegistration  <code>dataclass</code>","text":"<pre><code>HttpAgentRegistration(agent_id: AgentId[AgentT])\n</code></pre> <p>               Bases: <code>Generic[AgentT]</code></p> <p>Agent registration for Http exchanges.</p>"},{"location":"api/exchange/cloud/client/#academy.exchange.cloud.client.HttpAgentRegistration.agent_id","title":"agent_id  <code>instance-attribute</code>","text":"<pre><code>agent_id: AgentId[AgentT]\n</code></pre> <p>Unique identifier for the agent created by the exchange.</p>"},{"location":"api/exchange/cloud/client/#academy.exchange.cloud.client.HttpExchangeTransport","title":"HttpExchangeTransport","text":"<pre><code>HttpExchangeTransport(\n    mailbox_id: EntityId,\n    session: ClientSession,\n    connection_info: _HttpConnectionInfo,\n)\n</code></pre> <p>               Bases: <code>ExchangeTransportMixin</code>, <code>NoPickleMixin</code></p> <p>Http exchange client.</p> <p>Parameters:</p> <ul> <li> <code>mailbox_id</code>               (<code>EntityId</code>)           \u2013            <p>Identifier of the mailbox on the exchange. If there is not an id provided, the exchange will create a new client mailbox.</p> </li> <li> <code>session</code>               (<code>ClientSession</code>)           \u2013            <p>Http session.</p> </li> <li> <code>connection_info</code>               (<code>_HttpConnectionInfo</code>)           \u2013            <p>Exchange connection info.</p> </li> </ul> Source code in <code>academy/exchange/cloud/client.py</code> <pre><code>def __init__(\n    self,\n    mailbox_id: EntityId,\n    session: aiohttp.ClientSession,\n    connection_info: _HttpConnectionInfo,\n) -&gt; None:\n    self._mailbox_id = mailbox_id\n    self._session = session\n    self._info = connection_info\n\n    base_url = self._info.url\n    self._mailbox_url = f'{base_url}/mailbox'\n    self._message_url = f'{base_url}/message'\n    self._discover_url = f'{base_url}/discover'\n</code></pre>"},{"location":"api/exchange/cloud/client/#academy.exchange.cloud.client.HttpExchangeTransport.new","title":"new  <code>async</code> <code>classmethod</code>","text":"<pre><code>new(\n    *,\n    connection_info: _HttpConnectionInfo,\n    mailbox_id: EntityId | None = None,\n    name: str | None = None\n) -&gt; Self\n</code></pre> <p>Instantiate a new transport.</p> <p>Parameters:</p> <ul> <li> <code>connection_info</code>               (<code>_HttpConnectionInfo</code>)           \u2013            <p>Exchange connection information.</p> </li> <li> <code>mailbox_id</code>               (<code>EntityId | None</code>, default:                   <code>None</code> )           \u2013            <p>Bind the transport to the specific mailbox. If <code>None</code>, a new user entity will be registered and the transport will be bound to that mailbox.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Display name of the registered entity if <code>mailbox_id</code> is <code>None</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>An instantiated transport bound to a specific mailbox.</p> </li> </ul> Source code in <code>academy/exchange/cloud/client.py</code> <pre><code>@classmethod\nasync def new(\n    cls,\n    *,\n    connection_info: _HttpConnectionInfo,\n    mailbox_id: EntityId | None = None,\n    name: str | None = None,\n) -&gt; Self:\n    \"\"\"Instantiate a new transport.\n\n    Args:\n        connection_info: Exchange connection information.\n        mailbox_id: Bind the transport to the specific mailbox. If `None`,\n            a new user entity will be registered and the transport will be\n            bound to that mailbox.\n        name: Display name of the registered entity if `mailbox_id` is\n            `None`.\n\n    Returns:\n        An instantiated transport bound to a specific mailbox.\n    \"\"\"\n    ssl_verify = connection_info.ssl_verify\n    if ssl_verify is None:  # pragma: no branch\n        scheme = urlparse(connection_info.url).scheme\n        ssl_verify = scheme == 'https'\n\n    session = aiohttp.ClientSession(\n        connector=aiohttp.TCPConnector(ssl=ssl_verify),\n        headers=connection_info.additional_headers,\n        trust_env=True,\n    )\n\n    if mailbox_id is None:\n        mailbox_id = UserId.new(name=name)\n        async with session.post(\n            f'{connection_info.url}/mailbox',\n            json={'mailbox': mailbox_id.model_dump_json()},\n        ) as response:\n            _raise_for_status(response, mailbox_id)\n        logger.info(\n            'Registered %s in exchange',\n            mailbox_id,\n            extra={'academy.mailbox_id': mailbox_id},\n        )\n\n    return cls(mailbox_id, session, connection_info)\n</code></pre>"},{"location":"api/exchange/cloud/client/#academy.exchange.cloud.client.HttpExchangeConsole","title":"HttpExchangeConsole","text":"<pre><code>HttpExchangeConsole(\n    session: ClientSession,\n    connection_info: _HttpConnectionInfo,\n)\n</code></pre> <p>Client for Http/Cloud specific exchange operations.</p> <p>Parameters:</p> <ul> <li> <code>session</code>               (<code>ClientSession</code>)           \u2013            <p>Http session.</p> </li> <li> <code>connection_info</code>               (<code>_HttpConnectionInfo</code>)           \u2013            <p>Exchange connection info.</p> </li> </ul> Source code in <code>academy/exchange/cloud/client.py</code> <pre><code>def __init__(\n    self,\n    session: aiohttp.ClientSession,\n    connection_info: _HttpConnectionInfo,\n) -&gt; None:\n    self._session = session\n    self._info = connection_info\n\n    base_url = self._info.url\n    self._share_url = f'{base_url}/mailbox/share'\n</code></pre>"},{"location":"api/exchange/cloud/client/#academy.exchange.cloud.client.HttpExchangeConsole.new","title":"new  <code>async</code> <code>classmethod</code>","text":"<pre><code>new(*, connection_info: _HttpConnectionInfo) -&gt; Self\n</code></pre> <p>Instantiate a new console.</p> <p>Parameters:</p> <ul> <li> <code>connection_info</code>               (<code>_HttpConnectionInfo</code>)           \u2013            <p>Exchange connection information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>An instantiated transport bound to a specific mailbox.</p> </li> </ul> Source code in <code>academy/exchange/cloud/client.py</code> <pre><code>@classmethod\nasync def new(\n    cls,\n    *,\n    connection_info: _HttpConnectionInfo,\n) -&gt; Self:\n    \"\"\"Instantiate a new console.\n\n    Args:\n        connection_info: Exchange connection information.\n\n    Returns:\n        An instantiated transport bound to a specific mailbox.\n    \"\"\"\n    ssl_verify = connection_info.ssl_verify\n    if ssl_verify is None:  # pragma: no branch\n        scheme = urlparse(connection_info.url).scheme\n        ssl_verify = scheme == 'https'\n\n    session = aiohttp.ClientSession(\n        connector=aiohttp.TCPConnector(ssl=ssl_verify),\n        headers=connection_info.additional_headers,\n        trust_env=True,\n    )\n    return cls(session, connection_info)\n</code></pre>"},{"location":"api/exchange/cloud/client/#academy.exchange.cloud.client.HttpExchangeConsole.share_mailbox","title":"share_mailbox  <code>async</code>","text":"<pre><code>share_mailbox(mailbox_id: EntityId, group_id: UUID) -&gt; None\n</code></pre> <p>Share mailbox with group.</p> <p>Parameters:</p> <ul> <li> <code>mailbox_id</code>               (<code>EntityId</code>)           \u2013            <p>Either AgentId or UserId of mailbox</p> </li> <li> <code>group_id</code>               (<code>UUID</code>)           \u2013            <p>Id of globus group. User must be part of group to share mailbox.</p> </li> </ul> Source code in <code>academy/exchange/cloud/client.py</code> <pre><code>async def share_mailbox(\n    self,\n    mailbox_id: EntityId,\n    group_id: uuid.UUID,\n) -&gt; None:\n    \"\"\"Share mailbox with group.\n\n    Args:\n        mailbox_id: Either AgentId or UserId of mailbox\n        group_id: Id of globus group. User must be part of group to share\n            mailbox.\n    \"\"\"\n    async with self._session.post(\n        self._share_url,\n        json={\n            'mailbox': mailbox_id.model_dump_json(),\n            'group_id': str(group_id),\n        },\n    ) as response:\n        _raise_for_status(response, None, mailbox_id)\n</code></pre>"},{"location":"api/exchange/cloud/client/#academy.exchange.cloud.client.HttpExchangeConsole.get_shared_groups","title":"get_shared_groups  <code>async</code>","text":"<pre><code>get_shared_groups(mailbox_id: EntityId) -&gt; list[UUID]\n</code></pre> <p>Get the groups mailbox is shared with.</p> <p>Parameters:</p> <ul> <li> <code>mailbox_id</code>               (<code>EntityId</code>)           \u2013            <p>Either AgentId or UserId of mailbox</p> </li> </ul> Source code in <code>academy/exchange/cloud/client.py</code> <pre><code>async def get_shared_groups(self, mailbox_id: EntityId) -&gt; list[uuid.UUID]:\n    \"\"\"Get the groups mailbox is shared with.\n\n    Args:\n        mailbox_id: Either AgentId or UserId of mailbox\n    \"\"\"\n    async with self._session.get(\n        self._share_url,\n        json={\n            'mailbox': mailbox_id.model_dump_json(),\n        },\n    ) as response:\n        _raise_for_status(response, None, mailbox_id)\n        groups_str = (await response.json())['group_ids']\n        return [uuid.UUID(group_id) for group_id in groups_str]\n</code></pre>"},{"location":"api/exchange/cloud/client/#academy.exchange.cloud.client.HttpExchangeConsole.close","title":"close  <code>async</code>","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the console session.</p> Source code in <code>academy/exchange/cloud/client.py</code> <pre><code>async def close(self) -&gt; None:\n    \"\"\"Close the console session.\"\"\"\n    await self._session.close()\n</code></pre>"},{"location":"api/exchange/cloud/client/#academy.exchange.cloud.client.HttpExchangeFactory","title":"HttpExchangeFactory","text":"<pre><code>HttpExchangeFactory(\n    url: str,\n    auth_method: Literal[\"globus\"] | None = None,\n    additional_headers: dict[str, str] | None = None,\n    request_timeout_s: float = 60,\n    ssl_verify: bool | None = None,\n)\n</code></pre> <p>               Bases: <code>ExchangeFactory[HttpExchangeTransport]</code></p> <p>Http exchange client factory.</p> <p>Parameters:</p> <ul> <li> <code>url</code>               (<code>str</code>)           \u2013            <p>Address of HTTP exchange</p> </li> <li> <code>auth_method</code>               (<code>Literal['globus'] | None</code>, default:                   <code>None</code> )           \u2013            <p>Method to get authorization headers</p> </li> <li> <code>additional_headers</code>               (<code>dict[str, str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Any other information necessary to communicate with the exchange. Used for passing the Globus bearer token</p> </li> <li> <code>ssl_verify</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Same as requests.Session.verify. If the server's TLS certificate should be validated. Should be true if using HTTPS Only set to false for testing or local development.</p> </li> </ul> Source code in <code>academy/exchange/cloud/client.py</code> <pre><code>def __init__(\n    self,\n    url: str,\n    auth_method: Literal['globus'] | None = None,\n    additional_headers: dict[str, str] | None = None,\n    request_timeout_s: float = 60,\n    ssl_verify: bool | None = None,\n) -&gt; None:\n    if additional_headers is None:\n        additional_headers = {}\n    additional_headers |= get_auth_headers(auth_method)\n\n    self._info = _HttpConnectionInfo(\n        url=url,\n        additional_headers=additional_headers,\n        ssl_verify=ssl_verify,\n        request_timeout_s=request_timeout_s,\n    )\n</code></pre>"},{"location":"api/exchange/cloud/client/#academy.exchange.cloud.client.HttpExchangeFactory.create_agent_client","title":"create_agent_client  <code>async</code>","text":"<pre><code>create_agent_client(\n    registration: AgentRegistration[AgentT],\n    request_handler: RequestHandler[RequestT_co],\n) -&gt; AgentExchangeClient[AgentT, ExchangeTransportT]\n</code></pre> <p>Create a new agent exchange client.</p> <p>An agent must be registered with the exchange before an exchange client can be created. For example: <pre><code>factory = ExchangeFactory(...)\nuser_client = factory.create_user_client()\nregistration = user_client.register_agent(...)\nagent_client = factory.create_agent_client(registration, ...)\n</code></pre></p> <p>Parameters:</p> <ul> <li> <code>registration</code>               (<code>AgentRegistration[AgentT]</code>)           \u2013            <p>Registration information returned by the exchange.</p> </li> <li> <code>request_handler</code>               (<code>RequestHandler[RequestT_co]</code>)           \u2013            <p>Agent request message handler.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AgentExchangeClient[AgentT, ExchangeTransportT]</code>           \u2013            <p>Agent exchange client.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BadEntityIdError</code>             \u2013            <p>If an agent with <code>registration.agent_id</code> is not already registered with the exchange.</p> </li> </ul> Source code in <code>academy/exchange/factory.py</code> <pre><code>async def create_agent_client(\n    self,\n    registration: AgentRegistration[AgentT],\n    request_handler: RequestHandler[RequestT_co],\n) -&gt; AgentExchangeClient[AgentT, ExchangeTransportT]:\n    \"\"\"Create a new agent exchange client.\n\n    An agent must be registered with the exchange before an exchange\n    client can be created. For example:\n    ```python\n    factory = ExchangeFactory(...)\n    user_client = factory.create_user_client()\n    registration = user_client.register_agent(...)\n    agent_client = factory.create_agent_client(registration, ...)\n    ```\n\n    Args:\n        registration: Registration information returned by the exchange.\n        request_handler: Agent request message handler.\n\n    Returns:\n        Agent exchange client.\n\n    Raises:\n        BadEntityIdError: If an agent with `registration.agent_id` is not\n            already registered with the exchange.\n    \"\"\"\n    agent_id: AgentId[AgentT] = registration.agent_id\n    transport = await self._create_transport(\n        mailbox_id=agent_id,\n        registration=registration,\n    )\n    assert transport.mailbox_id == agent_id\n    status = await transport.status(agent_id)\n    if status != MailboxStatus.ACTIVE:\n        await transport.close()\n        raise BadEntityIdError(agent_id)\n    return AgentExchangeClient(\n        agent_id,\n        transport,\n        request_handler=request_handler,\n    )\n</code></pre>"},{"location":"api/exchange/cloud/client/#academy.exchange.cloud.client.HttpExchangeFactory.create_user_client","title":"create_user_client  <code>async</code>","text":"<pre><code>create_user_client(\n    *, name: str | None = None, start_listener: bool = True\n) -&gt; UserExchangeClient[ExchangeTransportT]\n</code></pre> <p>Create a new user in the exchange and associated client.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Display name of the client on the exchange.</p> </li> <li> <code>start_listener</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Start a message listener thread.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>UserExchangeClient[ExchangeTransportT]</code>           \u2013            <p>User exchange client.</p> </li> </ul> Source code in <code>academy/exchange/factory.py</code> <pre><code>async def create_user_client(\n    self,\n    *,\n    name: str | None = None,\n    start_listener: bool = True,\n) -&gt; UserExchangeClient[ExchangeTransportT]:\n    \"\"\"Create a new user in the exchange and associated client.\n\n    Args:\n        name: Display name of the client on the exchange.\n        start_listener: Start a message listener thread.\n\n    Returns:\n        User exchange client.\n    \"\"\"\n    transport = await self._create_transport(mailbox_id=None, name=name)\n    user_id = transport.mailbox_id\n    assert isinstance(user_id, UserId)\n    return UserExchangeClient(\n        user_id,\n        transport,\n        start_listener=start_listener,\n    )\n</code></pre>"},{"location":"api/exchange/cloud/client/#academy.exchange.cloud.client.spawn_http_exchange","title":"spawn_http_exchange","text":"<pre><code>spawn_http_exchange(\n    host: str = \"0.0.0.0\",\n    port: int = 5463,\n    *,\n    level: int | str = WARNING,\n    timeout: float | None = None\n) -&gt; Generator[HttpExchangeFactory]\n</code></pre> <p>Context manager that spawns an HTTP exchange in a subprocess.</p> <p>This function spawns a new process (rather than forking) and wait to return until a connection with the exchange has been established. When exiting the context manager, <code>SIGINT</code> will be sent to the exchange process. If the process does not exit within 5 seconds, it will be killed.</p> Warning <p>The exclusion of authentication and ssl configuration is intentional. This method should only be used for temporary exchanges in trusted environments (i.e. the login node of a cluster).</p> <p>Parameters:</p> <ul> <li> <code>host</code>               (<code>str</code>, default:                   <code>'0.0.0.0'</code> )           \u2013            <p>Host the exchange should listen on.</p> </li> <li> <code>port</code>               (<code>int</code>, default:                   <code>5463</code> )           \u2013            <p>Port the exchange should listen on.</p> </li> <li> <code>level</code>               (<code>int | str</code>, default:                   <code>WARNING</code> )           \u2013            <p>Logging level.</p> </li> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Connection timeout when waiting for exchange to start.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Generator[HttpExchangeFactory]</code>           \u2013            <p>Exchange interface connected to the spawned exchange.</p> </li> </ul> Source code in <code>academy/exchange/cloud/client.py</code> <pre><code>@contextlib.contextmanager\ndef spawn_http_exchange(\n    host: str = '0.0.0.0',\n    port: int = 5463,\n    *,\n    level: int | str = logging.WARNING,\n    timeout: float | None = None,\n) -&gt; Generator[HttpExchangeFactory]:\n    \"\"\"Context manager that spawns an HTTP exchange in a subprocess.\n\n    This function spawns a new process (rather than forking) and wait to\n    return until a connection with the exchange has been established.\n    When exiting the context manager, `SIGINT` will be sent to the exchange\n    process. If the process does not exit within 5 seconds, it will be\n    killed.\n\n    Warning:\n        The exclusion of authentication and ssl configuration is\n        intentional. This method should only be used for temporary exchanges\n        in trusted environments (i.e. the login node of a cluster).\n\n    Args:\n        host: Host the exchange should listen on.\n        port: Port the exchange should listen on.\n        level: Logging level.\n        timeout: Connection timeout when waiting for exchange to start.\n\n    Returns:\n        Exchange interface connected to the spawned exchange.\n    \"\"\"\n    config = ExchangeServingConfig(host=host, port=port, log_level=level)\n\n    # Fork is not safe in multi-threaded context.\n    context = multiprocessing.get_context('spawn')\n    exchange_process = context.Process(target=_run, args=(config,))\n    exchange_process.start()\n\n    logger.info('Starting exchange server...')\n    wait_connection(host, port, timeout=timeout)\n    logger.info('Started exchange server!')\n\n    base_url = f'http://{host}:{port}'\n    factory = HttpExchangeFactory(base_url)\n    try:\n        yield factory\n    finally:\n        logger.info('Terminating exchange server...')\n        wait = 5\n        exchange_process.terminate()\n        exchange_process.join(timeout=wait)\n        if exchange_process.exitcode is None:  # pragma: no cover\n            logger.info(\n                'Killing exchange server after waiting %s seconds',\n                wait,\n                extra={'academy.delay': wait},\n            )\n            exchange_process.kill()\n            exchange_process.join()\n        else:\n            logger.info('Terminated exchange server!')\n        exchange_process.close()\n</code></pre>"},{"location":"api/exchange/cloud/client_info/","title":"academy.exchange.cloud.client_info","text":"<code>academy/exchange/cloud/client_info.py</code>"},{"location":"api/exchange/cloud/client_info/#academy.exchange.cloud.client_info.ClientInfo","title":"ClientInfo  <code>dataclass</code>","text":"<pre><code>ClientInfo(client_id: str, group_memberships: set[str])\n</code></pre> <p>Hold client info including group and membership info.</p>"},{"location":"api/exchange/cloud/config/","title":"academy.exchange.cloud.config","text":"<code>academy/exchange/cloud/config.py</code> <p>Cloud exchange configuration file parsing.</p>"},{"location":"api/exchange/cloud/config/#academy.exchange.cloud.config.ExchangeAuthConfig","title":"ExchangeAuthConfig","text":"<p>               Bases: <code>BaseModel</code></p> <p>Exchange authentication configuration.</p> <p>Attributes:</p> <ul> <li> <code>method</code>               (<code>Literal['globus'] | None</code>)           \u2013            <p>Authentication method.</p> </li> <li> <code>kwargs</code>               (<code>dict[str, Any]</code>)           \u2013            <p>Arbitrary keyword arguments to pass to the authenticator. The kwargs are excluded from the <code>repr()</code> of this class because they often contain secrets.</p> </li> </ul>"},{"location":"api/exchange/cloud/config/#academy.exchange.cloud.config.BackendConfig","title":"BackendConfig","text":"<p>               Bases: <code>Protocol</code></p> <p>Config for backend of storing messages.</p>"},{"location":"api/exchange/cloud/config/#academy.exchange.cloud.config.BackendConfig.get_backend","title":"get_backend  <code>abstractmethod</code>","text":"<pre><code>get_backend() -&gt; MailboxBackend\n</code></pre> <p>Construct an instance of the backend from the config.</p> Source code in <code>academy/exchange/cloud/config.py</code> <pre><code>@abc.abstractmethod\ndef get_backend(self) -&gt; MailboxBackend:\n    \"\"\"Construct an instance of the backend from the config.\"\"\"\n    ...\n</code></pre>"},{"location":"api/exchange/cloud/config/#academy.exchange.cloud.config.PythonBackendConfig","title":"PythonBackendConfig","text":"<p>               Bases: <code>BaseModel</code></p> <p>Config for using PythonBackend.</p>"},{"location":"api/exchange/cloud/config/#academy.exchange.cloud.config.PythonBackendConfig.get_backend","title":"get_backend","text":"<pre><code>get_backend() -&gt; MailboxBackend\n</code></pre> <p>Construct an instance of the backend from the config.</p> Source code in <code>academy/exchange/cloud/config.py</code> <pre><code>def get_backend(self) -&gt; MailboxBackend:\n    \"\"\"Construct an instance of the backend from the config.\"\"\"\n    return PythonBackend()\n</code></pre>"},{"location":"api/exchange/cloud/config/#academy.exchange.cloud.config.RedisBackendConfig","title":"RedisBackendConfig","text":"<p>               Bases: <code>BaseModel</code></p> <p>Config for RedisBackend.</p> <p>Attributes:</p> <ul> <li> <code>hostname</code>               (<code>str</code>)           \u2013            <p>Redis host</p> </li> <li> <code>port</code>               (<code>int</code>)           \u2013            <p>Redis port</p> </li> <li> <code>kwargs</code>               (<code>dict[str, Any]</code>)           \u2013            <p>Any additional args to Redis</p> </li> </ul>"},{"location":"api/exchange/cloud/config/#academy.exchange.cloud.config.RedisBackendConfig.get_backend","title":"get_backend","text":"<pre><code>get_backend() -&gt; MailboxBackend\n</code></pre> <p>Construct an instance of the backend from the config.</p> Source code in <code>academy/exchange/cloud/config.py</code> <pre><code>def get_backend(self) -&gt; MailboxBackend:\n    \"\"\"Construct an instance of the backend from the config.\"\"\"\n    return RedisBackend(\n        self.hostname,\n        self.port,\n        message_size_limit_kb=self.message_size_limit_kb,\n        kwargs=self.kwargs,\n        mailbox_expiration_s=int(self.mailbox_expiration_d * 24 * 2600),\n        gravestone_expiration_s=int(\n            self.gravestone_expiration_d * 24 * 3600,\n        ),\n    )\n</code></pre>"},{"location":"api/exchange/cloud/config/#academy.exchange.cloud.config.ExchangeServingConfig","title":"ExchangeServingConfig","text":"<p>               Bases: <code>BaseModel</code></p> <p>Exchange serving configuration.</p> <p>Attributes:</p> <ul> <li> <code>host</code>               (<code>str</code>)           \u2013            <p>Network interface the server binds to.</p> </li> <li> <code>port</code>               (<code>int</code>)           \u2013            <p>Network port the server binds to.</p> </li> <li> <code>certfile</code>               (<code>str | None</code>)           \u2013            <p>Certificate file (PEM format) use to enable TLS.</p> </li> <li> <code>keyfile</code>               (<code>str | None</code>)           \u2013            <p>Private key file. If not specified, the key will be taken from the certfile.</p> </li> <li> <code>auth</code>               (<code>ExchangeAuthConfig</code>)           \u2013            <p>Authentication configuration.</p> </li> <li> <code>log_file</code>               (<code>str | None</code>)           \u2013            <p>Location to write logs.</p> </li> <li> <code>log_level</code>               (<code>int | str</code>)           \u2013            <p>Verbosity of logs.</p> </li> </ul>"},{"location":"api/exchange/cloud/config/#academy.exchange.cloud.config.ExchangeServingConfig.from_toml","title":"from_toml  <code>classmethod</code>","text":"<pre><code>from_toml(filepath: str | Path) -&gt; Self\n</code></pre> <p>Parse an TOML config file.</p> Example <p>Minimal config without SSL and without authentication. exchange.toml<pre><code>port = 8700\n</code></pre></p> <pre><code>from academy_exchange.config import ExchangeServingConfig\n\nconfig = ExchangeServingConfig.from_toml('exchange.toml')\n</code></pre> Example <p>Serve with SSL and Globus Auth. relay.toml<pre><code>host = \"0.0.0.0\"\nport = 8700\ncertfile = \"/path/to/cert.pem\"\nkeyfile = \"/path/to/privkey.pem\"\n\n[auth]\nmethod = \"globus\"\n\n[auth.kwargs]\nclient_id = \"...\"\nclient_secret = \"...\"\n</code></pre></p> Note <p>Omitted values will be set to their defaults (if they are an optional value with a default). relay.toml<pre><code>[serving]\ncertfile = \"/path/to/cert.pem\"\n</code></pre></p> <pre><code>from academy_exchange.config import ExchangeServingConfig\n\nconfig = ExchangeServingConfig.from_config('relay.toml')\nassert config.certfile == '/path/to/cert.pem'\nassert config.keyfile is None\n</code></pre> Source code in <code>academy/exchange/cloud/config.py</code> <pre><code>@classmethod\ndef from_toml(cls, filepath: str | pathlib.Path) -&gt; Self:\n    \"\"\"Parse an TOML config file.\n\n    Example:\n        Minimal config without SSL and without authentication.\n        ```toml title=\"exchange.toml\"\n        port = 8700\n        ```\n\n        ```python\n        from academy_exchange.config import ExchangeServingConfig\n\n        config = ExchangeServingConfig.from_toml('exchange.toml')\n        ```\n\n    Example:\n        Serve with SSL and Globus Auth.\n        ```toml title=\"relay.toml\"\n        host = \"0.0.0.0\"\n        port = 8700\n        certfile = \"/path/to/cert.pem\"\n        keyfile = \"/path/to/privkey.pem\"\n\n        [auth]\n        method = \"globus\"\n\n        [auth.kwargs]\n        client_id = \"...\"\n        client_secret = \"...\"\n        ```\n\n    Note:\n        Omitted values will be set to their defaults (if they are an\n        optional value with a default).\n        ```toml title=\"relay.toml\"\n        [serving]\n        certfile = \"/path/to/cert.pem\"\n        ```\n\n        ```python\n        from academy_exchange.config import ExchangeServingConfig\n\n        config = ExchangeServingConfig.from_config('relay.toml')\n        assert config.certfile == '/path/to/cert.pem'\n        assert config.keyfile is None\n        ```\n    \"\"\"\n    with open(filepath, 'rb') as f:\n        return load(cls, f)\n</code></pre>"},{"location":"api/exchange/cloud/config/#academy.exchange.cloud.config.load","title":"load","text":"<pre><code>load(model: type[BaseModelT], fp: BinaryIO) -&gt; BaseModelT\n</code></pre> <p>Parse TOML from a binary file to a data class.</p> <p>Parameters:</p> <ul> <li> <code>model</code>               (<code>type[BaseModelT]</code>)           \u2013            <p>Config model type to parse TOML using.</p> </li> <li> <code>fp</code>               (<code>BinaryIO</code>)           \u2013            <p>File-like bytes stream to read in.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>BaseModelT</code>           \u2013            <p>Model initialized from TOML file.</p> </li> </ul> Source code in <code>academy/exchange/cloud/config.py</code> <pre><code>def load(model: type[BaseModelT], fp: BinaryIO) -&gt; BaseModelT:\n    \"\"\"Parse TOML from a binary file to a data class.\n\n    Args:\n        model: Config model type to parse TOML using.\n        fp: File-like bytes stream to read in.\n\n    Returns:\n        Model initialized from TOML file.\n    \"\"\"\n    return loads(model, fp.read().decode())\n</code></pre>"},{"location":"api/exchange/cloud/config/#academy.exchange.cloud.config.loads","title":"loads","text":"<pre><code>loads(model: type[BaseModelT], data: str) -&gt; BaseModelT\n</code></pre> <p>Parse TOML string to data class.</p> <p>Parameters:</p> <ul> <li> <code>model</code>               (<code>type[BaseModelT]</code>)           \u2013            <p>Config model type to parse TOML using.</p> </li> <li> <code>data</code>               (<code>str</code>)           \u2013            <p>TOML string to parse.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>BaseModelT</code>           \u2013            <p>Model initialized from TOML file.</p> </li> </ul> Source code in <code>academy/exchange/cloud/config.py</code> <pre><code>def loads(model: type[BaseModelT], data: str) -&gt; BaseModelT:\n    \"\"\"Parse TOML string to data class.\n\n    Args:\n        model: Config model type to parse TOML using.\n        data: TOML string to parse.\n\n    Returns:\n        Model initialized from TOML file.\n    \"\"\"\n    data_dict = tomllib.loads(data)\n    return model.model_validate(data_dict)\n</code></pre>"},{"location":"api/exchange/cloud/globus/","title":"academy.exchange.cloud.globus","text":"<code>academy/exchange/cloud/globus.py</code>"},{"location":"api/exchange/cloud/globus/#academy.exchange.cloud.globus.AcademyAPIError","title":"AcademyAPIError","text":"<p>               Bases: <code>GlobusAPIError</code></p> <p>Error class to represent error responses from Academy.</p>"},{"location":"api/exchange/cloud/globus/#academy.exchange.cloud.globus.AcademyGlobusClient","title":"AcademyGlobusClient","text":"<p>               Bases: <code>BaseClient</code></p> <p>A globus service client to make requests to hosted exchange.</p> <p>The GlobusExchangeClient acts as a wrapper through which authenticated requests are issued. The exchange automatically handles things like retrying, refreshing tokens, and exponential backoff. The <code>BaseClient</code> is implemented using requests, so calls are synchronous, and must be run within a thread when using asyncio.</p>"},{"location":"api/exchange/cloud/globus/#academy.exchange.cloud.globus.GlobusAgentRegistration","title":"GlobusAgentRegistration  <code>dataclass</code>","text":"<pre><code>GlobusAgentRegistration(\n    agent_id: AgentId[AgentT],\n    client_id: UUID,\n    token: str,\n    secret: str,\n)\n</code></pre> <p>               Bases: <code>Generic[AgentT]</code></p> <p>Agent registration for hosted globus exchange.</p>"},{"location":"api/exchange/cloud/globus/#academy.exchange.cloud.globus.GlobusAgentRegistration.agent_id","title":"agent_id  <code>instance-attribute</code>","text":"<pre><code>agent_id: AgentId[AgentT]\n</code></pre> <p>Unique identifier for the agent created by the exchange.</p>"},{"location":"api/exchange/cloud/globus/#academy.exchange.cloud.globus.GlobusAgentRegistration.client_id","title":"client_id  <code>instance-attribute</code>","text":"<pre><code>client_id: UUID\n</code></pre> <p>Client ID of Globus resource server.</p> <p>Each agent is a resources server.  This allows the agent to exchange delegated tokens to act on the exchange on behalf of the client, and to create it's own delegated tokens so other agents can act on its behalf.</p>"},{"location":"api/exchange/cloud/globus/#academy.exchange.cloud.globus.GlobusAgentRegistration.token","title":"token  <code>instance-attribute</code>","text":"<pre><code>token: str\n</code></pre> <p>Auth. token provided by launching client (user or another agent).</p>"},{"location":"api/exchange/cloud/globus/#academy.exchange.cloud.globus.GlobusAgentRegistration.secret","title":"secret  <code>instance-attribute</code>","text":"<pre><code>secret: str\n</code></pre> <p>Secret for agent to use to authenticate itself with Globus Auth.</p> <p>Agents are created as hybrid resource servers within the Globus ecosystem. This allows them to use delegated tokens, but also requires the them to be able to store secrets. In order to support the launching of agents, we pass a secret as part of the agent initialization. We assume the security of the launching channel (typically Globus Compute in the Academy ecosystem).</p>"},{"location":"api/exchange/cloud/globus/#academy.exchange.cloud.globus.GlobusExchangeTransport","title":"GlobusExchangeTransport","text":"<pre><code>GlobusExchangeTransport(\n    mailbox_id: EntityId,\n    *,\n    project_id: UUID,\n    app: GlobusApp | None = None,\n    authorizer: GlobusAuthorizer | None = None,\n    client_params: dict[str, Any] | None = None\n)\n</code></pre> <p>               Bases: <code>ExchangeTransportMixin</code>, <code>NoPickleMixin</code></p> <p>Globus exchange client.</p> <p>Parameters:</p> <ul> <li> <code>mailbox_id</code>               (<code>EntityId</code>)           \u2013            <p>Identifier of the mailbox on the exchange. If there is not an id provided, the exchange will create a new client mailbox.</p> </li> <li> <code>project_id</code>               (<code>UUID</code>)           \u2013            <p>Globus Identifier of project to create agents under.</p> </li> <li> <code>app</code>               (<code>GlobusApp | None</code>, default:                   <code>None</code> )           \u2013            <p>For user authorization through token retrieval.</p> </li> <li> <code>authorizer</code>               (<code>GlobusAuthorizer | None</code>, default:                   <code>None</code> )           \u2013            <p>For service authorization through token retrieval.</p> </li> <li> <code>client_params</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional parameters for globus client.</p> </li> </ul> Source code in <code>academy/exchange/cloud/globus.py</code> <pre><code>def __init__(\n    self,\n    mailbox_id: EntityId,\n    *,\n    project_id: uuid.UUID,\n    app: GlobusApp | None = None,\n    authorizer: GlobusAuthorizer | None = None,\n    client_params: dict[str, Any] | None = None,\n) -&gt; None:\n    self._mailbox_id = mailbox_id\n    self.project = project_id\n    self.child_clients: list[uuid.UUID] = []\n    self.client_params = client_params or {}\n\n    self.login_time = datetime.min\n    self._app = app\n    self._authorizer = authorizer\n    self._local_data = threading.local()\n    self.executor = ThreadPoolExecutor(\n        thread_name_prefix='exchange-globus-thread',\n    )\n</code></pre>"},{"location":"api/exchange/cloud/globus/#academy.exchange.cloud.globus.GlobusExchangeTransport.exchange_client","title":"exchange_client  <code>property</code>","text":"<pre><code>exchange_client: AcademyGlobusClient\n</code></pre> <p>A thread local copy of the Globus AuthClient.</p>"},{"location":"api/exchange/cloud/globus/#academy.exchange.cloud.globus.GlobusExchangeTransport.auth_client","title":"auth_client  <code>property</code>","text":"<pre><code>auth_client: AuthClient\n</code></pre> <p>A thread local copy of the Globus AuthClient.</p>"},{"location":"api/exchange/cloud/globus/#academy.exchange.cloud.globus.GlobusExchangeTransport.new","title":"new  <code>async</code> <code>classmethod</code>","text":"<pre><code>new(\n    *,\n    project_id: UUID,\n    app: GlobusApp | None = None,\n    authorizer: GlobusAuthorizer | None = None,\n    mailbox_id: EntityId | None = None,\n    name: str | None = None,\n    client_params: dict[str, Any] | None = None\n) -&gt; Self\n</code></pre> <p>Instantiate a new transport.</p> <p>Parameters:</p> <ul> <li> <code>project_id</code>               (<code>UUID</code>)           \u2013            <p>Globus Identifier of project to create agents under.</p> </li> <li> <code>app</code>               (<code>GlobusApp | None</code>, default:                   <code>None</code> )           \u2013            <p>For user authorization through token retrieval</p> </li> <li> <code>authorizer</code>               (<code>GlobusAuthorizer | None</code>, default:                   <code>None</code> )           \u2013            <p>For service authorization through token retrieval</p> </li> <li> <code>mailbox_id</code>               (<code>EntityId | None</code>, default:                   <code>None</code> )           \u2013            <p>Bind the transport to the specific mailbox. If <code>None</code>, a new user entity will be registered and the transport will be bound to that mailbox.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Display name of the registered entity if <code>mailbox_id</code> is <code>None</code>.</p> </li> <li> <code>client_params</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional parameters for globus client.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>An instantiated transport bound to a specific mailbox.</p> </li> </ul> Source code in <code>academy/exchange/cloud/globus.py</code> <pre><code>@classmethod\nasync def new(  # noqa: PLR0913\n    cls,\n    *,\n    project_id: uuid.UUID,\n    app: GlobusApp | None = None,\n    authorizer: GlobusAuthorizer | None = None,\n    mailbox_id: EntityId | None = None,\n    name: str | None = None,\n    client_params: dict[str, Any] | None = None,\n) -&gt; Self:\n    \"\"\"Instantiate a new transport.\n\n    Args:\n        project_id: Globus Identifier of project to create agents under.\n        app: For user authorization through token retrieval\n        authorizer: For service authorization through token retrieval\n        mailbox_id: Bind the transport to the specific mailbox. If `None`,\n            a new user entity will be registered and the transport will be\n            bound to that mailbox.\n        name: Display name of the registered entity if `mailbox_id` is\n            `None`.\n        client_params: Additional parameters for globus client.\n\n    Returns:\n        An instantiated transport bound to a specific mailbox.\n    \"\"\"\n    loop = asyncio.get_running_loop()\n\n    if mailbox_id is None:\n        mailbox_id = UserId.new(name=name)\n        client = cls(\n            mailbox_id,\n            project_id=project_id,\n            app=app,\n            authorizer=authorizer,\n            client_params=client_params,\n        )\n        await loop.run_in_executor(\n            client.executor,\n            client._register_client,\n        )\n        logger.info(\n            'Registered %s in exchange',\n            mailbox_id,\n            extra={'academy.mailbox_id': mailbox_id},\n        )\n        return client\n\n    return cls(\n        mailbox_id,\n        project_id=project_id,\n        app=app,\n        authorizer=authorizer,\n        client_params=client_params,\n    )\n</code></pre>"},{"location":"api/exchange/cloud/globus/#academy.exchange.cloud.globus.GlobusExchangeFactory","title":"GlobusExchangeFactory","text":"<pre><code>GlobusExchangeFactory(\n    project_id: UUID,\n    client_params: dict[str, Any] | None = None,\n)\n</code></pre> <p>               Bases: <code>ExchangeFactory[GlobusExchangeTransport]</code></p> <p>Globus exchange client factory.</p> <p>Parameters:</p> <ul> <li> <code>project_id</code>               (<code>UUID</code>)           \u2013            <p>Project to create new clients under. Must be able to authenticate as a administrator.</p> </li> <li> <code>client_params</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional parameters for globus client.</p> </li> </ul> Source code in <code>academy/exchange/cloud/globus.py</code> <pre><code>def __init__(\n    self,\n    project_id: uuid.UUID,\n    client_params: dict[str, Any] | None = None,\n) -&gt; None:\n    self.project = project_id\n    self.client_params = client_params\n</code></pre>"},{"location":"api/exchange/cloud/globus/#academy.exchange.cloud.globus.GlobusExchangeFactory.create_agent_client","title":"create_agent_client  <code>async</code>","text":"<pre><code>create_agent_client(\n    registration: AgentRegistration[AgentT],\n    request_handler: RequestHandler[RequestT_co],\n) -&gt; AgentExchangeClient[AgentT, ExchangeTransportT]\n</code></pre> <p>Create a new agent exchange client.</p> <p>An agent must be registered with the exchange before an exchange client can be created. For example: <pre><code>factory = ExchangeFactory(...)\nuser_client = factory.create_user_client()\nregistration = user_client.register_agent(...)\nagent_client = factory.create_agent_client(registration, ...)\n</code></pre></p> <p>Parameters:</p> <ul> <li> <code>registration</code>               (<code>AgentRegistration[AgentT]</code>)           \u2013            <p>Registration information returned by the exchange.</p> </li> <li> <code>request_handler</code>               (<code>RequestHandler[RequestT_co]</code>)           \u2013            <p>Agent request message handler.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AgentExchangeClient[AgentT, ExchangeTransportT]</code>           \u2013            <p>Agent exchange client.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BadEntityIdError</code>             \u2013            <p>If an agent with <code>registration.agent_id</code> is not already registered with the exchange.</p> </li> </ul> Source code in <code>academy/exchange/factory.py</code> <pre><code>async def create_agent_client(\n    self,\n    registration: AgentRegistration[AgentT],\n    request_handler: RequestHandler[RequestT_co],\n) -&gt; AgentExchangeClient[AgentT, ExchangeTransportT]:\n    \"\"\"Create a new agent exchange client.\n\n    An agent must be registered with the exchange before an exchange\n    client can be created. For example:\n    ```python\n    factory = ExchangeFactory(...)\n    user_client = factory.create_user_client()\n    registration = user_client.register_agent(...)\n    agent_client = factory.create_agent_client(registration, ...)\n    ```\n\n    Args:\n        registration: Registration information returned by the exchange.\n        request_handler: Agent request message handler.\n\n    Returns:\n        Agent exchange client.\n\n    Raises:\n        BadEntityIdError: If an agent with `registration.agent_id` is not\n            already registered with the exchange.\n    \"\"\"\n    agent_id: AgentId[AgentT] = registration.agent_id\n    transport = await self._create_transport(\n        mailbox_id=agent_id,\n        registration=registration,\n    )\n    assert transport.mailbox_id == agent_id\n    status = await transport.status(agent_id)\n    if status != MailboxStatus.ACTIVE:\n        await transport.close()\n        raise BadEntityIdError(agent_id)\n    return AgentExchangeClient(\n        agent_id,\n        transport,\n        request_handler=request_handler,\n    )\n</code></pre>"},{"location":"api/exchange/cloud/globus/#academy.exchange.cloud.globus.GlobusExchangeFactory.create_user_client","title":"create_user_client  <code>async</code>","text":"<pre><code>create_user_client(\n    *, name: str | None = None, start_listener: bool = True\n) -&gt; UserExchangeClient[ExchangeTransportT]\n</code></pre> <p>Create a new user in the exchange and associated client.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Display name of the client on the exchange.</p> </li> <li> <code>start_listener</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Start a message listener thread.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>UserExchangeClient[ExchangeTransportT]</code>           \u2013            <p>User exchange client.</p> </li> </ul> Source code in <code>academy/exchange/factory.py</code> <pre><code>async def create_user_client(\n    self,\n    *,\n    name: str | None = None,\n    start_listener: bool = True,\n) -&gt; UserExchangeClient[ExchangeTransportT]:\n    \"\"\"Create a new user in the exchange and associated client.\n\n    Args:\n        name: Display name of the client on the exchange.\n        start_listener: Start a message listener thread.\n\n    Returns:\n        User exchange client.\n    \"\"\"\n    transport = await self._create_transport(mailbox_id=None, name=name)\n    user_id = transport.mailbox_id\n    assert isinstance(user_id, UserId)\n    return UserExchangeClient(\n        user_id,\n        transport,\n        start_listener=start_listener,\n    )\n</code></pre>"},{"location":"api/exchange/cloud/login/","title":"academy.exchange.cloud.login","text":"<code>academy/exchange/cloud/login.py</code> <p>Create <code>GlobusApp</code> instances.</p> <p>Taken from: https://github.com/proxystore/proxystore/blob/e296f937d913cae02f87ab35112fd4c8351860b0/proxystore/globus/app.py</p>"},{"location":"api/exchange/cloud/login/#academy.exchange.cloud.login.get_token_storage","title":"get_token_storage","text":"<pre><code>get_token_storage(\n    filepath: str | Path | None = None,\n    *,\n    namespace: str = \"DEFAULT\"\n) -&gt; SafeSQLiteTokenStorage\n</code></pre> <p>Create token storage adapter.</p> <p>Parameters:</p> <ul> <li> <code>filepath</code>               (<code>str | Path | None</code>, default:                   <code>None</code> )           \u2013            <p>Name of the database file. If not provided, defaults to a file in the Academy home directory specified by ACADEMY_HOME.</p> </li> <li> <code>namespace</code>               (<code>str</code>, default:                   <code>'DEFAULT'</code> )           \u2013            <p>Optional namespace to use within the database for partitioning token data.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>SafeSQLiteTokenStorage</code>           \u2013            <p>Token storage.</p> </li> </ul> Source code in <code>academy/exchange/cloud/login.py</code> <pre><code>def get_token_storage(\n    filepath: str | pathlib.Path | None = None,\n    *,\n    namespace: str = 'DEFAULT',\n) -&gt; SafeSQLiteTokenStorage:\n    \"\"\"Create token storage adapter.\n\n    Args:\n        filepath: Name of the database file. If not provided, defaults to a\n            file in the Academy home directory specified by ACADEMY_HOME.\n        namespace: Optional namespace to use within the database for\n            partitioning token data.\n\n    Returns:\n        Token storage.\n    \"\"\"\n    if filepath is None:\n        default = os.path.join(\n            os.path.expanduser('~/local/share'),\n            _APP_NAME,\n        )\n        basepath = os.environ.get('ACADEMY_HOME', default=default)\n        filepath = os.path.join(basepath, _TOKENS_FILE)\n\n    filepath = pathlib.Path(filepath)\n    filepath.parent.mkdir(parents=True, exist_ok=True)\n    return SafeSQLiteTokenStorage(filepath, namespace=namespace)\n</code></pre>"},{"location":"api/exchange/cloud/login/#academy.exchange.cloud.login.get_client_credentials_from_env","title":"get_client_credentials_from_env","text":"<pre><code>get_client_credentials_from_env() -&gt; tuple[str, str]\n</code></pre> <p>Read the Globus Client ID and secret from the environment.</p> <p>The Client ID should be set to <code>ACADEMY_GLOBUS_CLIENT_ID</code> and the secret to <code>ACADEMY_GLOBUS_CLIENT_SECRET</code>.</p> Note <p>This function performs no validation on the values of the variables.</p> <p>Returns:</p> <ul> <li> <code>tuple[str, str]</code>           \u2013            <p>Tuple containing the client ID and secret.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>if one of the environment variables is set.</p> </li> </ul> Source code in <code>academy/exchange/cloud/login.py</code> <pre><code>def get_client_credentials_from_env() -&gt; tuple[str, str]:\n    \"\"\"Read the Globus Client ID and secret from the environment.\n\n    The Client ID should be set to `ACADEMY_GLOBUS_CLIENT_ID` and\n    the secret to `ACADEMY_GLOBUS_CLIENT_SECRET`.\n\n    Note:\n        This function performs no validation on the values of the variables.\n\n    Returns:\n        Tuple containing the client ID and secret.\n\n    Raises:\n        ValueError: if one of the environment variables is set.\n    \"\"\"\n    try:\n        client_id = os.environ[ACADEMY_GLOBUS_CLIENT_ID_ENV_NAME]\n        client_secret = os.environ[ACADEMY_GLOBUS_CLIENT_SECRET_ENV_NAME]\n    except KeyError as e:\n        raise ValueError(\n            f'Both {ACADEMY_GLOBUS_CLIENT_ID_ENV_NAME} and '\n            f'{ACADEMY_GLOBUS_CLIENT_SECRET_ENV_NAME} must be set to '\n            'use a client identity. Either set both environment variables '\n            'or unset both to use the normal login flow.',\n        ) from e\n\n    return client_id, client_secret\n</code></pre>"},{"location":"api/exchange/cloud/login/#academy.exchange.cloud.login.get_globus_app","title":"get_globus_app","text":"<pre><code>get_globus_app() -&gt; GlobusApp\n</code></pre> <p>Get a Globus App based on the environment.</p> <p>If a client ID and secret are set in the environment, returns a <code>ClientApp</code> using <code>get_client_app()</code>. Otherwise returns a <code>UserApp</code> using <code>get_user_app()</code>.</p> <p>Returns:</p> <ul> <li> <code>GlobusApp</code>           \u2013            <p>Initialized app.</p> </li> </ul> Source code in <code>academy/exchange/cloud/login.py</code> <pre><code>def get_globus_app() -&gt; GlobusApp:\n    \"\"\"Get a Globus App based on the environment.\n\n    If a client ID and secret are set in the environment, returns a\n    [`ClientApp`][globus_sdk.ClientApp] using\n    [`get_client_app()`][academy.exchange.cloud.login.get_client_app].\n    Otherwise returns a [`UserApp`][globus_sdk.UserApp] using\n    [`get_user_app()`][academy.exchange.cloud.login.get_user_app].\n\n    Returns:\n        Initialized app.\n    \"\"\"\n    if is_client_login():\n        return get_client_app()\n    return get_user_app()\n</code></pre>"},{"location":"api/exchange/cloud/login/#academy.exchange.cloud.login.get_client_app","title":"get_client_app","text":"<pre><code>get_client_app(\n    client_id: str | None = None,\n    client_secret: str | None = None,\n) -&gt; ClientApp\n</code></pre> <p>Get a Client Globus App.</p> <p>Parameters:</p> <ul> <li> <code>client_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Client ID. If one or both of the <code>client_id</code> and <code>client_secret</code> are not provided, the values will be read from the environment using <code>get_client_credentials_from_env()</code>.</p> </li> <li> <code>client_secret</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Client secret. See above.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ClientApp</code>           \u2013            <p>Initialized app.</p> </li> </ul> Source code in <code>academy/exchange/cloud/login.py</code> <pre><code>def get_client_app(\n    client_id: str | None = None,\n    client_secret: str | None = None,\n) -&gt; ClientApp:\n    \"\"\"Get a Client Globus App.\n\n    Args:\n        client_id: Client ID. If one or both of the `client_id` and\n            `client_secret` are not provided, the values will be read from\n            the environment using\n            [`get_client_credentials_from_env()`][academy.exchange.cloud.login.get_client_credentials_from_env].\n        client_secret: Client secret. See above.\n\n    Returns:\n        Initialized app.\n    \"\"\"\n    if client_id is None or client_secret is None:\n        client_id, client_secret = get_client_credentials_from_env()\n\n    config = GlobusAppConfig(\n        token_storage=get_token_storage(),\n        request_refresh_tokens=True,\n    )\n\n    return ClientApp(\n        app_name=_APP_NAME,\n        client_id=client_id,\n        client_secret=client_secret,\n        config=config,\n    )\n</code></pre>"},{"location":"api/exchange/cloud/login/#academy.exchange.cloud.login.get_user_app","title":"get_user_app","text":"<pre><code>get_user_app() -&gt; UserApp\n</code></pre> <p>Get a User Globus App.</p> <p>The <code>UserApp</code> will automatically perform an interactive flow with the user as needed.</p> <p>Returns:</p> <ul> <li> <code>UserApp</code>           \u2013            <p>Initialized app.</p> </li> </ul> Source code in <code>academy/exchange/cloud/login.py</code> <pre><code>def get_user_app() -&gt; UserApp:\n    \"\"\"Get a User Globus App.\n\n    The [`UserApp`][globus_sdk.UserApp] will\n    automatically perform an interactive flow with the user as needed.\n\n    Returns:\n        Initialized app.\n    \"\"\"\n    config = GlobusAppConfig(\n        login_flow_manager=_CustomLoginFlowManager,\n        token_storage=get_token_storage(),\n        request_refresh_tokens=True,\n    )\n\n    return UserApp(\n        app_name=_APP_NAME,\n        client_id=ACADEMY_GLOBUS_CLIENT_ID,\n        config=config,\n    )\n</code></pre>"},{"location":"api/exchange/cloud/login/#academy.exchange.cloud.login.is_client_login","title":"is_client_login","text":"<pre><code>is_client_login() -&gt; bool\n</code></pre> <p>Check if Globus client identity environment variables are set.</p> <p>Based on the Globus Compute SDK's <code>is_client_login()</code>.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p><code>True</code> if <code>ACADEMY_GLOBUS_CLIENT_ID</code> and         <code>ACADEMY_GLOBUS_CLIENT_SECRET</code> are set.</p> </li> </ul> Source code in <code>academy/exchange/cloud/login.py</code> <pre><code>def is_client_login() -&gt; bool:\n    \"\"\"Check if Globus client identity environment variables are set.\n\n    Based on the Globus Compute SDK's\n    [`is_client_login()`](https://github.com/funcx-faas/funcX/blob/8f5b59075ae6f8e8b8b13fe1b91430271f4e0c3c/compute_sdk/globus_compute_sdk/sdk/login_manager/client_login.py#L24-L38){target=_blank}.\n\n    Returns:\n        `True` if `ACADEMY_GLOBUS_CLIENT_ID` and \\\n        `ACADEMY_GLOBUS_CLIENT_SECRET` are set.\n    \"\"\"\n    try:\n        get_client_credentials_from_env()\n    except ValueError:\n        return False\n    else:\n        return True\n</code></pre>"},{"location":"api/exchange/cloud/login/#academy.exchange.cloud.login.get_auth_headers","title":"get_auth_headers","text":"<pre><code>get_auth_headers(\n    method: Literal[\"globus\"] | None, **kwargs: Any\n) -&gt; dict[str, str]\n</code></pre> <p>Client utility method to perform authentication and get headers.</p> Source code in <code>academy/exchange/cloud/login.py</code> <pre><code>def get_auth_headers(\n    method: Literal['globus'] | None,\n    **kwargs: Any,\n) -&gt; dict[str, str]:\n    \"\"\"Client utility method to perform authentication and get headers.\"\"\"\n    if method is None:\n        return {}\n    elif method == 'globus':\n        app = get_globus_app()\n        app.add_scope_requirements(\n            {\n                AcademyExchangeScopes.resource_server: [\n                    AcademyExchangeScopes.academy_exchange,\n                ],\n            },\n        )\n        authorizer = app.get_authorizer(\n            AcademyExchangeScopes.resource_server,\n        )\n\n        bearer = authorizer.get_authorization_header()\n        assert bearer is not None\n        return {'Authorization': bearer}\n    else:\n        raise AssertionError('Unreachable.')\n</code></pre>"},{"location":"api/exchange/cloud/scopes/","title":"academy.exchange.cloud.scopes","text":"<code>academy/exchange/cloud/scopes.py</code>"},{"location":"api/exchange/cloud/scopes/#academy.exchange.cloud.scopes.get_academy_exchange_client_id","title":"get_academy_exchange_client_id","text":"<pre><code>get_academy_exchange_client_id() -&gt; str\n</code></pre> <p>Get the client id of the academy_exchange.</p> <p>The environment variable can be used for testing, otherwise the default value is the id of the hosted exchange.</p> Source code in <code>academy/exchange/cloud/scopes.py</code> <pre><code>def get_academy_exchange_client_id() -&gt; str:\n    \"\"\"Get the client id of the academy_exchange.\n\n    The environment variable can be used for testing, otherwise the\n    default value is the id of the hosted exchange.\n    \"\"\"\n    try:\n        return os.environ[ACADEMY_EXCHANGE_CLIENT_ID_ENV_NAME]\n    except KeyError:\n        return DEFAULT_EXCHANGE_CLIENT_ID\n</code></pre>"},{"location":"api/exchange/cloud/scopes/#academy.exchange.cloud.scopes.get_academy_exchange_secret","title":"get_academy_exchange_secret","text":"<pre><code>get_academy_exchange_secret() -&gt; str\n</code></pre> <p>Get the secret of the academy_exchange.</p> Source code in <code>academy/exchange/cloud/scopes.py</code> <pre><code>def get_academy_exchange_secret() -&gt; str:\n    \"\"\"Get the secret of the academy_exchange.\"\"\"\n    return os.environ[ACADEMY_EXCHANGE_SECRET_ENV_NAME]\n</code></pre>"},{"location":"api/exchange/cloud/scopes/#academy.exchange.cloud.scopes.get_academy_exchange_scope_id","title":"get_academy_exchange_scope_id","text":"<pre><code>get_academy_exchange_scope_id() -&gt; str\n</code></pre> <p>Get the id of the academy_exchange scope.</p> <p>The environment variable can be used for testing, otherwise the default value is the id of the scope associated with the hosted exchange.</p> Source code in <code>academy/exchange/cloud/scopes.py</code> <pre><code>def get_academy_exchange_scope_id() -&gt; str:\n    \"\"\"Get the id of the academy_exchange scope.\n\n    The environment variable can be used for testing, otherwise the default\n    value is the id of the scope associated with the hosted exchange.\n    \"\"\"\n    try:\n        return os.environ[ACADEMY_EXCHANGE_SCOPE_ID_ENV_NAME]\n    except KeyError:\n        return DEFAULT_EXCHANGE_SCOPE_ID\n</code></pre>"},{"location":"api/exchange/cloud/token_store/","title":"academy.exchange.cloud.token_store","text":"<code>academy/exchange/cloud/token_store.py</code>"},{"location":"api/exchange/cloud/token_store/#academy.exchange.cloud.token_store.SafeSQLiteTokenStorage","title":"SafeSQLiteTokenStorage","text":"<pre><code>SafeSQLiteTokenStorage(\n    filepath: Path | str, *, namespace: str = \"DEFAULT\"\n)\n</code></pre> <p>               Bases: <code>TokenStorage</code></p> <p>A thread safe Globus SQLite token store.</p> <p>Parameters:</p> <ul> <li> <code>filepath</code>               (<code>Path | str</code>)           \u2013            <p>The path to a file where token data should be stored.</p> </li> <li> <code>namespace</code>               (<code>str</code>, default:                   <code>'DEFAULT'</code> )           \u2013            <p>A unique string for partitioning token data (Default: \"DEFAULT\").</p> </li> </ul> Source code in <code>academy/exchange/cloud/token_store.py</code> <pre><code>def __init__(\n    self,\n    filepath: pathlib.Path | str,\n    *,\n    namespace: str = 'DEFAULT',\n) -&gt; None:\n    super().__init__(namespace=namespace)\n    self._local_data = threading.local()\n    self.filepath = filepath\n    self.namespace = namespace\n</code></pre>"},{"location":"api/exchange/cloud/token_store/#academy.exchange.cloud.token_store.SafeSQLiteTokenStorage.token_store","title":"token_store  <code>property</code>","text":"<pre><code>token_store: SQLiteTokenStorage\n</code></pre> <p>Internal thread local token storage.</p>"},{"location":"api/exchange/cloud/token_store/#academy.exchange.cloud.token_store.SafeSQLiteTokenStorage.store_token_data_by_resource_server","title":"store_token_data_by_resource_server","text":"<pre><code>store_token_data_by_resource_server(\n    token_data_by_resource_server: Mapping[\n        str, TokenStorageData\n    ],\n) -&gt; None\n</code></pre> <p>Store token data for resource server(s) in the current namespace.</p> <p>Parameters:</p> <ul> <li> <code>token_data_by_resource_server</code>               (<code>Mapping[str, TokenStorageData]</code>)           \u2013            <p>mapping of resource server to token data.</p> </li> </ul> Source code in <code>academy/exchange/cloud/token_store.py</code> <pre><code>def store_token_data_by_resource_server(\n    self,\n    token_data_by_resource_server: Mapping[str, TokenStorageData],\n) -&gt; None:\n    \"\"\"Store token data for resource server(s) in the current namespace.\n\n    Args:\n        token_data_by_resource_server: mapping of resource server to\n            token data.\n    \"\"\"\n    return self.token_store.store_token_data_by_resource_server(\n        token_data_by_resource_server,\n    )\n</code></pre>"},{"location":"api/exchange/cloud/token_store/#academy.exchange.cloud.token_store.SafeSQLiteTokenStorage.get_token_data_by_resource_server","title":"get_token_data_by_resource_server","text":"<pre><code>get_token_data_by_resource_server() -&gt; (\n    dict[str, TokenStorageData]\n)\n</code></pre> <p>Retrieve all token data stored in the current namespace.</p> <p>Returns:</p> <ul> <li> <code>dict[str, TokenStorageData]</code>           \u2013            <p>a dict of <code>TokenStorageData</code> objects indexed by their resource server.</p> </li> </ul> Source code in <code>academy/exchange/cloud/token_store.py</code> <pre><code>def get_token_data_by_resource_server(self) -&gt; dict[str, TokenStorageData]:\n    \"\"\"Retrieve all token data stored in the current namespace.\n\n    Returns:\n        a dict of ``TokenStorageData`` objects indexed by their\n            resource server.\n    \"\"\"\n    return self.token_store.get_token_data_by_resource_server()\n</code></pre>"},{"location":"api/exchange/cloud/token_store/#academy.exchange.cloud.token_store.SafeSQLiteTokenStorage.remove_token_data","title":"remove_token_data","text":"<pre><code>remove_token_data(resource_server: str) -&gt; bool\n</code></pre> <p>Remove token data for a resource server in the current namespace.</p> <p>Parameters:</p> <ul> <li> <code>resource_server</code>               (<code>str</code>)           \u2013            <p>The resource server to remove token data for.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if token data was deleted, False if none was found to delete.</p> </li> </ul> Source code in <code>academy/exchange/cloud/token_store.py</code> <pre><code>def remove_token_data(self, resource_server: str) -&gt; bool:\n    \"\"\"Remove token data for a resource server in the current namespace.\n\n    Args:\n        resource_server: The resource server to remove token data for.\n\n    Returns:\n        True if token data was deleted, False if none was found to delete.\n    \"\"\"\n    return self.token_store.remove_token_data(resource_server)\n</code></pre>"},{"location":"case-studies/","title":"Case Studies using Academy","text":"<p>Note</p> <p>Coming soon!</p>"},{"location":"concepts/","title":"Concepts","text":""},{"location":"concepts/#architecture","title":"Architecture","text":"<p>Agents and users in Academy interact via handles to invoke actions asynchronously. An agent's behavior is defined by its actions, control loops, and state. Academy decouples the control and data planes through the exchange, used for user and agent communication, and launcher mechanisms that can remotely execute agents.</p> <p>An Academy application includes one or more agents and zero or more users. An agent is a process defined by a local state, a set of actions, and a set of control loops. Agents can be executed remotely using a manager (previously referred to as a launcher). Once running, an agent concurrently executes all of its control loops and listens for messages from user programs or other agents.</p> <p>A user program interacts with an agent through a handle, which acts like a reference to the remote agent and translates method calls into action request messages. Each entity (i.e., user or agent) has an associated mailbox that maintains a queue of messages sent to that entity by other entities. Mailboxes are maintained by an exchange such that any client with access to a given exchange can send messages to the mailbox of another agent in the exchange and receive a response through its own mailbox.</p>"},{"location":"concepts/#agents","title":"Agents","text":"<p>In Academy, the concept of an \"agent\" is intentionally simple. The agent primitive is, at its core, is an entity that:</p> <ul> <li>Has state: Maintains information about its current situation, past history, or internal variables.</li> <li>Performs actions: Execute specific operations or tasks.</li> <li>Communicates: Exchanges messages or data with other users, agents, or the environment.</li> </ul> <p>In essence, Academy agents can be thought of as building blocks for more complex or specialized agent-based systems.</p> <p>An agent is implemented as a Python class that inherits from the base <code>Agent</code> type. This class-based approach is extensible through inheritance and polymorphism.</p> <ul> <li>State is stored as instance attributes on the agent class instance. Instance attributes maintain the agent's state, and methods define the actions and control loops.</li> <li>Actions can be performed in two ways: <code>@action</code> decorated methods allow other entities to invoke the method remotely and <code>@loop</code> decorated methods run non-terminating control loops that enable an agent to autonomously perform actions.</li> <li>Communication between entities in managed via <code>Handles</code> which are client interfaces to remote agents used to invoke actions, ping, and shutdown.</li> </ul>"},{"location":"concepts/#execution","title":"Execution","text":"<p>The <code>Runtime</code> manager takes an <code>Agent</code> and executes the agent by: (1) listening for new messages in the agent's mailbox and dispatching them appropriately, (2) starting each <code>@loop</code> method, (3) calling the <code>agent_on_startup()</code> callback, and (4) waiting for the agent to be shut down. Each <code>@action</code> method is executed concurrently in the event loop when requested remotely so as to not block the handling of other messages.</p> <p>Agents are designed to be long-running, but can be terminated by sending a shutdown request. Upon shutdown, the shutdown <code>Event</code>, passed to each <code>@loop</code>, is set; running tasks are cancelled and waited on; and the <code>agent_on_shutdown()</code> callback is invoked. Agents can terminate themselves by setting the shutdown event or calling <code>Agent.agent_shutdown()</code>; exceptions raised in <code>@loop</code> methods will shutdown the agent by default, and exceptions raised when executing <code>@action</code> methods are caught and returned to the remote caller.</p>"},{"location":"concepts/#handles","title":"Handles","text":"<p>Interacting with an agent is asynchronous; an entity sends a message to the agent's mailbox and waits to receive a response message in its own mailbox. A <code>Handle</code> is a client interface to a remote agent used to invoke actions, ping, and shutdown the agent. Handles translate method calls into a request messages sent via the exchange and returning a <code>Futures</code>. The handle also listens for response messages and accordingly sets the result on the appropriate <code>Futures</code>.</p>"},{"location":"concepts/#exchanges-and-mailboxes","title":"Exchanges and Mailboxes","text":"<p>Entities communicate by sending and receiving messages to and from mailboxes. Mailboxes are managed by an exchange, and the <code>ExchangeClient</code> protocol defines methods for interacting with the exchange and creating handles to other agents. An <code>ExchangeFactory</code> is used to register a new entity with the exchange and create a client that the entity can use for communicating with the exchange. Registering an entity involves creating a unique ID for the entity, which is also the address of its mailbox, and initializing that mailbox within the exchange.</p> <p>A mailbox has two states: active and terminated. Active indicates that the entity's mailbox is accepting messages, even if, for example, an agent has not yet started or is temporarily offline. Terminated indicates permanent termination of the entity and will cause <code>MailboxTerminatedError</code> to be raised by subsequent send or receive operations to that mailbox.</p> <p>Academy provides many exchange implementations for different scenarios, such as:</p> <ul> <li>Local: Uses in-memory queues for single-process, multiple-agent scenarios. Useful for testing and development.</li> <li>HTTP: Centralized service that maintains mailboxes and exposes a REST API. Lower performance but easy to extend with common authentication tools.</li> <li>Redis: Stores state and mailboxes in a Redis server. Use of Redis enables optional replication and cloud-hosting for improved resilience and availability.</li> <li>HybridExchange: Entities host their mailbox locally and message each other directly over TCP when possible. Redis is used to map mailbox IDs to address and port pairs, and to store messages for offline entities or when two entities cannot directly communicate (such as when behind NATs).</li> </ul>"},{"location":"concepts/#manager","title":"Manager","text":"<p>Agents can be run manually via <code>Runtime.run_until_complete()</code>, but typically applications want to run many agents concurrently across parallel or distributed resources. The <code>Manager</code> provides a single interface for launching and managing agents across one or more <code>Executors</code>, such as a <code>ProcessPoolExecutor</code>, Parsl, or Globus Compute. A manager will handle common boilerplate, including registering agents, creating handles, and ensuring stateful resources are appropriately cleaned up.</p>"},{"location":"guides/","title":"Guides, Integrations, and Tutorials","text":"<p>Note</p> <p>More coming soon!</p> <p>The best way to get started with Academy basics is the Tutorial</p>"},{"location":"guides/#guides","title":"Guides","text":"<p>HPC Integration Patterns</p> <p>LLM Integration Patterns</p>"},{"location":"guides/hpc/","title":"Building HPC Agents","text":"<p>Academy supports deploying agents and running tasks on HPC resource. This guide walks through different patterns of using HPC resources with Academy.</p>"},{"location":"guides/hpc/#launching-agents-with-globus-compute","title":"Launching Agents with Globus Compute","text":"<p>Academy can be combined with Globus Compute to deploy agents onto remote resources. Globus Compute is a function-as-a-service provider with a bring-your-own compute model.</p> <p>A Globus Compute endpoint can be deployed on an HPC resource using the <code>globus_compute_endpoint</code> package: <pre><code>pip install globus-compute-endpoint\nglobus-compute-endpoint configure\nglobus-compute-endpoint start &lt;ENDPOINT_NAME&gt;\n</code></pre> When you start the Globus Compute endpoint, the script will output an <code>endpoint_id</code>. For more information on deployoing and configuring a Globus Compute endpoint please refer to the Globus Compute documentation.</p> <p>To launch agents on the Globus Compute endpoint, we can use the Globus Compute <code>executor</code> with the <code>Manager</code> class. The following script initializes a <code>executor</code> pointing to <code>&lt;endpoint_id&gt;</code> and passes the executor to a <code>Manager</code> to launch agents. It also connects the Manager and agent to the cloud hosted exchange at https://exchange.academy-agents.org using the <code>HttpExchangeFactory</code> for authenticated inter-site communication.</p> <p>globus_compute_example.py<pre><code>## Deploying Agents with Globus Compute\n...\n\nfrom academy.exchange.cloud.client import HttpExchangeFactory\nfrom academy.manager import Manager\nfrom globus_compute_sdk import Executor as GCExecutor\n\nEXCHANGE_ADDRESS = 'https://exchange.academy-agents.org'\n\nasync def main() -&gt; int:\n    executor = GCExecutor(&lt;endpoint_id&gt;)\n    async with await Manager.from_exchange_factory(\n        factory=HttpExchangeFactory(\n            EXCHANGE_ADDRESS,\n            auth_method='globus',\n        ),\n        executors=executor,\n    ) as manager:\n        hdl = await manager.launch(&lt;Agent&gt;)\n        ...\n</code></pre> For the full code for this example, refer to the tutorial</p>"},{"location":"guides/hpc/#running-actions-with-parsl","title":"Running Actions With Parsl","text":"<p>Academy Agents can also manage a pool of resources to run actions on HPC facilities. With this pattern an Agent is deployed on the login-node of a cluster (either using Globus Compute as above, or co-located with the user-script that is located in the same place). An Agent can then use technique it chooses to allocate resources and run tasks on the cluster.</p> <p>The following script shows a simple example of invoking a Parsl task within an Academy action. parsl_example.py<pre><code>## Running actions with parsl\n...\nimport asyncio\nimport parsl\nfrom parsl import Config\nfrom academy.agent import Agent, action\n\n\n@parsl.python_app\ndef expensive_task():\n    # Do expensive task\n    return 42\n\nclass SimulationAgent(Agent):\n    def __init__(self):\n        self.config = Config(\n            executors=[\n                HighThroughputExecutor()\n            ],\n        )\n\n    async def agent_on_startup(self) -&gt; None:\n        self.dfk = parsl.load(self.config)\n\n    async def agent_on_shutdown(self) -&gt; None:\n        self.dfk.cleanup()\n        self.dfk = None\n        parsl.clear()\n\n    @action\n    async def run_expensive_task(self) -&gt; None:\n        return await asyncio.wrap_future(expensive_task())\n</code></pre> The configuration will submit jobs to the cluster using Slurm, and run tasks using the HighThroughputExecutor. For information on configuring Parsl, please see the Parsl docs.</p>"},{"location":"guides/llm/","title":"LLM Agents","text":"<p>There are a variety of ways to create LLM agents within Academy.</p> <p>This page is still under construction, more details and examples to come!</p>"},{"location":"guides/llm/#llm-as-an-orchestrator-agents-as-tools","title":"LLM as an Orchestrator (Agents as Tools)","text":"<p>Language models can be used as the central coordinator in the workflow, where they are used to pick which agents to invoke. In Academy, this means that the language model needs to (1) be wrapped in an agent, and (2) needs to be able to invoke actions on other Agents.</p> <p>You can wrap an action invocation as a Tool call from a multi-LLM orchestration framework (i.e. Lanchain or pydanticAI). For instance:</p> <pre><code>from academy.handle import Handle\nfrom langchain.tools import tool, Tool\n\ndef make_sim_tool(handle: Handle[MySimAgent]) -&gt; Tool:\n    @tool\n    async def compute_property(smiles: str) -&gt; float:\n        \"\"\"Compute molecule property.\"\"\"\n        return await handle.compute_property(smiles)\n    return compute_property\n\ntool = make_sim_tool(agent_handle)\nprint(tool.args_schema.model_json_schema())\n</code></pre> <p>The LLM needs to be explicitly passed a tool because internally langchain uses the doc-string and the signature, which are not available on the handle. This also means that tools must be defined dynamically or a specific wrapper is needed for each tool to specify the documentation.</p> <p>Once the action is wrapped in a tool call, La\u00dfngchain can call actions on (potentiall remote) agents, allowing your language model access to research infrastrucutre.</p> <pre><code>async def main() -&gt; int:\n    ...\n    async with await Manager.from_exchange_factory(\n        executors=&lt;Insert your executor&gt;\n        factory=&lt;Insert your factory&gt;\n    ) as manager:\n        simulator = await manager.launch(MySimAgent)\n        llm = ChatOpenAI(\n            model=self.model,\n            api_key=self.access_token,\n            base_url=self.base_url,\n        )\n\n        tools = [make_sim_tool(agent) for agent in self.simulators]\n        langchain_agent = create_agent(llm, tools=tools)\n        await langchain_agent.ainvoke(\n            {\n                'messages': [{\n                    'role': 'user',\n                    'content': 'What is the simulated ionoization energy of benzene?'\n                }]\n            },\n        )\n        result = await orchestrator.hypothesize(question)\n        print(result)\n\n    return 0\n</code></pre> <p>This example still uses the client script to interact with the simulation agent through langchain. It's also possible to make the orchestration agentic  and distributed (i.e. an Academy agent). For example, if the orchestrator relies on a self-hosted language model available only within a certain resource, or if the agent is managing resources (such as the orchestrator running on a login node and starting up agents on compute nodes.) To do this, we can wrap the Langchain code up inside of an agent:</p> <pre><code>class Orchestrator(Agent):\n    \"\"\"Orchestrate a scientific workflow.\"\"\"\n\n    def __init__(\n        self,\n        model: str,\n        access_token: str,\n        simulators: list[Handle[MySimAgent]],\n        base_url: str | None = None,\n    ):\n        self.model = model\n        self.access_token = access_token\n        self.base_url = base_url\n        self.simulators = simulators\n\n    async def agent_on_startup(self) -&gt; None:\n        llm = ChatOpenAI(\n            model=self.model,\n            api_key=self.access_token,\n            base_url=self.base_url,\n        )\n\n        tools = [make_sim_tool(agent) for agent in self.simulators]\n        self.react_loop = create_agent(llm, tools=tools)\n\n    @action\n    async def hypothesize(self, goal: str) -&gt; str:\n        \"\"\"Use other agents to hypothesize molecules.\"\"\"\n\n        return await self.react_loop.ainvoke(\n            {'messages': [{'role': 'user', 'content': goal}]},\n        )\n</code></pre> <p>For the complete code of Langchain interacting with Academy agents, please look at the example included in the repo.</p>"},{"location":"guides/llm/#multi-agent-discussion-with-llms","title":"Multi-agent Discussion with LLMs","text":""},{"location":"guides/llm/#using-specialized-llms","title":"Using specialized LLMs","text":"<p>One advantage of distributing agents as</p>"},{"location":"guides/llm/#connecting-to-academy-via-mcp","title":"Connecting to Academy via MCP","text":"<p>MCP is a protocol for connecting models to tools. If your language model LLM knows how to call tools via an MCP server, this can be used as an entry point into the Academy ecosystem.</p>"},{"location":"guides/tutorial/","title":"Academy Tutorial","text":"<p>This tutorial provides a step by step introduction of Academy, from building a simple \"Hello World\" agent to coordinating a distributed, multi-agent game. The tutorial is structured as 5 modules that are cumulative --- the solution to the previous module provides the necessary information to understand the next module.</p> <p>Estimated Time: 40 minutes</p>"},{"location":"guides/tutorial/#setup","title":"Setup","text":""},{"location":"guides/tutorial/#install-tutorial-package","title":"Install Tutorial Package","text":"<p>Clone the repository from github and install the tutorial package. The package will automatically install <code>academy</code> as well.  The tutorial requires <code>python&gt;=3.12</code>. We recommend completing the tutorial inside a virtual environment. <pre><code>git clone git@github.com:academy-agents/academy-tutorial.git\ncd academy-tutorial\npython -m venv venv\n. ./venv/bin/activate\npip install .\n</code></pre> This will set up a local environment to complete the tutorial.</p>"},{"location":"guides/tutorial/#optional-set-up-globus-compute-endpoint","title":"(Optional) Set-up Globus Compute Endpoint","text":"<p>The tutorial also contains a walk through of writing distributed applications with <code>academy</code> and <code>globus compute</code>. You will need to follow the instructions to setup a globus compute endpoint or provide the <code>endpoint_id</code> of an endpoint you have access to. In the endpoint environment, you will also need to install the <code>academy-tutorial</code> package. To use the endpoint with the tutorial: <pre><code>export ACADEMY_TUTORIAL_ENDPOINT=&lt;endpoint_id&gt;\n</code></pre></p> <p>(If you are completing this tutorial with the Academy team, we will provide access to a Globus Compute Endpoint that you can use.)</p>"},{"location":"guides/tutorial/#helpful-links","title":"Helpful links","text":"<ul> <li>Example: shows basic usage of most classes and methods needed in this tutorial</li> <li>Getting started guide: an annotated example demonstrating basic features of Academy</li> <li>API reference: detailed reference for Academy</li> </ul>"},{"location":"guides/tutorial/#module-01-simple-actor-client-application","title":"Module 01: Simple Actor-Client Application:","text":"<p>In the first module, we will write a simple example of launching a stateful actor and invoking actions from a user program.</p> <p>The starter code contains an outline of an <code>Agent</code> class and a <code>Manager</code> class. In the <code>Counter</code> agent class add two new functions <code>increment</code> and <code>get_count</code> annotated with <code>@action</code> decorator. In the <code>manager</code> context, first fill in the <code>factory</code> and the <code>executors</code> arguments. Then use <code>manager.launch</code> to launch the counter agent, and create a handle to the newly launched agent. To verify that the agent launched and is running call the <code>increment</code> and <code>get_count</code> methods of the agent using the handle.</p> <p>To run the script: <pre><code>python run-01.py\n</code></pre></p>"},{"location":"guides/tutorial/#module-02-adding-autonomy","title":"Module 02: Adding \"Autonomy\"","text":"<p>Academy allows <code>agents</code> to express autonomous action using the <code>@loop</code> decorator. This can be used to monitor and respond to changing state or environment.</p> <p>Using the completed code from Module 01, change the increment method to a loop that increments the value of count every one second. To observe that it is working, change the <code>increment</code> call within the manager context to a <code>asyncio.sleep</code>. The <code>agent.count</code> should increment for how ever long the sleep is called.</p> <p>To run the script: <pre><code>python run-02.py\n</code></pre></p>"},{"location":"guides/tutorial/#module-03-agent-agent-communication","title":"Module 03: Agent-Agent Communication","text":"<p>Academy allows you to build multi-agent systems. Agent <code>Handle</code>s can be passed to other agents (or created by other agents) to allow one agent to invoke another.</p> <p>The starter code for Module 03 contains a coordinator class that should lower and reverse a string using two other agents. Fill in the constructor to accept <code>Handle</code>s to the <code>Lowerer</code> and <code>Reverser</code> agents and store them as part of the <code>Coordinator</code> state. Then fill in the <code>process</code> action to invoke each handle. In the <code>manager</code> context, launch the <code>Coordinator</code> agent. You can pass arguments to the <code>Coordinator</code>constructor using the <code>args=</code> argument of <code>manager.launch</code></p> <p>To run the script: <pre><code>python run-03.py\n</code></pre></p>"},{"location":"guides/tutorial/#module-04-distributing-computation","title":"Module 04: Distributing Computation","text":"<p>Academy integrates with a cloud hosted exchange and <code>globus compute</code> to build distributed agentic systems. In the starter code for Module 04, fill in the constructor of an executor used to launch agents with the <code>GCExecutor</code> (Globus Compute Executor) or a <code>ProcessPoolExecutor</code> if you do not have a Globus Compute Endpoint available. Then complete the Manager context with the appropriate fields. For the <code>factory</code> use the <code>HttpExchangeFactory</code> pointed at our hosted exchange <code>https:exchange.academy-agents.org</code> with <code>auth_method='globus'</code>. For the <code>executors</code> field use the <code>GCExecutor</code> or <code>ProcessPoolExecutor</code> you created above. This will enable you to launch the agents across distributed resources.</p> <p>Globus Compute is a FaaS platform that allows you to bring your own compute resource. In <code>run-compute-function.py</code> we show an example of running a remote function.</p> <p>The script also uses a cloud hosted exchange. The exchange is authenticated with globus auth, and federated identification provider. When you run the script you will be asked to give permissions for the <code>academy</code> client to use the exchange, and authenticate your token. After you provide the permissions, a token will be created that the <code>academy</code> client uses to communicate with the exchange.</p> <p>To run the script: <pre><code>python run-04.py\n</code></pre></p>"},{"location":"guides/tutorial/#module-05-battleship","title":"Module 05: Battleship","text":"<p>Finally, we use <code>academy</code> to build a battleship game. Battleship consists of two agents --- a <code>coordinator</code> the manages the game state, and multiple instance of the <code>player</code> agent which implements a strategy.</p> <p>Implement the player strategy for guessing where opponent ships are and for placing ships on your board.</p> <p>To run the script: <pre><code>python run-05.py\n</code></pre></p>"},{"location":"publications/","title":"Publications","text":""},{"location":"publications/#citing-academy","title":"Citing Academy","text":"<p>If you use Academy in your work, please cite our preprint: Empowering Scientific Workflows with Federated Agents.</p> <p>Pauloski, J. Gregory, Yadu Babuji, Ryan Chard, Mansi Sakarvadia, Kyle Chard, and Ian Foster. \"Empowering Scientific Workflows with Federated Agents.\" arXiv preprint arXiv:2505.05428 (2025).</p> <pre><code>@misc{pauloski2025academy,\n    title = {Empowering {S}cientific {W}orkflows with {F}ederated {A}gents},\n    author = {J. Gregory Pauloski and Yadu Babuji and Ryan Chard and Mansi Sakarvadia and Kyle Chard and Ian Foster},\n    archiveprefix = {arXiv},\n    eprint = {2505.05428},\n    primaryclass = {cs.MA},\n    url = {https://arxiv.org/abs/2505.05428},\n    year = {2025}\n}\n</code></pre>"},{"location":"publications/#featured-publications","title":"Featured Publications","text":"<p>If you use Academy in your work and would like to be featured on this page, open an issue or propose a pull request on GitHub.</p> <ul> <li>J.G. Pauloski, K. Chard, I. Foster. \"Agentic Discovery: Closing the Loop With Cooperative Agents,\" in Computer, vol. 58, no. 10, pp. 20-27, 2025.</li> </ul>"}]}