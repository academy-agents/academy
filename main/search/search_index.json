{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Academy: Federated Actors and Agents","text":"<p>Academy is a modular and extensible middleware for building and deploying stateful actors and autonomous agents across distributed systems and federated research infrastructure. In Academy, you can:</p> <ul> <li>\u2699\ufe0f  Express agent behavior and state in code</li> <li>\ud83d\udceb Manage inter-agent coordination and asynchronous communication</li> <li>\ud83c\udf10 Deploy agents across distributed, federated, and heterogeneous resources</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Academy is available on PyPI.</p> <pre><code>pip install academy-py\n</code></pre>"},{"location":"#example","title":"Example","text":"<p>Agents in Academy are defined by a <code>Behavior</code>, a class with methods decorated with <code>@action</code> can be invoked by peers and method decorated with <code>@loop</code> run autonomous control loops.</p> <p>The below sensor monitoring behavior periodically reads a sensor in the <code>monitor()</code> loop and processes the reading if a threshold is met. Clients or peers can invoke the <code>get_last_reading()</code> and <code>set_process_threshold()</code> actions remotely to interact with the monitor agent.</p> <pre><code>import time, threading\nfrom academy.behavior import Behavior, action, loop\n\nclass SensorMonitorAgent(Behavior):\n    def __init__(self) -&gt; None:\n        self.last_reading: float | None = None\n        self.process_threshold: float = 1.0\n\n    @action\n    def get_last_reading(self) -&gt; float | None:\n        return self.last_reading\n\n    @action\n    def set_process_threshold(self, value: float) -&gt; None:\n        self.process_threshold = value\n\n    @loop\n    def monitor(self, shutdown: threading.Event) -&gt; None:\n        while not shutdown.is_set():\n            value = read_sensor_data()\n            self.last_reading = value:\n            if value &gt;= self.process_threshold:\n                process_reading(value)\n            time.sleep(1)\n</code></pre> <p>Entities communicate asynchronously through handles, sending messages to and receiving messages from a mailbox managed by an <code>Exchange</code>. The <code>Launcher</code> abstracts the remote execution of an agent, and the <code>Manager</code> provides easy management of handles, launchers, and the exchange.</p> <pre><code>from academy.exchange.thread import ThreadExchange\nfrom academy.launcher import ThreadLauncher\nfrom academy.manager import Manager\n\nwith Manager(\n    exchange=ThreadExchange(),  # Replace with other implementations\n    launcher=ThreadLauncher(),  # for distributed deployments\n) as manager:\n    behavior = SensorMonitorAgent()  # From the above block\n    agent_handle = manager.launch(behavior)\n\n    agent_handle.set_process_threshold(2.0).result()\n    time.sleep(5)\n    value = agent_handle.get_last_reading().result()\n\n    manager.shutdown(handle, blocking=True)\n</code></pre> <p>Learn more about Academy in Getting Started.</p>"},{"location":"#what-can-be-an-agent","title":"What can be an agent?","text":"<p>In Academy, an agent is a primitive entity that (1) has internal state, (2) performs actions, and (3) communicates with other agents.</p> <p>This allows for range of agent implementations\u2014Academy agents are building blocks for constructing more complex agent-based systems.</p> <p>For example, Academy can be use to create the following:</p> <ul> <li>Stateful Actors: Actors manage their own data and respond to requests in a distributed system.</li> <li>LLM Agents: Integrate LLM-based reasoning and tool calling.</li> <li>Embodied Agents: The \"brain\" controlling a robot or simulated entity where action are translated into motor commands or environment manipulations.</li> <li>Computational Units: Encapsulate a specific computational task, like running a simulation, processing data, or training a machine learning model.</li> <li>Orchestrators: Manage or coordinate the activities of other agents, distributing tasks and monitoring progress.</li> <li>Data Interfaces: Interact with external data sources, such as databases, file systems, or sensors, providing a consistent interface for data access and manipulation.</li> </ul>"},{"location":"#why-academy","title":"Why Academy?","text":"<p>Academy offers a powerful and flexible framework for building sophisticated, distributed agent-based systems, particularly well-suited for the complexities of scientific applications. Here's what makes Academy valuable:</p> <ul> <li>Stateful Agents: Academy enables agents to maintain state, which is crucial for managing long-running processes, tracking context across steps, and implementing agents that need to \"remember\" information.</li> <li>Agent Autonomy: Academy allows agents to have autonomous control loops, empowering them to make decisions, react to events, and execute tasks independently.</li> <li>Flexible Deployment: Academy provides tools for managing agent deployment, communication, and coordination in complex environments such that applications can leverage heterogeneous, distributed, and federated resources.</li> <li>Foundation for Sophisticated Applications: Academy primitives offer a strong foundation for building highly specialized and sophisticated agent-based systems that go beyond standard LLM use cases, allowing for fine-grained control and optimization tailored to specific scientific applications.</li> </ul>"},{"location":"#citation","title":"Citation","text":"<p>The Academy preprint is available on arXiv.</p> <pre><code>@misc{pauloski2025academy,\n    title = {{E}mpowering {S}cientific {W}orkflows with {F}ederated {A}gents},\n    author = {J. Gregory Pauloski and Yadu Babuji and Ryan Chard and Mansi Sakarvadia and Kyle Chard and Ian Foster},\n    archivePrefix = {arXiv},\n    eprint = {2505.05428},\n    primaryClass = {cs.MA},\n    url = {https://arxiv.org/abs/2505.05428},\n    year = {2025},\n}\n</code></pre>"},{"location":"concepts/","title":"Concepts","text":""},{"location":"concepts/#architecture","title":"Architecture","text":"<p>Agents and clients in Academy interact via handles to invoke actions asynchronously. Agents implement a behavior, defined by their actions, control loops, and state. Academy decouples the control and data planes through the launcher and exchange components that manage spawning agents and communication, respectively.</p> <p>An Academy application includes one or more agents and zero or more clients. An agent is a process that executes a behavior, where a behavior is defined by a local state, a set of actions, and a set of control loops. Agents are executed remotely using a launcher. Once running, an agent concurrently executes all of its control loops and listens for messages from clients, which can be other agents or programs.</p> <p>A client interacts with an agent through a handle}, which acts like a reference to the remote agent and translates method calls into action request messages. Each entity (i.e., client or agent) has an associated mailbox that maintains a queue of messages sent to that entity by other entities. Mailboxes are maintained by an exchange such that any client with access to a given exchange can send messages to the mailbox of another agent in the exchange and receive a response through its own mailbox.</p>"},{"location":"concepts/#agents","title":"Agents","text":"<p>In Academy, the concept of an \"agent\" is intentionally simple. The agent primitive is, at its core, is an entity that:</p> <ul> <li>Has state: Maintains information about its current situation, past history, or internal variables.</li> <li>Performs actions: Execute specific operations or tasks.</li> <li>Communicates: Exchanges messages or data with other clients, agents, or the environment.</li> </ul> <p>In essence, Academy agents can be thought of as building blocks for more complex or specialized agent-based systems.</p>"},{"location":"concepts/#behaviors","title":"Behaviors","text":"<p>An academy.behavior is implemented as a Python class that inherits from the base <code>Behavior</code> type. This class-based approach is extensible through inheritance and polymorphism.</p> <ul> <li>State is stored as instance attributes on the agent's behavior type. Instance attributes maintain the agent's state, and methods define the actions and control loops.</li> <li>Actions can be performed in two ways: <code>@action</code> decorated methods allow other entities to invoke the method remotely and <code>@loop</code> decorated methods run non-terminating control loops that enable an agent to autonomously perform actions.</li> <li>Communication between entities in managed via <code>Handles</code> which are client interfaces to remote agents used to invoke actions, ping, and shutdown.</li> </ul>"},{"location":"concepts/#execution","title":"Execution","text":"<p>The <code>Agent</code> is a multithreaded entity that executes a provided behavior and manages communication with other entities. <code>Agent.run()</code> executed the agent by (1) invokes the <code>on_setup()</code> callback of the behavior, (2) starts each <code>@loop</code> method in a separate thread, (3) spawns a thread to listen for new messages in the agent's mailbox, and (4) waits for the agent to be shut down. Each <code>@action</code> method is executed in a thread pool when requested remotely so as to not block the handling of other messages.</p> <p>Note</p> <p>The use of multi-threading means that behavior implementations must be aware of the caveats of Python's global interpreter lock (GIL). Compute-heavy actions can dispatch work to other parallel executors, such as a <code>ProcessPoolExecutor</code>, Dask Distributed, Parsl, or Ray.</p> <p>Agents are designed to be long-running, but can be terminated by sending a shutdown request. Upon shutdown, the shutdown <code>threading.Event</code>, passed to each <code>@loop</code>, is set; running threads are instructed to shutdown and waited on; and the <code>on_shutdown()</code> callback is invoked. Agents can terminate themselves by setting the shutdown event; exceptions raised in <code>@loop</code> methods will shutdown the agent by default, and exceptions raised when executing <code>@action</code> methods are caught and returned to the remote caller.</p>"},{"location":"concepts/#handles","title":"Handles","text":"<p>Interacting with an agent is asynchronous; an entity sends a message to the agent's mailbox and waits to receive a response message in its own mailbox. A <code>Handle</code> is a client interface to a remote agent used to invoke actions, ping, and shutdown the agent. Handles translate method calls into a request messages sent via the exchange and returning a <code>Futures</code>. The handle also listens for response messages and accordingly sets the result on the appropriate <code>Futures</code>.</p>"},{"location":"concepts/#exchanges-and-mailboxes","title":"Exchanges and Mailboxes","text":"<p>Entities communicate by sending and receiving messages to and from mailboxes. Mailboxes are managed by an Exchange, and this protocol defines methods for registering new agent or client mailboxes, sending and receiving messages, and creating handles to remote agents. A ExchangeFactory is initially unbound. That is not attached to a mailbox. In this state it is not able to send or receive messages. In order to act on the exchange, the ExchangeFactory must <code>bind</code> to a mailbox so it is able to receive responses to its actions. Registering an agent or client involves creating a unique ID for the entity, which is also the address of its mailbox, and initializing that mailbox within the exchange.</p> <p>A mailbox has two states: open and closed. Open indicates that the entity is accepting messages, even if, for example, an agent has not yet started or is temporarily offline. Closed indicates permanent termination of the entity and will cause <code>MailboxClosedError</code> to be raised by subsequent send or receive operations to that mailbox.</p> <p>Academy provides many exchange implementations for different scenarios, such as:</p> <ul> <li><code>ThreadExchange</code>: Uses thread-safe queues for single-process, multiple-agent scenarios. Useful for testing and development.</li> <li><code>HttpExchange</code>: Centralized service that maintains mailboxes and exposes a REST API. Lower performance but easy to extend with common authentication tools.</li> <li><code>RedisExchange</code>: Stores state and mailboxes in a Redis server. Use of Redis enables optional replication and cloud-hosting for improved resilience and availability.</li> <li><code>HybridExchange</code>: Entities host their mailbox locally and message each other directly over TCP when possible. Redis is used to map mailbox IDs to address and port pairs, and to store messages for offline entities or when two entities cannot directly communicate (such as when behind NATs).</li> </ul>"},{"location":"concepts/#launcher","title":"Launcher","text":"<p>An agent can be run manually, but the intended method of execution is via the launcher, which manages the initialization and execution of agents on remote resources. The <code>Launcher</code> defines a <code>launch()</code> method with parameters for the behavior, exchange, and agent ID and returns a handle to the launched agent. It runs agents in any <code>concurrent.futures.Executor</code> compatible executor, such as a <code>ProcessPoolExecutor</code>, Parsl, or Globus Compute.</p>"},{"location":"concepts/#managers","title":"Managers","text":"<p>A <code>Manager</code> combines an exchange and one or more launchers to provide a single interface for launching, using, and managing agents. Each manager has a single mailbox in the exchange and multiplexes that mailbox across handles to all of the agents that it manages. This reduces boilerplate code, improves communication efficiency, and ensures stateful resources and threads are appropriately cleaned up.</p>"},{"location":"faq/","title":"Frequently Asked Questions","text":"<p>Open a new issue if you have a question not answered in the FAQ, Guides, or API docs.</p> <p>Warning</p> <p>FAQs are under development!</p>"},{"location":"get-started/","title":"Getting Started","text":""},{"location":"get-started/#installation","title":"Installation","text":"<p>You can install Academy with <code>pip</code> or from source. We suggest installing within a virtual environment (e.g., <code>venv</code> or Conda). <pre><code>python -m venv venv\n. venv/bin/activate\n</code></pre></p> <p>Option 1: Install from PyPI: <pre><code>pip install academy-py\n</code></pre></p> <p>Option 2: Install from source: <pre><code>git clone git@github.com:proxystore/academy\ncd academy\npip install -e .  # -e for editable mode\n</code></pre></p>"},{"location":"get-started/#a-basic-example","title":"A Basic Example","text":"<p>The following script defines, initializes, and launches a simple agent that performs a single action. Click on the plus (<code>+</code>) signs to learn more.</p> example.py<pre><code>from academy.behavior import Behavior, action\nfrom academy.exchange.thread import ThreadExchangeFactory\nfrom academy.launcher import ThreadLauncher\nfrom academy.logging import init_logging\nfrom academy.manager import Manager\n\nclass ExampleAgent(Behavior):  # (1)!\n    @action  # (2)!\n    def square(self, value: float) -&gt; float:\n        return value * value\n\ndef main() -&gt; None:\n    init_logging('INFO')\n\n    with Manager(  # (3)!\n        exchange=ThreadExchangeFactory(),  # (4)!\n        launcher=ThreadLauncher(),  # (5)!\n    ) as manager:\n        agent_handle = manager.launch(ExampleAgent())  # (6)!\n\n        future = agent_handle.square(2)  # (7)!\n        assert future.result() == 4\n\n        agent_handle.shutdown()  # (8)!\n\nif __name__ == '__main__':\n    main()\n</code></pre> <ol> <li>Running agents implement a <code>Behavior</code>.</li> <li>Behavior methods decorated with <code>@action</code> can be invoked remotely by clients and other agents. An agent can call action methods on itself as normal methods.</li> <li>The <code>Manager</code> is a high-level interface that reduces boilerplate code when launching and managing agents. It will also manage clean up of resources and shutting down agents when the context manager exits.</li> <li>The <code>ThreadExchange</code> manages message passing between clients and agents running in different threads of a single process.</li> <li>The <code>ThreadLauncher</code> launches agents in threads of the current process.</li> <li>An instantiated behavior (here, <code>ExampleAgent</code>) can be launched with <code>Manager.launch()</code>, returning a handle to the remote agent.</li> <li>Interact with running agents via a <code>BoundRemoteHandle</code>. Invoking an action returns a future to the result.</li> <li>Agents can be shutdown via a handle or the manager.</li> </ol> <p>Running this script with logging enabled produces the following output: <pre><code>$ python example.py\nINFO (root) Configured logger (stdout-level=INFO, logfile=None, logfile-level=None)\nINFO (academy.manager) Initialized manager (ClientID&lt;6e890226&gt;; ThreadExchange&lt;4401447664&gt;)\nINFO (academy.manager) Launched agent (AgentID&lt;ad6faf7e&gt;; Behavior&lt;ExampleAgent&gt;)\nINFO (academy.agent) Running agent (AgentID&lt;ad6faf7e&gt;; Behavior&lt;ExampleAgent&gt;)\nINFO (academy.agent) Shutdown agent (AgentID&lt;ad6faf7e&gt;; Behavior&lt;ExampleAgent&gt;)\nINFO (academy.manager) Closed manager (ClientID&lt;6e890226&gt;)\n</code></pre></p>"},{"location":"get-started/#control-loops","title":"Control Loops","text":"<p>Control loops define the autonomous behavior of a running agent and are created by decorating a method with <code>@loop</code>.</p> <pre><code>import threading\nimport time\nfrom academy.behavior import loop\n\nclass ExampleAgent(Behavior):\n    @loop\n    def counter(self, shutdown: threading.Event) -&gt; None:\n        count = 0\n        while not shutdown.is_set():\n            print(f'Count: {count}')\n            count += 1\n            time.sleep(1)\n</code></pre> <p>All control loops are started in separate threads when an agent is executed, and run until the control loop exits or the agent is shut down, as indicated by the <code>shutdown</code> event.</p>"},{"location":"get-started/#agent-to-agent-interaction","title":"Agent to Agent Interaction","text":"<p>Agent handles can be passed to other agents to facilitate agent-to-agent interaction. Here, a <code>Coordinator</code> is initialized with handles to two other agents implementing the <code>Lowerer</code> and <code>Reverser</code> behaviors, respectively.</p> <pre><code>from academy.behavior import action\nfrom academy.behavior import Behavior\nfrom academy.handle import Handle\n\nclass Coordinator(Behavior):\n    def __init__(\n        self,\n        lowerer: Handle[Lowerer],\n        reverser: Handle[Reverser],\n    ) -&gt; None:\n        self.lowerer = lowerer\n        self.reverser = reverser\n\n    @action\n    def process(self, text: str) -&gt; str:\n        text = self.lowerer.action('lower', text).result()\n        text = self.reverser.action('reverse', text).result()\n        return text\n\nclass Lowerer(Behavior):\n    @action\n    def lower(self, text: str) -&gt; str:\n        return text.lower()\n\nclass Reverser(Behavior):\n    @action\n    def reverse(self, text: str) -&gt; str:\n        return text[::-1]\n</code></pre> <p>After launching the <code>Lowerer</code> and <code>Reverser</code>, the respective handles can be used to initialize the <code>Coordinator</code> before launching it.</p> <pre><code>from academy.exchange.thread import ThreadExchange\nfrom academy.launcher import ThreadLauncher\nfrom academy.logging import init_logging\nfrom academy.manager import Manager\n\ndef main() -&gt; None:\n    init_logging('INFO')\n\n    with Manager(\n        exchange=ThreadExchange(),\n        launcher=ThreadLauncher(),\n    ) as manager:\n        lowerer = manager.launch(Lowerer())\n        reverser = manager.launch(Reverser())\n        coordinator = manager.launch(Coordinator(lowerer, reverser))\n\n        text = 'DEADBEEF'\n        expected = 'feebdaed'\n\n        future = coordinator.process(text)\n        assert future.result() == expected\n\nif __name__ == '__main__':\n    main()\n</code></pre>"},{"location":"get-started/#distributed-execution","title":"Distributed Execution","text":"<p>The prior examples have launched agent in threads of the main process, but in practice agents are launched in different processes, possibly on the same node or remote nodes. The prior example can be executed in a distributed fashion by changing the launcher and exchange to implementations which support distributed execution. Below, a Redis server server (via the <code>RedisExchange</code>) is used to support messaging between distributed agents executed with a <code>ProcessPoolExecutor</code> (via the <code>Launcher</code>).</p> <pre><code>from concurrent.futures import ProcessPoolExecutor\nfrom academy.exchange.redis import RedisExchangeFactory\nfrom academy.launcher import Launcher\n\ndef main() -&gt; None:\n    process_pool = ProcessPoolExecutor(max_processes=4)\n    with Manager(\n        exchange=RedisExchangeFactory('&lt;REDIS HOST&gt;', port=6379),\n        launcher=Launcher(process_pool),\n    ) as manager:\n        ...\n</code></pre> <p>The <code>Launcher</code> is compatible with any <code>concurrent.futures.Executor</code>.</p>"},{"location":"api/","title":"academy","text":"<code>academy/__init__.py</code>"},{"location":"api/SUMMARY/","title":"SUMMARY","text":"<ul> <li>academy</li> <li>academy.agent</li> <li>academy.behavior</li> <li>academy.event</li> <li>academy.exception</li> <li>academy.exchange<ul> <li>cloud<ul> <li>authenticate</li> <li>client</li> <li>config</li> <li>exceptions</li> <li>login</li> <li>server</li> </ul> </li> <li>hybrid</li> <li>proxystore</li> <li>queue</li> <li>redis</li> <li>thread</li> </ul> </li> <li>academy.handle</li> <li>academy.identifier</li> <li>academy.launcher</li> <li>academy.logging</li> <li>academy.manager</li> <li>academy.message</li> <li>academy.mypy_plugin</li> <li>academy.serialize</li> <li>academy.socket</li> <li>academy.state</li> </ul>"},{"location":"api/agent/","title":"academy.agent","text":"<code>academy/agent.py</code>"},{"location":"api/agent/#academy.agent.AgentRunConfig","title":"AgentRunConfig  <code>dataclass</code>","text":"<pre><code>AgentRunConfig(\n    close_exchange_on_exit: bool = True,\n    max_action_concurrency: int | None = None,\n    terminate_on_error: bool = True,\n    terminate_on_exit: bool = True,\n)\n</code></pre> <p>Agent run configuration.</p> <p>Attributes:</p> <ul> <li> <code>close_exchange_on_exit</code>               (<code>bool</code>)           \u2013            <p>Close the exchange interface when the agent exits. Typically this should be <code>True</code> to clean up resources, except when multiple agents are running in the same process and sharing an exchange.</p> </li> <li> <code>max_action_concurrency</code>               (<code>int | None</code>)           \u2013            <p>Maximum size of the thread pool used to concurrently execute action requests.</p> </li> <li> <code>terminate_on_error</code>               (<code>bool</code>)           \u2013            <p>Terminate the agent by closing its mailbox permanently if the agent fails.</p> </li> <li> <code>terminate_on_exit</code>               (<code>bool</code>)           \u2013            <p>Terminate the agent by closing its mailbox permanently after the agent exits.</p> </li> </ul>"},{"location":"api/agent/#academy.agent.Agent","title":"Agent","text":"<pre><code>Agent(\n    behavior: BehaviorT,\n    *,\n    agent_id: AgentId[BehaviorT],\n    exchange: ExchangeFactory,\n    config: AgentRunConfig | None = None\n)\n</code></pre> <p>               Bases: <code>Generic[BehaviorT]</code></p> <p>Executable agent.</p> <p>An agent executes predefined <code>Behavior</code>. An agent can operate independently or as part of a broader multi-agent system.</p> Note <p>An agent can only be run once. After <code>shutdown()</code> is called, later operations will raise a <code>RuntimeError</code>.</p> Note <p>If any <code>@loop</code> method raises an error, the agent will be signaled to shutdown.</p> <p>Parameters:</p> <ul> <li> <code>behavior</code>               (<code>BehaviorT</code>)           \u2013            <p>Behavior that the agent will exhibit.</p> </li> <li> <code>agent_id</code>               (<code>AgentId[BehaviorT]</code>)           \u2013            <p>EntityId of this agent in a multi-agent system.</p> </li> <li> <code>exchange</code>               (<code>ExchangeFactory</code>)           \u2013            <p>Message exchange of multi-agent system. The agent will close the exchange when it finished running.</p> </li> <li> <code>config</code>               (<code>AgentRunConfig | None</code>, default:                   <code>None</code> )           \u2013            <p>Agent execution parameters.</p> </li> </ul> Source code in <code>academy/agent.py</code> <pre><code>def __init__(\n    self,\n    behavior: BehaviorT,\n    *,\n    agent_id: AgentId[BehaviorT],\n    exchange: ExchangeFactory,\n    config: AgentRunConfig | None = None,\n) -&gt; None:\n    self.agent_id = agent_id\n    self.behavior = behavior\n    self.exchange = exchange.bind_as_agent(\n        agent_id,\n        handler=self._request_handler,\n    )\n    self.config = config if config is not None else AgentRunConfig()\n\n    self._actions = behavior.behavior_actions()\n    self._loops = behavior.behavior_loops()\n\n    self._shutdown = threading.Event()\n    self._expected_shutdown = False\n    self._state_lock = threading.Lock()\n    self._state = _AgentState.INITIALIZED\n\n    self._action_pool: ThreadPoolExecutor | None = None\n    self._action_futures: dict[ActionRequest, Future[None]] = {}\n    self._loop_pool: ThreadPoolExecutor | None = None\n    self._loop_futures: dict[Future[None], str] = {}\n</code></pre>"},{"location":"api/agent/#academy.agent.Agent.__call__","title":"__call__","text":"<pre><code>__call__() -&gt; None\n</code></pre> <p>Alias for run().</p> Source code in <code>academy/agent.py</code> <pre><code>def __call__(self) -&gt; None:\n    \"\"\"Alias for [run()][academy.agent.Agent.run].\"\"\"\n    self.run()\n</code></pre>"},{"location":"api/agent/#academy.agent.Agent.action","title":"action","text":"<pre><code>action(action: str, args: Any, kwargs: Any) -&gt; Any\n</code></pre> <p>Invoke an action of the agent.</p> <p>Parameters:</p> <ul> <li> <code>action</code>               (<code>str</code>)           \u2013            <p>Name of action to invoke.</p> </li> <li> <code>args</code>               (<code>Any</code>)           \u2013            <p>Tuple of positional arguments.</p> </li> <li> <code>kwargs</code>               (<code>Any</code>)           \u2013            <p>Dictionary of keyword arguments.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any</code>           \u2013            <p>Result of the action.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>AttributeError</code>             \u2013            <p>if an action with this name is not implemented by the behavior of the agent.</p> </li> </ul> Source code in <code>academy/agent.py</code> <pre><code>def action(self, action: str, args: Any, kwargs: Any) -&gt; Any:\n    \"\"\"Invoke an action of the agent.\n\n    Args:\n        action: Name of action to invoke.\n        args: Tuple of positional arguments.\n        kwargs: Dictionary of keyword arguments.\n\n    Returns:\n        Result of the action.\n\n    Raises:\n        AttributeError: if an action with this name is not implemented by\n            the behavior of the agent.\n    \"\"\"\n    logger.debug('Invoking \"%s\" action on %s', action, self.agent_id)\n    if action not in self._actions:\n        raise AttributeError(\n            f'Agent[{type(self.behavior).__name__}] does not have an '\n            f'action named \"{action}\".',\n        )\n    return self._actions[action](*args, **kwargs)\n</code></pre>"},{"location":"api/agent/#academy.agent.Agent.run","title":"run","text":"<pre><code>run() -&gt; None\n</code></pre> <p>Run the agent.</p> <p>Starts the agent, waits for another thread to call <code>signal_shutdown()</code>, and then shuts down the agent.</p> <p>Raises:</p> <ul> <li> <code>Exception</code>             \u2013            <p>Any exceptions raised inside threads.</p> </li> </ul> Source code in <code>academy/agent.py</code> <pre><code>def run(self) -&gt; None:\n    \"\"\"Run the agent.\n\n    Starts the agent, waits for another thread to call `signal_shutdown()`,\n    and then shuts down the agent.\n\n    Raises:\n        Exception: Any exceptions raised inside threads.\n    \"\"\"\n    try:\n        self.start()\n        self._shutdown.wait()\n    finally:\n        self.shutdown()\n</code></pre>"},{"location":"api/agent/#academy.agent.Agent.start","title":"start","text":"<pre><code>start() -&gt; None\n</code></pre> <p>Start the agent.</p> Note <p>This method is idempotent; it will return if the agent is already running. However, it will raise an error if the agent is shutdown.</p> <ol> <li>Binds all unbound handles to remote agents to this agent.</li> <li>Calls <code>Behavior.on_setup()</code>.</li> <li>Starts threads for all control loops defined on the agent's    <code>Behavior</code>.</li> <li>Starts a thread for listening to messages from the exchange.</li> </ol> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>If the agent has been shutdown.</p> </li> </ul> Source code in <code>academy/agent.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Start the agent.\n\n    Note:\n        This method is idempotent; it will return if the agent is\n        already running. However, it will raise an error if the agent\n        is shutdown.\n\n    1. Binds all unbound handles to remote agents to this agent.\n    1. Calls [`Behavior.on_setup()`][academy.behavior.Behavior.on_setup].\n    1. Starts threads for all control loops defined on the agent's\n       [`Behavior`][academy.behavior.Behavior].\n    1. Starts a thread for listening to messages from the exchange.\n\n    Raises:\n        RuntimeError: If the agent has been shutdown.\n    \"\"\"\n    with self._state_lock:\n        if self._state is _AgentState.SHUTDOWN:\n            raise RuntimeError('Agent has already been shutdown.')\n        elif self._state is _AgentState.RUNNING:\n            return\n\n        logger.debug(\n            'Starting agent... (%s; %s)',\n            self.agent_id,\n            self.behavior,\n        )\n        self._state = _AgentState.STARTING\n        self._bind_handles()\n        self.behavior.on_setup()\n        self._action_pool = ThreadPoolExecutor(\n            self.config.max_action_concurrency,\n        )\n        self._loop_pool = ThreadPoolExecutor(\n            max_workers=len(self._loops) + 1,\n        )\n\n        for name, method in self._loops.items():\n            loop_future = self._loop_pool.submit(method, self._shutdown)\n            self._loop_futures[loop_future] = name\n            loop_future.add_done_callback(self._loop_callback)\n\n        listener_future = self._loop_pool.submit(self.exchange.listen)\n        self._loop_futures[listener_future] = '_exchange.listen'\n\n        self._state = _AgentState.RUNNING\n\n        logger.info('Running agent (%s; %s)', self.agent_id, self.behavior)\n</code></pre>"},{"location":"api/agent/#academy.agent.Agent.shutdown","title":"shutdown","text":"<pre><code>shutdown() -&gt; None\n</code></pre> <p>Shutdown the agent.</p> Note <p>This method is idempotent.</p> <ol> <li>Sets the shutdown <code>Event</code> passed to all control    loops.</li> <li>Waits for any currently executing actions to complete.</li> <li>Closes the agent's mailbox indicating that no further messages    will be processed.</li> <li>Waits for the control loop and message listener threads to exit.</li> <li>Optionally closes the exchange.</li> <li>Calls    <code>Behavior.on_shutdown()</code>.</li> </ol> <p>Raises:</p> <ul> <li> <code>Exception</code>             \u2013            <p>Any exceptions raised inside threads.</p> </li> </ul> Source code in <code>academy/agent.py</code> <pre><code>def shutdown(self) -&gt; None:\n    \"\"\"Shutdown the agent.\n\n    Note:\n        This method is idempotent.\n\n    1. Sets the shutdown [`Event`][threading.Event] passed to all control\n       loops.\n    1. Waits for any currently executing actions to complete.\n    1. Closes the agent's mailbox indicating that no further messages\n       will be processed.\n    1. Waits for the control loop and message listener threads to exit.\n    1. Optionally closes the exchange.\n    1. Calls\n       [`Behavior.on_shutdown()`][academy.behavior.Behavior.on_shutdown].\n\n    Raises:\n        Exception: Any exceptions raised inside threads.\n    \"\"\"\n    with self._state_lock:\n        if self._state is _AgentState.SHUTDOWN:\n            return\n\n        logger.debug(\n            'Shutting down agent... (expected: %s; %s; %s)',\n            self._expected_shutdown,\n            self.agent_id,\n            self.behavior,\n        )\n        self._state = _AgentState.TERMINTATING\n        self._shutdown.set()\n\n        # Cause the exchange message listener thread to exit by closing\n        # the mailbox the exchange is listening to. This is done\n        # first so we stop receiving new requests.\n        self.exchange.terminate(self.agent_id)\n        for future, name in self._loop_futures.items():\n            if name == '_exchange.listen':\n                future.result()\n\n        # Wait for currently running actions to complete. No more\n        # should come in now that exchange's listener thread is done.\n        if self._action_pool is not None:\n            self._action_pool.shutdown(wait=True, cancel_futures=True)\n\n        # Shutdown the loop pool after waiting on the loops to exit.\n        if self._loop_pool is not None:\n            self._loop_pool.shutdown(wait=True)\n\n        if (\n            self._expected_shutdown and not self.config.terminate_on_exit\n        ) or (\n            not self._expected_shutdown\n            and not self.config.terminate_on_error\n        ):\n            # TODO: This is a hack because we need to close the mailbox\n            # for the exchange listener thread to exit, but in some\n            # cases we don't actually want to close it permanently. This\n            # means there is a race where the mailbox is temporarily\n            # closed.\n            self.exchange.register_agent(\n                type(self.behavior),\n                agent_id=self.agent_id,\n            )\n\n        self.behavior.on_shutdown()\n\n        # Close the exchange last since the actions that finished\n        # up may still need to use it to send replies.\n        if self.config.close_exchange_on_exit:\n            self.exchange.close()\n\n        self._state = _AgentState.SHUTDOWN\n\n        # Raise any exceptions from the loop threads as the final step.\n        _raise_future_exceptions(tuple(self._loop_futures))\n\n        logger.info(\n            'Shutdown agent (%s; %s)',\n            self.agent_id,\n            self.behavior,\n        )\n</code></pre>"},{"location":"api/agent/#academy.agent.Agent.signal_shutdown","title":"signal_shutdown","text":"<pre><code>signal_shutdown(expected: bool = True) -&gt; None\n</code></pre> <p>Signal that the agent should exit.</p> <p>If the agent has not started, this will cause the agent to immediately shutdown when next started. If the agent is shutdown, this has no effect.</p> Source code in <code>academy/agent.py</code> <pre><code>def signal_shutdown(self, expected: bool = True) -&gt; None:\n    \"\"\"Signal that the agent should exit.\n\n    If the agent has not started, this will cause the agent to immediately\n    shutdown when next started. If the agent is shutdown, this has no\n    effect.\n    \"\"\"\n    self._expected_shutdown = expected\n    self._shutdown.set()\n</code></pre>"},{"location":"api/behavior/","title":"academy.behavior","text":"<code>academy/behavior.py</code>"},{"location":"api/behavior/#academy.behavior.Behavior","title":"Behavior","text":"<p>Agent behavior base class.</p> <p>All <code>Agent</code> instances execute a behavior which is defined by a subclass of the <code>Behavior</code>. Each behavior is composed of three parts:   1. The <code>on_startup()</code> and      <code>on_shutdown()</code> methods      define callbacks that are invoked once at the start and end of an      agent's execution, respectively. The methods should be used to      initialize and cleanup stateful resources. Resource initialization      should not be performed in <code>__init__</code>.   2. Action methods annotated with <code>@action</code>      are methods that other agents can invoke on this agent. An agent      may also call it's own action methods as normal methods.   3. Control loop methods annotated with <code>@loop</code>      are executed in separate threads when the agent is executed.</p> Warning <p>This class cannot be instantiated directly and must be subclassed.</p>"},{"location":"api/behavior/#academy.behavior.Behavior.behavior_actions","title":"behavior_actions","text":"<pre><code>behavior_actions() -&gt; dict[str, Action[Any, Any]]\n</code></pre> <p>Get methods of this behavior type that are decorated as actions.</p> <p>Returns:</p> <ul> <li> <code>dict[str, Action[Any, Any]]</code>           \u2013            <p>Dictionary mapping method names to action methods.</p> </li> </ul> Source code in <code>academy/behavior.py</code> <pre><code>def behavior_actions(self) -&gt; dict[str, Action[Any, Any]]:\n    \"\"\"Get methods of this behavior type that are decorated as actions.\n\n    Returns:\n        Dictionary mapping method names to action methods.\n    \"\"\"\n    actions: dict[str, Action[Any, Any]] = {}\n    for name in dir(self):\n        attr = getattr(self, name)\n        if _is_agent_method_type(attr, 'action'):\n            actions[name] = attr\n    return actions\n</code></pre>"},{"location":"api/behavior/#academy.behavior.Behavior.behavior_loops","title":"behavior_loops","text":"<pre><code>behavior_loops() -&gt; dict[str, ControlLoop]\n</code></pre> <p>Get methods of this behavior type that are decorated as loops.</p> <p>Returns:</p> <ul> <li> <code>dict[str, ControlLoop]</code>           \u2013            <p>Dictionary mapping method names to loop methods.</p> </li> </ul> Source code in <code>academy/behavior.py</code> <pre><code>def behavior_loops(self) -&gt; dict[str, ControlLoop]:\n    \"\"\"Get methods of this behavior type that are decorated as loops.\n\n    Returns:\n        Dictionary mapping method names to loop methods.\n    \"\"\"\n    loops: dict[str, ControlLoop] = {}\n    for name in dir(self):\n        attr = getattr(self, name)\n        if _is_agent_method_type(attr, 'loop'):\n            loops[name] = attr\n    return loops\n</code></pre>"},{"location":"api/behavior/#academy.behavior.Behavior.behavior_handles","title":"behavior_handles","text":"<pre><code>behavior_handles() -&gt; dict[\n    str,\n    Handle[Any] | HandleDict[Any, Any] | HandleList[Any],\n]\n</code></pre> <p>Get instance attributes that are agent handles.</p> <p>Returns:</p> <ul> <li> <code>dict[str, Handle[Any] | HandleDict[Any, Any] | HandleList[Any]]</code>           \u2013            <p>Dictionary mapping attribute names to agent handles or             data structures of handles.</p> </li> </ul> Source code in <code>academy/behavior.py</code> <pre><code>def behavior_handles(\n    self,\n) -&gt; dict[\n    str,\n    Handle[Any] | HandleDict[Any, Any] | HandleList[Any],\n]:\n    \"\"\"Get instance attributes that are agent handles.\n\n    Returns:\n        Dictionary mapping attribute names to agent handles or \\\n        data structures of handles.\n    \"\"\"\n    from academy.handle import Handle\n\n    # This import is deferred to prevent a cyclic import with\n    # academy.handle.\n    handles: dict[\n        str,\n        Handle[Any] | HandleDict[Any, Any] | HandleList[Any],\n    ] = {}\n    for name in dir(self):\n        attr = getattr(self, name)\n        if isinstance(attr, (Handle, HandleDict, HandleList)):\n            handles[name] = attr\n    return handles\n</code></pre>"},{"location":"api/behavior/#academy.behavior.Behavior.behavior_handles_bind","title":"behavior_handles_bind","text":"<pre><code>behavior_handles_bind(\n    bind: Callable[[Handle[BehaviorT]], Handle[BehaviorT]],\n) -&gt; None\n</code></pre> <p>Bind all instance attributes that are agent handles.</p> <p>Parameters:</p> <ul> <li> <code>bind</code>               (<code>Callable[[Handle[BehaviorT]], Handle[BehaviorT]]</code>)           \u2013            <p>A callback that takes a handle and returns the same handle or a bound version of the handle.</p> </li> </ul> Source code in <code>academy/behavior.py</code> <pre><code>def behavior_handles_bind(\n    self,\n    bind: Callable[[Handle[BehaviorT]], Handle[BehaviorT]],\n) -&gt; None:\n    \"\"\"Bind all instance attributes that are agent handles.\n\n    Args:\n        bind: A callback that takes a handle and returns the same handle\n            or a bound version of the handle.\n    \"\"\"\n    for attr, handles in self.behavior_handles().items():\n        if isinstance(handles, Handle):\n            setattr(self, attr, bind(handles))\n        elif isinstance(handles, HandleDict):\n            setattr(\n                self,\n                attr,\n                HandleDict({k: bind(h) for k, h in handles.items()}),\n            )\n        elif isinstance(handles, HandleList):\n            setattr(self, attr, HandleList(bind(h) for h in handles))\n        else:\n            raise AssertionError('Unreachable.')\n</code></pre>"},{"location":"api/behavior/#academy.behavior.Behavior.behavior_mro","title":"behavior_mro  <code>classmethod</code>","text":"<pre><code>behavior_mro() -&gt; tuple[str, ...]\n</code></pre> <p>Get the method resolution order of the behavior.</p> Example <pre><code>&gt;&gt;&gt; from academy.behavior import Behavior\n&gt;&gt;&gt;\n&gt;&gt;&gt; class A(Behavior): ...\n&gt;&gt;&gt; class B(Behavior): ...\n&gt;&gt;&gt; class C(A): ...\n&gt;&gt;&gt; class D(A, B): ...\n&gt;&gt;&gt;\n&gt;&gt;&gt; A.behavior_mro()\n('__main__.A',)\n&gt;&gt;&gt; B.behavior_mro()\n('__main__.B',)\n&gt;&gt;&gt; C.behavior_mro()\n('__main__.C', '__main__.A')\n&gt;&gt;&gt; D.behavior_mro()\n('__main__.D', '__main__.A', '__main__.B')\n</code></pre> <p>Returns:</p> <ul> <li> <code>tuple[str, ...]</code>           \u2013            <p>Tuple of fully-qualified paths of types in the MRO of this             behavior type, not including the base             <code>Behavior</code> or <code>object</code>.</p> </li> </ul> Source code in <code>academy/behavior.py</code> <pre><code>@classmethod\ndef behavior_mro(cls) -&gt; tuple[str, ...]:\n    \"\"\"Get the method resolution order of the behavior.\n\n    Example:\n        ```python\n        &gt;&gt;&gt; from academy.behavior import Behavior\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; class A(Behavior): ...\n        &gt;&gt;&gt; class B(Behavior): ...\n        &gt;&gt;&gt; class C(A): ...\n        &gt;&gt;&gt; class D(A, B): ...\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; A.behavior_mro()\n        ('__main__.A',)\n        &gt;&gt;&gt; B.behavior_mro()\n        ('__main__.B',)\n        &gt;&gt;&gt; C.behavior_mro()\n        ('__main__.C', '__main__.A')\n        &gt;&gt;&gt; D.behavior_mro()\n        ('__main__.D', '__main__.A', '__main__.B')\n        ```\n\n    Returns:\n        Tuple of fully-qualified paths of types in the MRO of this \\\n        behavior type, not including the base \\\n        [`Behavior`][academy.behavior.Behavior] or [`object`][object].\n    \"\"\"\n    mro = cls.mro()\n    base_index = mro.index(Behavior)\n    mro = mro[:base_index]\n    return tuple(f'{t.__module__}.{t.__qualname__}' for t in mro)\n</code></pre>"},{"location":"api/behavior/#academy.behavior.Behavior.on_setup","title":"on_setup","text":"<pre><code>on_setup() -&gt; None\n</code></pre> <p>Setup up resources needed for the agents execution.</p> <p>This is called before any control loop threads are started.</p> Source code in <code>academy/behavior.py</code> <pre><code>def on_setup(self) -&gt; None:\n    \"\"\"Setup up resources needed for the agents execution.\n\n    This is called before any control loop threads are started.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/behavior/#academy.behavior.Behavior.on_shutdown","title":"on_shutdown","text":"<pre><code>on_shutdown() -&gt; None\n</code></pre> <p>Shutdown resources after the agents execution.</p> <p>This is called after control loop threads have exited.</p> Source code in <code>academy/behavior.py</code> <pre><code>def on_shutdown(self) -&gt; None:\n    \"\"\"Shutdown resources after the agents execution.\n\n    This is called after control loop threads have exited.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/behavior/#academy.behavior.Action","title":"Action","text":"<p>               Bases: <code>Generic[P, R_co]</code>, <code>Protocol</code></p> <p>Action method protocol.</p>"},{"location":"api/behavior/#academy.behavior.Action.__call__","title":"__call__","text":"<pre><code>__call__(*arg: args, **kwargs: kwargs) -&gt; R_co\n</code></pre> <p>Expected signature of methods decorated as an action.</p> <p>In general, action methods can implement any signature.</p> Source code in <code>academy/behavior.py</code> <pre><code>def __call__(self, *arg: P.args, **kwargs: P.kwargs) -&gt; R_co:\n    \"\"\"Expected signature of methods decorated as an action.\n\n    In general, action methods can implement any signature.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/behavior/#academy.behavior.ControlLoop","title":"ControlLoop","text":"<p>               Bases: <code>Protocol</code></p> <p>Control loop method protocol.</p>"},{"location":"api/behavior/#academy.behavior.ControlLoop.__call__","title":"__call__","text":"<pre><code>__call__(shutdown: Event) -&gt; None\n</code></pre> <p>Expected signature of methods decorated as a control loop.</p> <p>Parameters:</p> <ul> <li> <code>shutdown</code>               (<code>Event</code>)           \u2013            <p>Event indicating that the agent has been instructed to shutdown and all control loops should exit.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>Control loops should not return anything.</p> </li> </ul> Source code in <code>academy/behavior.py</code> <pre><code>def __call__(self, shutdown: threading.Event) -&gt; None:\n    \"\"\"Expected signature of methods decorated as a control loop.\n\n    Args:\n        shutdown: Event indicating that the agent has been instructed to\n            shutdown and all control loops should exit.\n\n    Returns:\n        Control loops should not return anything.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/behavior/#academy.behavior.action","title":"action","text":"<pre><code>action(method: Callable[P, R]) -&gt; Callable[P, R]\n</code></pre> <p>Decorator that annotates a method of a behavior as an action.</p> <p>Marking a method of a behavior as an action makes the method available to other agents. I.e., peers within a multi-agent system can only invoke methods marked as actions on each other. This enables behaviors to define \"private\" methods.</p> Example <pre><code>from academy.behavior import Behavior, action\n\nclass Example(Behavior):\n    @action\n    def perform(self):\n        ...\n</code></pre> Source code in <code>academy/behavior.py</code> <pre><code>def action(method: Callable[P, R]) -&gt; Callable[P, R]:\n    \"\"\"Decorator that annotates a method of a behavior as an action.\n\n    Marking a method of a behavior as an action makes the method available\n    to other agents. I.e., peers within a multi-agent system can only invoke\n    methods marked as actions on each other. This enables behaviors to\n    define \"private\" methods.\n\n    Example:\n        ```python\n        from academy.behavior import Behavior, action\n\n        class Example(Behavior):\n            @action\n            def perform(self):\n                ...\n        ```\n    \"\"\"\n    method._agent_method_type = 'action'  # type: ignore[attr-defined]\n    return method\n</code></pre>"},{"location":"api/behavior/#academy.behavior.loop","title":"loop","text":"<pre><code>loop(\n    method: Callable[Concatenate[BehaviorT, P], R],\n) -&gt; Callable[Concatenate[BehaviorT, P], R]\n</code></pre> <p>Decorator that annotates a method of a behavior as a control loop.</p> <p>Control loop methods of a behavior are run as threads when an agent starts. A control loop can run for a well-defined period of time or indefinitely, provided the control loop exits when the <code>shutdown</code> event, passed as a parameter to all control loop methods, is set.</p> Example <pre><code>import threading\nfrom academy.behavior import Behavior, loop\n\nclass Example(Behavior):\n    @loop\n    def listen(self, shutdown: threading.Event) -&gt; None:\n        while not shutdown.is_set():\n            ...\n</code></pre> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>if the method signature does not conform to the <code>ControlLoop</code> protocol.</p> </li> </ul> Source code in <code>academy/behavior.py</code> <pre><code>def loop(\n    method: Callable[Concatenate[BehaviorT, P], R],\n) -&gt; Callable[Concatenate[BehaviorT, P], R]:\n    \"\"\"Decorator that annotates a method of a behavior as a control loop.\n\n    Control loop methods of a behavior are run as threads when an agent\n    starts. A control loop can run for a well-defined period of time or\n    indefinitely, provided the control loop exits when the `shutdown`\n    event, passed as a parameter to all control loop methods, is set.\n\n    Example:\n        ```python\n        import threading\n        from academy.behavior import Behavior, loop\n\n        class Example(Behavior):\n            @loop\n            def listen(self, shutdown: threading.Event) -&gt; None:\n                while not shutdown.is_set():\n                    ...\n        ```\n\n    Raises:\n        TypeError: if the method signature does not conform to the\n            [`ControlLoop`][academy.behavior.ControlLoop] protocol.\n    \"\"\"\n    method._agent_method_type = 'loop'  # type: ignore[attr-defined]\n\n    if sys.version_info &gt;= (3, 10):  # pragma: &gt;=3.10 cover\n        found_sig = inspect.signature(method, eval_str=True)\n        expected_sig = inspect.signature(ControlLoop.__call__, eval_str=True)\n    else:  # pragma: &lt;3.10 cover\n        found_sig = inspect.signature(method)\n        expected_sig = inspect.signature(ControlLoop.__call__)\n\n    if found_sig != expected_sig:\n        raise TypeError(\n            f'Signature of loop method \"{method.__name__}\" is {found_sig} '\n            f'but should be {expected_sig}. If the signatures look the same '\n            'except that types are stringified, try importing '\n            '\"from __future__ import annotations\" at the top of the module '\n            'where the behavior is defined.',\n        )\n\n    @functools.wraps(method)\n    def _wrapped(self: BehaviorT, *args: P.args, **kwargs: P.kwargs) -&gt; R:\n        logger.debug('Started %r loop for %s', method.__name__, self)\n        result = method(self, *args, **kwargs)\n        logger.debug('Exited %r loop for %s', method.__name__, self)\n        return result\n\n    return _wrapped\n</code></pre>"},{"location":"api/behavior/#academy.behavior.event","title":"event","text":"<pre><code>event(\n    name: str,\n) -&gt; Callable[\n    [Callable[[BehaviorT], None]],\n    Callable[[BehaviorT, Event], None],\n]\n</code></pre> <p>Decorator that annotates a method of a behavior as an event loop.</p> <p>An event loop is a special type of control loop that runs when a <code>threading.Event</code> is set. The event is cleared after the loop runs.</p> Example <pre><code>import threading\nfrom academy.behavior import Behavior, timer\n\nclass Example(Behavior):\n    def __init__(self) -&gt; None:\n        self.alert = threading.Event()\n\n    @event('alert')\n    def handle(self) -&gt; None:\n        # Runs every time alter is set\n        ...\n</code></pre> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Attribute name of the <code>threading.Event</code> to wait on.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>AttributeError</code>             \u2013            <p>Raised at runtime if no attribute named <code>name</code> exists on the behavior.</p> </li> <li> <code>TypeError</code>             \u2013            <p>Raised at runtime if the attribute named <code>name</code> is not a <code>threading.Event</code>.</p> </li> </ul> Source code in <code>academy/behavior.py</code> <pre><code>def event(\n    name: str,\n) -&gt; Callable[\n    [Callable[[BehaviorT], None]],\n    Callable[[BehaviorT, threading.Event], None],\n]:\n    \"\"\"Decorator that annotates a method of a behavior as an event loop.\n\n    An event loop is a special type of control loop that runs when a\n    [`threading.Event`][threading.Event] is set. The event is cleared\n    after the loop runs.\n\n    Example:\n        ```python\n        import threading\n        from academy.behavior import Behavior, timer\n\n        class Example(Behavior):\n            def __init__(self) -&gt; None:\n                self.alert = threading.Event()\n\n            @event('alert')\n            def handle(self) -&gt; None:\n                # Runs every time alter is set\n                ...\n        ```\n\n    Args:\n        name: Attribute name of the [`threading.Event`][threading.Event]\n            to wait on.\n\n    Raises:\n        AttributeError: Raised at runtime if no attribute named `name`\n            exists on the behavior.\n        TypeError: Raised at runtime if the attribute named `name` is not\n            a [`threading.Event`][threading.Event].\n    \"\"\"\n\n    def decorator(\n        method: Callable[[BehaviorT], None],\n    ) -&gt; Callable[[BehaviorT, threading.Event], None]:\n        method._agent_method_type = 'loop'  # type: ignore[attr-defined]\n\n        @functools.wraps(method)\n        def _wrapped(self: BehaviorT, shutdown: threading.Event) -&gt; None:\n            event = getattr(self, name)\n            if not isinstance(event, threading.Event):\n                raise TypeError(\n                    f'Attribute {name} of {type(self).__class__} has type '\n                    f'{type(event).__class__}. Expected threading.Event.',\n                )\n\n            logger.debug(\n                'Started %r event loop for %s (event: %r)',\n                method.__name__,\n                self,\n                name,\n            )\n            combined = or_event(shutdown, event)\n            while True:\n                combined.wait()\n                if shutdown.is_set():\n                    break\n                elif event.is_set():\n                    try:\n                        method(self)\n                    finally:\n                        event.clear()\n                else:\n                    raise AssertionError('Unreachable.')\n            logger.debug('Exited %r event loop for %s', method.__name__, self)\n\n        return _wrapped\n\n    return decorator\n</code></pre>"},{"location":"api/behavior/#academy.behavior.timer","title":"timer","text":"<pre><code>timer(\n    interval: float | timedelta,\n) -&gt; Callable[\n    [Callable[[BehaviorT], None]],\n    Callable[[BehaviorT, Event], None],\n]\n</code></pre> <p>Decorator that annotates a method of a behavior as a timer loop.</p> <p>A timer loop is a special type of control loop that runs at a set interval. The method will always be called once before the first sleep.</p> Example <pre><code>from academy.behavior import Behavior, timer\n\nclass Example(Behavior):\n    @timer(interval=1)\n    def listen(self) -&gt; None:\n        # Runs every 1 second\n        ...\n</code></pre> <p>Parameters:</p> <ul> <li> <code>interval</code>               (<code>float | timedelta</code>)           \u2013            <p>Seconds or a <code>timedelta</code> to wait between invoking the method.</p> </li> </ul> Source code in <code>academy/behavior.py</code> <pre><code>def timer(\n    interval: float | timedelta,\n) -&gt; Callable[\n    [Callable[[BehaviorT], None]],\n    Callable[[BehaviorT, threading.Event], None],\n]:\n    \"\"\"Decorator that annotates a method of a behavior as a timer loop.\n\n    A timer loop is a special type of control loop that runs at a set\n    interval. The method will always be called once before the first\n    sleep.\n\n    Example:\n        ```python\n        from academy.behavior import Behavior, timer\n\n        class Example(Behavior):\n            @timer(interval=1)\n            def listen(self) -&gt; None:\n                # Runs every 1 second\n                ...\n        ```\n\n    Args:\n        interval: Seconds or a [`timedelta`][datetime.timedelta] to wait\n            between invoking the method.\n    \"\"\"\n    interval = (\n        interval.total_seconds()\n        if isinstance(interval, timedelta)\n        else interval\n    )\n\n    def decorator(\n        method: Callable[[BehaviorT], None],\n    ) -&gt; Callable[[BehaviorT, threading.Event], None]:\n        method._agent_method_type = 'loop'  # type: ignore[attr-defined]\n\n        @functools.wraps(method)\n        def _wrapped(self: BehaviorT, shutdown: threading.Event) -&gt; None:\n            logger.debug(\n                'Started %r timer loop for %s (interval: %fs)',\n                method.__name__,\n                self,\n                interval,\n            )\n            while not shutdown.wait(interval):\n                method(self)\n            logger.debug('Exited %r timer loop for %s', method.__name__, self)\n\n        return _wrapped\n\n    return decorator\n</code></pre>"},{"location":"api/event/","title":"academy.event","text":"<code>academy/event.py</code>"},{"location":"api/event/#academy.event.or_event","title":"or_event","text":"<pre><code>or_event(*events: Event) -&gt; Event\n</code></pre> <p>Create a combined event that is set when any input events are set.</p> Note <p>The creator can wait on the combined event, but must still check each individual event to see which was set.</p> Warning <p>This works by dynamically replacing methods on the inputs events with custom methods that trigger callbacks.</p> Note <p>Based on this Stack Overflow answer.</p> <p>Parameters:</p> <ul> <li> <code>events</code>               (<code>Event</code>, default:                   <code>()</code> )           \u2013            <p>One or more events to combine.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Event</code>           \u2013            <p>A single event that is set when any of the input events is set.</p> </li> </ul> Source code in <code>academy/event.py</code> <pre><code>def or_event(*events: threading.Event) -&gt; threading.Event:\n    \"\"\"Create a combined event that is set when any input events are set.\n\n    Note:\n        The creator can wait on the combined event, but must still check\n        each individual event to see which was set.\n\n    Warning:\n        This works by dynamically replacing methods on the inputs events\n        with custom methods that trigger callbacks.\n\n    Note:\n        Based on this Stack Overflow\n        [answer](https://stackoverflow.com/a/12320352).\n\n    Args:\n        events: One or more events to combine.\n\n    Returns:\n        A single event that is set when any of the input events is set.\n    \"\"\"\n    combined = threading.Event()\n\n    def changed() -&gt; None:\n        bools = [e.is_set() for e in events]\n        if any(bools):\n            combined.set()\n        else:\n            combined.clear()\n\n    for e in events:\n        _orify(e, changed)\n\n    changed()\n    return combined\n</code></pre>"},{"location":"api/exception/","title":"academy.exception","text":"<code>academy/exception.py</code>"},{"location":"api/exception/#academy.exception.BadEntityIdError","title":"BadEntityIdError","text":"<pre><code>BadEntityIdError(uid: EntityId)\n</code></pre> <p>               Bases: <code>Exception</code></p> <p>Entity associated with the identifier is unknown.</p> Source code in <code>academy/exception.py</code> <pre><code>def __init__(self, uid: EntityId) -&gt; None:\n    super().__init__(f'Unknown identifier {uid}.')\n</code></pre>"},{"location":"api/exception/#academy.exception.HandleClosedError","title":"HandleClosedError","text":"<pre><code>HandleClosedError(\n    agent_id: AgentId[Any], mailbox_id: EntityId | None\n)\n</code></pre> <p>               Bases: <code>Exception</code></p> <p>Agent handle has been closed.</p> Source code in <code>academy/exception.py</code> <pre><code>def __init__(\n    self,\n    agent_id: AgentId[Any],\n    mailbox_id: EntityId | None,\n) -&gt; None:\n    message = (\n        f'Handle to {agent_id} bound to {mailbox_id} has been closed.'\n        if mailbox_id is not None\n        else f'Handle to {agent_id} has been closed.'\n    )\n    super().__init__(message)\n</code></pre>"},{"location":"api/exception/#academy.exception.HandleNotBoundError","title":"HandleNotBoundError","text":"<pre><code>HandleNotBoundError(aid: AgentId[Any])\n</code></pre> <p>               Bases: <code>Exception</code></p> <p>Handle to agent is in an unbound state.</p> <p>An unbound handle (typically, an instance of <code>UnboundRemoteHandle</code>) is initialized with a target agent ID and exchange, but does not have an identifier itself. Thus, the handle does not have a mailbox in the exchange to receive response messages.</p> <p>A handle must be bound to be used, either as a unique client with its own mailbox or as bound to a running agent where it shares a mailbox with that running agent. To create a client bound handle, use <code>handle.bind_to_exchange()</code>.</p> <p>Any agent behavior that has a handle to another agent as an instance attribute will be automatically bound to the agent when the agent begins running.</p> Source code in <code>academy/exception.py</code> <pre><code>def __init__(self, aid: AgentId[Any]) -&gt; None:\n    super().__init__(\n        f'Handle to {aid} to an exchange. See the exception docstring '\n        'for troubleshooting.',\n    )\n</code></pre>"},{"location":"api/exception/#academy.exception.MailboxClosedError","title":"MailboxClosedError","text":"<pre><code>MailboxClosedError(uid: EntityId)\n</code></pre> <p>               Bases: <code>Exception</code></p> <p>Mailbox is closed and cannot send or receive messages.</p> Source code in <code>academy/exception.py</code> <pre><code>def __init__(self, uid: EntityId) -&gt; None:\n    super().__init__(f'Mailbox for {uid} has been closed.')\n</code></pre>"},{"location":"api/handle/","title":"academy.handle","text":"<code>academy/handle.py</code>"},{"location":"api/handle/#academy.handle.Handle","title":"Handle","text":"<p>               Bases: <code>Protocol[BehaviorT]</code></p> <p>Agent handle protocol.</p> <p>A handle enables a client or agent to invoke actions on another agent.</p>"},{"location":"api/handle/#academy.handle.Handle.action","title":"action","text":"<pre><code>action(\n    action: str, /, *args: Any, **kwargs: Any\n) -&gt; Future[R]\n</code></pre> <p>Invoke an action on the agent.</p> <p>Parameters:</p> <ul> <li> <code>action</code>               (<code>str</code>)           \u2013            <p>Action to invoke.</p> </li> <li> <code>args</code>               (<code>Any</code>, default:                   <code>()</code> )           \u2013            <p>Positional arguments for the action.</p> </li> <li> <code>kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Keywords arguments for the action.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Future[R]</code>           \u2013            <p>Future to the result of the action.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>HandleClosedError</code>             \u2013            <p>If the handle was closed.</p> </li> <li> <code>MailboxClosedError</code>             \u2013            <p>If the agent's mailbox was closed. This typically indicates the agent shutdown for another reason (it self terminated or via another handle).</p> </li> </ul> Source code in <code>academy/handle.py</code> <pre><code>def action(\n    self,\n    action: str,\n    /,\n    *args: Any,\n    **kwargs: Any,\n) -&gt; Future[R]:\n    \"\"\"Invoke an action on the agent.\n\n    Args:\n        action: Action to invoke.\n        args: Positional arguments for the action.\n        kwargs: Keywords arguments for the action.\n\n    Returns:\n        Future to the result of the action.\n\n    Raises:\n        HandleClosedError: If the handle was closed.\n        MailboxClosedError: If the agent's mailbox was closed. This\n            typically indicates the agent shutdown for another reason\n            (it self terminated or via another handle).\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/handle/#academy.handle.Handle.close","title":"close","text":"<pre><code>close(\n    wait_futures: bool = True,\n    *,\n    timeout: float | None = None\n) -&gt; None\n</code></pre> <p>Close this handle.</p> <p>Parameters:</p> <ul> <li> <code>wait_futures</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Wait to return until all pending futures are done executing. If <code>False</code>, pending futures are cancelled.</p> </li> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional timeout used when <code>wait=True</code>.</p> </li> </ul> Source code in <code>academy/handle.py</code> <pre><code>def close(\n    self,\n    wait_futures: bool = True,\n    *,\n    timeout: float | None = None,\n) -&gt; None:\n    \"\"\"Close this handle.\n\n    Args:\n        wait_futures: Wait to return until all pending futures are done\n            executing. If `False`, pending futures are cancelled.\n        timeout: Optional timeout used when `wait=True`.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/handle/#academy.handle.Handle.ping","title":"ping","text":"<pre><code>ping(*, timeout: float | None = None) -&gt; float\n</code></pre> <p>Ping the agent.</p> <p>Ping the agent and wait to get a response. Agents process messages in order so the round-trip time will include processing time of earlier messages in the queue.</p> <p>Parameters:</p> <ul> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional timeout in seconds to wait for the response.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>Round-trip time in seconds.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>HandleClosedError</code>             \u2013            <p>If the handle was closed.</p> </li> <li> <code>MailboxClosedError</code>             \u2013            <p>If the agent's mailbox was closed. This typically indicates the agent shutdown for another reason (it self terminated or via another handle).</p> </li> <li> <code>TimeoutError</code>             \u2013            <p>If the timeout is exceeded.</p> </li> </ul> Source code in <code>academy/handle.py</code> <pre><code>def ping(self, *, timeout: float | None = None) -&gt; float:\n    \"\"\"Ping the agent.\n\n    Ping the agent and wait to get a response. Agents process messages\n    in order so the round-trip time will include processing time of\n    earlier messages in the queue.\n\n    Args:\n        timeout: Optional timeout in seconds to wait for the response.\n\n    Returns:\n        Round-trip time in seconds.\n\n    Raises:\n        HandleClosedError: If the handle was closed.\n        MailboxClosedError: If the agent's mailbox was closed. This\n            typically indicates the agent shutdown for another reason\n            (it self terminated or via another handle).\n        TimeoutError: If the timeout is exceeded.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/handle/#academy.handle.Handle.shutdown","title":"shutdown","text":"<pre><code>shutdown() -&gt; None\n</code></pre> <p>Instruct the agent to shutdown.</p> <p>This is non-blocking and will only send the message.</p> <p>Raises:</p> <ul> <li> <code>HandleClosedError</code>             \u2013            <p>If the handle was closed.</p> </li> <li> <code>MailboxClosedError</code>             \u2013            <p>If the agent's mailbox was closed. This typically indicates the agent shutdown for another reason (it self terminated or via another handle).</p> </li> </ul> Source code in <code>academy/handle.py</code> <pre><code>def shutdown(self) -&gt; None:\n    \"\"\"Instruct the agent to shutdown.\n\n    This is non-blocking and will only send the message.\n\n    Raises:\n        HandleClosedError: If the handle was closed.\n        MailboxClosedError: If the agent's mailbox was closed. This\n            typically indicates the agent shutdown for another reason\n            (it self terminated or via another handle).\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/handle/#academy.handle.HandleDict","title":"HandleDict","text":"<pre><code>HandleDict(\n    values: (\n        Mapping[K, Handle[BehaviorT]]\n        | Iterable[tuple[K, Handle[BehaviorT]]]\n    ) = (),\n    /,\n    **kwargs: dict[str, Handle[BehaviorT]],\n)\n</code></pre> <p>               Bases: <code>dict[K, Handle[BehaviorT]]</code></p> <p>Dictionary mapping keys to handles.</p> Tip <p>The <code>HandleDict</code> is required when storing a mapping of handles as attributes of a <code>Behavior</code> so that those handles get bound to the correct agent when running.</p> Source code in <code>academy/handle.py</code> <pre><code>def __init__(\n    self,\n    values: Mapping[K, Handle[BehaviorT]]\n    | Iterable[tuple[K, Handle[BehaviorT]]] = (),\n    /,\n    **kwargs: dict[str, Handle[BehaviorT]],\n) -&gt; None:\n    super().__init__(values, **kwargs)\n</code></pre>"},{"location":"api/handle/#academy.handle.HandleList","title":"HandleList","text":"<pre><code>HandleList(iterable: Iterable[Handle[BehaviorT]] = ())\n</code></pre> <p>               Bases: <code>list[Handle[BehaviorT]]</code></p> <p>List of handles.</p> Tip <p>The <code>HandleList</code> is required when storing a list of handles as attributes of a <code>Behavior</code> so that those handles get bound to the correct agent when running.</p> Source code in <code>academy/handle.py</code> <pre><code>def __init__(\n    self,\n    iterable: Iterable[Handle[BehaviorT]] = (),\n    /,\n) -&gt; None:\n    super().__init__(iterable)\n</code></pre>"},{"location":"api/handle/#academy.handle.ProxyHandle","title":"ProxyHandle","text":"<pre><code>ProxyHandle(behavior: BehaviorT)\n</code></pre> <p>               Bases: <code>Generic[BehaviorT]</code></p> <p>Proxy handle.</p> <p>A proxy handle is thin wrapper around a <code>Behavior</code> instance that is useful for testing behaviors that are initialized with a handle to another agent without needing to spawn agents. This wrapper invokes actions synchronously.</p> Source code in <code>academy/handle.py</code> <pre><code>def __init__(self, behavior: BehaviorT) -&gt; None:\n    self.behavior = behavior\n    self.agent_id: AgentId[BehaviorT] = AgentId.new()\n    self.mailbox_id: EntityId | None = None\n    self._agent_closed = False\n    self._handle_closed = False\n</code></pre>"},{"location":"api/handle/#academy.handle.ProxyHandle.action","title":"action","text":"<pre><code>action(\n    action: str, /, *args: Any, **kwargs: Any\n) -&gt; Future[R]\n</code></pre> <p>Invoke an action on the agent.</p> <p>Parameters:</p> <ul> <li> <code>action</code>               (<code>str</code>)           \u2013            <p>Action to invoke.</p> </li> <li> <code>args</code>               (<code>Any</code>, default:                   <code>()</code> )           \u2013            <p>Positional arguments for the action.</p> </li> <li> <code>kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Keywords arguments for the action.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Future[R]</code>           \u2013            <p>Future to the result of the action.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>HandleClosedError</code>             \u2013            <p>If the handle was closed.</p> </li> <li> <code>MailboxClosedError</code>             \u2013            <p>If the agent's mailbox was closed. This typically indicates the agent shutdown for another reason (it self terminated or via another handle).</p> </li> </ul> Source code in <code>academy/handle.py</code> <pre><code>def action(\n    self,\n    action: str,\n    /,\n    *args: Any,\n    **kwargs: Any,\n) -&gt; Future[R]:\n    \"\"\"Invoke an action on the agent.\n\n    Args:\n        action: Action to invoke.\n        args: Positional arguments for the action.\n        kwargs: Keywords arguments for the action.\n\n    Returns:\n        Future to the result of the action.\n\n    Raises:\n        HandleClosedError: If the handle was closed.\n        MailboxClosedError: If the agent's mailbox was closed. This\n            typically indicates the agent shutdown for another reason\n            (it self terminated or via another handle).\n    \"\"\"\n    if self._agent_closed:\n        raise MailboxClosedError(self.agent_id)\n    elif self._handle_closed:\n        raise HandleClosedError(self.agent_id, self.mailbox_id)\n\n    future: Future[R] = Future()\n    try:\n        method = getattr(self.behavior, action)\n        result = method(*args, **kwargs)\n    except Exception as e:\n        future.set_exception(e)\n    else:\n        future.set_result(result)\n    return future\n</code></pre>"},{"location":"api/handle/#academy.handle.ProxyHandle.close","title":"close","text":"<pre><code>close(\n    wait_futures: bool = True,\n    *,\n    timeout: float | None = None\n) -&gt; None\n</code></pre> <p>Close this handle.</p> Note <p>This is a no-op for proxy handles.</p> <p>Parameters:</p> <ul> <li> <code>wait_futures</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Wait to return until all pending futures are done executing. If <code>False</code>, pending futures are cancelled.</p> </li> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional timeout used when <code>wait=True</code>.</p> </li> </ul> Source code in <code>academy/handle.py</code> <pre><code>def close(\n    self,\n    wait_futures: bool = True,\n    *,\n    timeout: float | None = None,\n) -&gt; None:\n    \"\"\"Close this handle.\n\n    Note:\n        This is a no-op for proxy handles.\n\n    Args:\n        wait_futures: Wait to return until all pending futures are done\n            executing. If `False`, pending futures are cancelled.\n        timeout: Optional timeout used when `wait=True`.\n    \"\"\"\n    self._handle_closed = True\n</code></pre>"},{"location":"api/handle/#academy.handle.ProxyHandle.ping","title":"ping","text":"<pre><code>ping(*, timeout: float | None = None) -&gt; float\n</code></pre> <p>Ping the agent.</p> <p>Ping the agent and wait to get a response. Agents process messages in order so the round-trip time will include processing time of earlier messages in the queue.</p> Note <p>This is a no-op for proxy handles and returns 0 latency.</p> <p>Parameters:</p> <ul> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional timeout in seconds to wait for the response.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>Round-trip time in seconds.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>HandleClosedError</code>             \u2013            <p>If the handle was closed.</p> </li> <li> <code>MailboxClosedError</code>             \u2013            <p>If the agent's mailbox was closed. This typically indicates the agent shutdown for another reason (it self terminated or via another handle).</p> </li> <li> <code>TimeoutError</code>             \u2013            <p>If the timeout is exceeded.</p> </li> </ul> Source code in <code>academy/handle.py</code> <pre><code>def ping(self, *, timeout: float | None = None) -&gt; float:\n    \"\"\"Ping the agent.\n\n    Ping the agent and wait to get a response. Agents process messages\n    in order so the round-trip time will include processing time of\n    earlier messages in the queue.\n\n    Note:\n        This is a no-op for proxy handles and returns 0 latency.\n\n    Args:\n        timeout: Optional timeout in seconds to wait for the response.\n\n    Returns:\n        Round-trip time in seconds.\n\n    Raises:\n        HandleClosedError: If the handle was closed.\n        MailboxClosedError: If the agent's mailbox was closed. This\n            typically indicates the agent shutdown for another reason\n            (it self terminated or via another handle).\n        TimeoutError: If the timeout is exceeded.\n    \"\"\"\n    if self._agent_closed:\n        raise MailboxClosedError(self.agent_id)\n    elif self._handle_closed:\n        raise HandleClosedError(self.agent_id, self.mailbox_id)\n    return 0\n</code></pre>"},{"location":"api/handle/#academy.handle.ProxyHandle.shutdown","title":"shutdown","text":"<pre><code>shutdown() -&gt; None\n</code></pre> <p>Instruct the agent to shutdown.</p> <p>This is non-blocking and will only send the message.</p> <p>Raises:</p> <ul> <li> <code>HandleClosedError</code>             \u2013            <p>If the handle was closed.</p> </li> <li> <code>MailboxClosedError</code>             \u2013            <p>If the agent's mailbox was closed. This typically indicates the agent shutdown for another reason (it self terminated or via another handle).</p> </li> </ul> Source code in <code>academy/handle.py</code> <pre><code>def shutdown(self) -&gt; None:\n    \"\"\"Instruct the agent to shutdown.\n\n    This is non-blocking and will only send the message.\n\n    Raises:\n        HandleClosedError: If the handle was closed.\n        MailboxClosedError: If the agent's mailbox was closed. This\n            typically indicates the agent shutdown for another reason\n            (it self terminated or via another handle).\n    \"\"\"\n    if self._agent_closed:\n        raise MailboxClosedError(self.agent_id)\n    elif self._handle_closed:\n        raise HandleClosedError(self.agent_id, self.mailbox_id)\n    self._agent_closed = True\n</code></pre>"},{"location":"api/handle/#academy.handle.UnboundRemoteHandle","title":"UnboundRemoteHandle","text":"<pre><code>UnboundRemoteHandle(agent_id: AgentId[BehaviorT])\n</code></pre> <p>               Bases: <code>Generic[BehaviorT]</code></p> <p>Handle to a remote agent that not bound to a mailbox.</p> Warning <p>An unbound handle must be bound before use. Otherwise all methods will raise an <code>HandleNotBoundError</code> when attempting to send a message to the remote agent.</p> <p>Parameters:</p> <ul> <li> <code>agent_id</code>               (<code>AgentId[BehaviorT]</code>)           \u2013            <p>EntityId of the agent.</p> </li> </ul> Source code in <code>academy/handle.py</code> <pre><code>def __init__(self, agent_id: AgentId[BehaviorT]) -&gt; None:\n    self.agent_id = agent_id\n    self.mailbox_id = None\n</code></pre>"},{"location":"api/handle/#academy.handle.UnboundRemoteHandle.__getattr__","title":"__getattr__","text":"<pre><code>__getattr__(name: str) -&gt; Any\n</code></pre> <p>Raises <code>AttributeError</code>.</p> Source code in <code>academy/handle.py</code> <pre><code>def __getattr__(self, name: str) -&gt; Any:\n    \"\"\"Raises `AttributeError`.\"\"\"\n    raise AttributeError(\n        'Actions cannot be invoked via an unbound handle.',\n    )\n</code></pre>"},{"location":"api/handle/#academy.handle.UnboundRemoteHandle.bind_to_exchange","title":"bind_to_exchange","text":"<pre><code>bind_to_exchange(\n    exchange: ExchangeClient,\n) -&gt; BoundRemoteHandle[BehaviorT]\n</code></pre> <p>Bind the handle to an existing mailbox.</p> <p>Parameters:</p> <ul> <li> <code>exchange</code>               (<code>ExchangeClient</code>)           \u2013            <p>Client exchange to associate with handle</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>BoundRemoteHandle[BehaviorT]</code>           \u2013            <p>Remote handle bound to the identifier.</p> </li> </ul> Source code in <code>academy/handle.py</code> <pre><code>def bind_to_exchange(\n    self,\n    exchange: ExchangeClient,\n) -&gt; BoundRemoteHandle[BehaviorT]:\n    \"\"\"Bind the handle to an existing mailbox.\n\n    Args:\n        exchange: Client exchange to associate with handle\n\n    Returns:\n        Remote handle bound to the identifier.\n    \"\"\"\n    return exchange.get_handle(self.agent_id)\n</code></pre>"},{"location":"api/handle/#academy.handle.UnboundRemoteHandle.action","title":"action","text":"<pre><code>action(\n    action: str, /, *args: Any, **kwargs: Any\n) -&gt; Future[R]\n</code></pre> <p>Raises <code>HandleNotBoundError</code>.</p> Source code in <code>academy/handle.py</code> <pre><code>def action(\n    self,\n    action: str,\n    /,\n    *args: Any,\n    **kwargs: Any,\n) -&gt; Future[R]:\n    \"\"\"Raises [`HandleNotBoundError`][academy.exception.HandleNotBoundError].\"\"\"  # noqa: E501\n    raise HandleNotBoundError(self.agent_id)\n</code></pre>"},{"location":"api/handle/#academy.handle.UnboundRemoteHandle.close","title":"close","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Raises <code>HandleNotBoundError</code>.</p> Source code in <code>academy/handle.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Raises [`HandleNotBoundError`][academy.exception.HandleNotBoundError].\"\"\"  # noqa: E501\n    raise HandleNotBoundError(self.agent_id)\n</code></pre>"},{"location":"api/handle/#academy.handle.UnboundRemoteHandle.ping","title":"ping","text":"<pre><code>ping(*, timeout: float | None = None) -&gt; float\n</code></pre> <p>Raises <code>HandleNotBoundError</code>.</p> Source code in <code>academy/handle.py</code> <pre><code>def ping(self, *, timeout: float | None = None) -&gt; float:\n    \"\"\"Raises [`HandleNotBoundError`][academy.exception.HandleNotBoundError].\"\"\"  # noqa: E501\n    raise HandleNotBoundError(self.agent_id)\n</code></pre>"},{"location":"api/handle/#academy.handle.UnboundRemoteHandle.shutdown","title":"shutdown","text":"<pre><code>shutdown() -&gt; None\n</code></pre> <p>Raises <code>HandleNotBoundError</code>.</p> Source code in <code>academy/handle.py</code> <pre><code>def shutdown(self) -&gt; None:\n    \"\"\"Raises [`HandleNotBoundError`][academy.exception.HandleNotBoundError].\"\"\"  # noqa: E501\n    raise HandleNotBoundError(self.agent_id)\n</code></pre>"},{"location":"api/handle/#academy.handle.BoundRemoteHandle","title":"BoundRemoteHandle","text":"<pre><code>BoundRemoteHandle(\n    exchange: ExchangeClient,\n    agent_id: AgentId[BehaviorT],\n    mailbox_id: EntityId | None = None,\n)\n</code></pre> <p>               Bases: <code>Generic[BehaviorT]</code></p> <p>Handle to a remote agent bound to an existing mailbox.</p> <p>Parameters:</p> <ul> <li> <code>exchange</code>               (<code>ExchangeClient</code>)           \u2013            <p>Message exchange used for agent communication.</p> </li> <li> <code>agent_id</code>               (<code>AgentId[BehaviorT]</code>)           \u2013            <p>EntityId of the target agent of this handle.</p> </li> <li> <code>mailbox_id</code>               (<code>EntityId | None</code>, default:                   <code>None</code> )           \u2013            <p>EntityId of the mailbox this handle receives messages to.</p> </li> </ul> Source code in <code>academy/handle.py</code> <pre><code>def __init__(\n    self,\n    exchange: ExchangeClient,\n    agent_id: AgentId[BehaviorT],\n    mailbox_id: EntityId | None = None,\n) -&gt; None:\n    if agent_id == mailbox_id:\n        raise ValueError(\n            f'Cannot create handle to {agent_id} that is bound to itself. '\n            'Check that the values of `agent_id` and `mailbox_id` '\n            'are different.',\n        )\n\n    self.exchange = exchange\n    self.agent_id = agent_id\n    self.mailbox_id = mailbox_id\n    # Unique identifier for each handle object; used to disambiguate\n    # messages when multiple handles are bound to the same mailbox.\n    self.handle_id = uuid.uuid4()\n\n    self._futures: dict[uuid.UUID, Future[Any]] = {}\n    self._closed = False\n</code></pre>"},{"location":"api/handle/#academy.handle.BoundRemoteHandle.clone","title":"clone","text":"<pre><code>clone() -&gt; UnboundRemoteHandle[BehaviorT]\n</code></pre> <p>Create an unbound copy of this handle.</p> Source code in <code>academy/handle.py</code> <pre><code>def clone(self) -&gt; UnboundRemoteHandle[BehaviorT]:\n    \"\"\"Create an unbound copy of this handle.\"\"\"\n    return UnboundRemoteHandle(self.agent_id)\n</code></pre>"},{"location":"api/handle/#academy.handle.BoundRemoteHandle.close","title":"close","text":"<pre><code>close(\n    wait_futures: bool = True,\n    *,\n    timeout: float | None = None\n) -&gt; None\n</code></pre> <p>Close this handle.</p> <p>Parameters:</p> <ul> <li> <code>wait_futures</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Wait to return until all pending futures are done executing. If <code>False</code>, pending futures are cancelled.</p> </li> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional timeout used when <code>wait=True</code>.</p> </li> </ul> Source code in <code>academy/handle.py</code> <pre><code>def close(\n    self,\n    wait_futures: bool = True,\n    *,\n    timeout: float | None = None,\n) -&gt; None:\n    \"\"\"Close this handle.\n\n    Args:\n        wait_futures: Wait to return until all pending futures are done\n            executing. If `False`, pending futures are cancelled.\n        timeout: Optional timeout used when `wait=True`.\n    \"\"\"\n    self._closed = True\n\n    if len(self._futures) == 0:\n        return\n    if wait_futures:\n        logger.debug('Waiting on pending futures for %s', self)\n        wait(list(self._futures.values()), timeout=timeout)\n    else:\n        logger.debug('Cancelling pending futures for %s', self)\n        for future in self._futures:\n            self._futures[future].cancel()\n</code></pre>"},{"location":"api/handle/#academy.handle.BoundRemoteHandle.action","title":"action","text":"<pre><code>action(\n    action: str, /, *args: Any, **kwargs: Any\n) -&gt; Future[R]\n</code></pre> <p>Invoke an action on the agent.</p> <p>Parameters:</p> <ul> <li> <code>action</code>               (<code>str</code>)           \u2013            <p>Action to invoke.</p> </li> <li> <code>args</code>               (<code>Any</code>, default:                   <code>()</code> )           \u2013            <p>Positional arguments for the action.</p> </li> <li> <code>kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Keywords arguments for the action.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Future[R]</code>           \u2013            <p>Future to the result of the action.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>HandleClosedError</code>             \u2013            <p>If the handle was closed.</p> </li> <li> <code>MailboxClosedError</code>             \u2013            <p>If the agent's mailbox was closed. This typically indicates the agent shutdown for another reason (it self terminated or via another handle).</p> </li> </ul> Source code in <code>academy/handle.py</code> <pre><code>def action(\n    self,\n    action: str,\n    /,\n    *args: Any,\n    **kwargs: Any,\n) -&gt; Future[R]:\n    \"\"\"Invoke an action on the agent.\n\n    Args:\n        action: Action to invoke.\n        args: Positional arguments for the action.\n        kwargs: Keywords arguments for the action.\n\n    Returns:\n        Future to the result of the action.\n\n    Raises:\n        HandleClosedError: If the handle was closed.\n        MailboxClosedError: If the agent's mailbox was closed. This\n            typically indicates the agent shutdown for another reason\n            (it self terminated or via another handle).\n    \"\"\"\n    if self.mailbox_id is None:\n        # UnboundRemoteHandle overrides these methods and is the only\n        # handle state variant where hid is None.\n        raise AssertionError(\n            'Method should not be reachable in unbound state.',\n        )\n    if self._closed:\n        raise HandleClosedError(self.agent_id, self.mailbox_id)\n\n    request = ActionRequest(\n        src=self.mailbox_id,\n        dest=self.agent_id,\n        label=self.handle_id,\n        action=action,\n        pargs=args,\n        kargs=kwargs,\n    )\n    future: Future[R] = Future()\n    self._futures[request.tag] = future\n    self._send_request(request)\n    logger.debug(\n        'Sent action request from %s to %s (action=%r)',\n        self.mailbox_id,\n        self.agent_id,\n        action,\n    )\n    return future\n</code></pre>"},{"location":"api/handle/#academy.handle.BoundRemoteHandle.ping","title":"ping","text":"<pre><code>ping(*, timeout: float | None = None) -&gt; float\n</code></pre> <p>Ping the agent.</p> <p>Ping the agent and wait to get a response. Agents process messages in order so the round-trip time will include processing time of earlier messages in the queue.</p> <p>Parameters:</p> <ul> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional timeout in seconds to wait for the response.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>Round-trip time in seconds.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>HandleClosedError</code>             \u2013            <p>If the handle was closed.</p> </li> <li> <code>MailboxClosedError</code>             \u2013            <p>If the agent's mailbox was closed. This typically indicates the agent shutdown for another reason (it self terminated or via another handle).</p> </li> <li> <code>TimeoutError</code>             \u2013            <p>If the timeout is exceeded.</p> </li> </ul> Source code in <code>academy/handle.py</code> <pre><code>def ping(self, *, timeout: float | None = None) -&gt; float:\n    \"\"\"Ping the agent.\n\n    Ping the agent and wait to get a response. Agents process messages\n    in order so the round-trip time will include processing time of\n    earlier messages in the queue.\n\n    Args:\n        timeout: Optional timeout in seconds to wait for the response.\n\n    Returns:\n        Round-trip time in seconds.\n\n    Raises:\n        HandleClosedError: If the handle was closed.\n        MailboxClosedError: If the agent's mailbox was closed. This\n            typically indicates the agent shutdown for another reason\n            (it self terminated or via another handle).\n        TimeoutError: If the timeout is exceeded.\n    \"\"\"\n    if self.mailbox_id is None:\n        # UnboundRemoteHandle overrides these methods and is the only\n        # handle state variant where hid is None.\n        raise AssertionError(\n            'Method should not be reachable in unbound state.',\n        )\n    if self._closed:\n        raise HandleClosedError(self.agent_id, self.mailbox_id)\n\n    start = time.perf_counter()\n    request = PingRequest(\n        src=self.mailbox_id,\n        dest=self.agent_id,\n        label=self.handle_id,\n    )\n    future: Future[None] = Future()\n    self._futures[request.tag] = future\n    self._send_request(request)\n    logger.debug('Sent ping from %s to %s', self.mailbox_id, self.agent_id)\n    future.result(timeout=timeout)\n    elapsed = time.perf_counter() - start\n    logger.debug(\n        'Received ping from %s to %s in %.1f ms',\n        self.mailbox_id,\n        self.agent_id,\n        elapsed * 1000,\n    )\n    return elapsed\n</code></pre>"},{"location":"api/handle/#academy.handle.BoundRemoteHandle.shutdown","title":"shutdown","text":"<pre><code>shutdown() -&gt; None\n</code></pre> <p>Instruct the agent to shutdown.</p> <p>This is non-blocking and will only send the message.</p> <p>Raises:</p> <ul> <li> <code>HandleClosedError</code>             \u2013            <p>If the handle was closed.</p> </li> <li> <code>MailboxClosedError</code>             \u2013            <p>If the agent's mailbox was closed. This typically indicates the agent shutdown for another reason (it self terminated or via another handle).</p> </li> </ul> Source code in <code>academy/handle.py</code> <pre><code>def shutdown(self) -&gt; None:\n    \"\"\"Instruct the agent to shutdown.\n\n    This is non-blocking and will only send the message.\n\n    Raises:\n        HandleClosedError: If the handle was closed.\n        MailboxClosedError: If the agent's mailbox was closed. This\n            typically indicates the agent shutdown for another reason\n            (it self terminated or via another handle).\n    \"\"\"\n    if self.mailbox_id is None:\n        # UnboundRemoteHandle overrides these methods and is the only\n        # handle state variant where hid is None.\n        raise AssertionError(\n            'Method should not be reachable in unbound state.',\n        )\n    if self._closed:\n        raise HandleClosedError(self.agent_id, self.mailbox_id)\n\n    request = ShutdownRequest(\n        src=self.mailbox_id,\n        dest=self.agent_id,\n        label=self.handle_id,\n    )\n    self._send_request(request)\n    logger.debug(\n        'Sent shutdown request from %s to %s',\n        self.mailbox_id,\n        self.agent_id,\n    )\n</code></pre>"},{"location":"api/handle/#academy.handle.BoundRemoteHandle.bind_to_exchange","title":"bind_to_exchange","text":"<pre><code>bind_to_exchange(\n    exchange: ExchangeClient,\n) -&gt; BoundRemoteHandle[BehaviorT]\n</code></pre> <p>Bind the handle to an existing mailbox.</p> <p>Parameters:</p> <ul> <li> <code>exchange</code>               (<code>ExchangeClient</code>)           \u2013            <p>Client exchange to associate with handle</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>BoundRemoteHandle[BehaviorT]</code>           \u2013            <p>Remote handle bound to the identifier.</p> </li> </ul> Source code in <code>academy/handle.py</code> <pre><code>def bind_to_exchange(\n    self,\n    exchange: ExchangeClient,\n) -&gt; BoundRemoteHandle[BehaviorT]:\n    \"\"\"Bind the handle to an existing mailbox.\n\n    Args:\n        exchange: Client exchange to associate with handle\n\n    Returns:\n        Remote handle bound to the identifier.\n    \"\"\"\n    return self.clone().bind_to_exchange(exchange)\n</code></pre>"},{"location":"api/identifier/","title":"academy.identifier","text":"<code>academy/identifier.py</code>"},{"location":"api/identifier/#academy.identifier.EntityId","title":"EntityId  <code>module-attribute</code>","text":"<pre><code>EntityId = Union[AgentId[Any], ClientId]\n</code></pre> <p>EntityId union type for type annotations.</p>"},{"location":"api/identifier/#academy.identifier.AgentId","title":"AgentId  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code>, <code>Generic[BehaviorT]</code></p> <p>Unique identifier of an agent in a multi-agent system.</p> <p>Config:</p> <ul> <li><code>extra</code>: <code>forbid</code></li> <li><code>frozen</code>: <code>True</code></li> <li><code>validate_default</code>: <code>True</code></li> </ul> <p>Fields:</p> <ul> <li> <code>uid</code>                 (<code>UUID</code>)             </li> <li> <code>name</code>                 (<code>Optional[str]</code>)             </li> <li> <code>role</code>                 (<code>Literal['agent']</code>)             </li> </ul>"},{"location":"api/identifier/#academy.identifier.AgentId.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(name: str | None = None) -&gt; Self\n</code></pre> <p>Create a new identifier.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional human-readable name for the entity.</p> </li> </ul> Source code in <code>academy/identifier.py</code> <pre><code>@classmethod\ndef new(cls, name: str | None = None) -&gt; Self:\n    \"\"\"Create a new identifier.\n\n    Args:\n        name: Optional human-readable name for the entity.\n    \"\"\"\n    return cls(uid=uuid.uuid4(), name=name)\n</code></pre>"},{"location":"api/identifier/#academy.identifier.ClientId","title":"ClientId  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Unique identifier of a client in a multi-agent system.</p> <p>Config:</p> <ul> <li><code>extra</code>: <code>forbid</code></li> <li><code>frozen</code>: <code>True</code></li> <li><code>validate_default</code>: <code>True</code></li> </ul> <p>Fields:</p> <ul> <li> <code>uid</code>                 (<code>UUID</code>)             </li> <li> <code>name</code>                 (<code>Optional[str]</code>)             </li> <li> <code>role</code>                 (<code>Literal['client']</code>)             </li> </ul>"},{"location":"api/identifier/#academy.identifier.ClientId.new","title":"new  <code>classmethod</code>","text":"<pre><code>new(name: str | None = None) -&gt; Self\n</code></pre> <p>Create a new identifier.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional human-readable name for the entity.</p> </li> </ul> Source code in <code>academy/identifier.py</code> <pre><code>@classmethod\ndef new(cls, name: str | None = None) -&gt; Self:\n    \"\"\"Create a new identifier.\n\n    Args:\n        name: Optional human-readable name for the entity.\n    \"\"\"\n    return cls(uid=uuid.uuid4(), name=name)\n</code></pre>"},{"location":"api/launcher/","title":"academy.launcher","text":"<code>academy/launcher.py</code>"},{"location":"api/launcher/#academy.launcher.Launcher","title":"Launcher","text":"<pre><code>Launcher(\n    executor: Executor,\n    *,\n    close_exchange: bool = True,\n    max_restarts: int = 0\n)\n</code></pre> <p>Launcher that wraps a <code>concurrent.futures.Executor</code>.</p> <p>Parameters:</p> <ul> <li> <code>executor</code>               (<code>Executor</code>)           \u2013            <p>Executor used for launching agents. Note that this class takes ownership of the <code>executor</code>.</p> </li> <li> <code>close_exchange</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Passed along to the <code>Agent</code> constructor. This should typically be <code>True</code>, the default, when the executor runs agents in separate processes, but should be <code>False</code> for the <code>ThreadPoolExecutor</code> to avoid closing shared exchange objects.</p> </li> <li> <code>max_restarts</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Maximum times to restart an agent if it exits with an error.</p> </li> </ul> Source code in <code>academy/launcher.py</code> <pre><code>def __init__(\n    self,\n    executor: Executor,\n    *,\n    close_exchange: bool = True,\n    max_restarts: int = 0,\n) -&gt; None:\n    self._executor = executor\n    self._close_exchange = close_exchange\n    self._max_restarts = max_restarts\n    self._acbs: dict[AgentId[Any], _ACB[Any]] = {}\n    self._future_to_acb: dict[Future[None], _ACB[Any]] = {}\n</code></pre>"},{"location":"api/launcher/#academy.launcher.Launcher.close","title":"close","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the launcher.</p> Warning <p>This will not return until all agents have exited. It is the caller's responsibility to shutdown agents prior to closing the launcher.</p> Source code in <code>academy/launcher.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Close the launcher.\n\n    Warning:\n        This will not return until all agents have exited. It is the\n        caller's responsibility to shutdown agents prior to closing\n        the launcher.\n    \"\"\"\n    logger.debug('Waiting for agents to shutdown...')\n    for acb in self._acbs.values():\n        if acb.done.is_set() and acb.future is not None:\n            # Raise possible errors from agents so user is sure\n            # to see them.\n            acb.future.result()\n    self._executor.shutdown(wait=True, cancel_futures=True)\n    logger.debug('Closed launcher (%s)', self)\n</code></pre>"},{"location":"api/launcher/#academy.launcher.Launcher.launch","title":"launch","text":"<pre><code>launch(\n    behavior: BehaviorT,\n    exchange: ExchangeClient,\n    *,\n    agent_id: AgentId[BehaviorT] | None = None,\n    name: str | None = None\n) -&gt; BoundRemoteHandle[BehaviorT]\n</code></pre> <p>Launch a new agent with a specified behavior.</p> <p>Parameters:</p> <ul> <li> <code>behavior</code>               (<code>BehaviorT</code>)           \u2013            <p>Behavior the agent should implement.</p> </li> <li> <code>exchange</code>               (<code>ExchangeClient</code>)           \u2013            <p>Exchange the agent will use for messaging.</p> </li> <li> <code>agent_id</code>               (<code>AgentId[BehaviorT] | None</code>, default:                   <code>None</code> )           \u2013            <p>Specify ID of the launched agent. If <code>None</code>, a new agent ID will be created within the exchange.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Readable name of the agent. Ignored if <code>agent_id</code> is provided.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>BoundRemoteHandle[BehaviorT]</code>           \u2013            <p>Handle (unbound) used to interact with the agent.</p> </li> </ul> Source code in <code>academy/launcher.py</code> <pre><code>def launch(\n    self,\n    behavior: BehaviorT,\n    exchange: ExchangeClient,\n    *,\n    agent_id: AgentId[BehaviorT] | None = None,\n    name: str | None = None,\n) -&gt; BoundRemoteHandle[BehaviorT]:\n    \"\"\"Launch a new agent with a specified behavior.\n\n    Args:\n        behavior: Behavior the agent should implement.\n        exchange: Exchange the agent will use for messaging.\n        agent_id: Specify ID of the launched agent. If `None`, a new\n            agent ID will be created within the exchange.\n        name: Readable name of the agent. Ignored if `agent_id` is\n            provided.\n\n    Returns:\n        Handle (unbound) used to interact with the agent.\n    \"\"\"\n    agent_id = (\n        exchange.register_agent(type(behavior), name=name)\n        if agent_id is None\n        else agent_id\n    )\n\n    acb = _ACB(\n        agent_id,\n        behavior,\n        exchange.clone(),\n        done=threading.Event(),\n    )\n    self._acbs[agent_id] = acb\n    self._launch(agent_id)\n\n    return exchange.get_handle(agent_id)\n</code></pre>"},{"location":"api/launcher/#academy.launcher.Launcher.running","title":"running","text":"<pre><code>running() -&gt; set[AgentId[Any]]\n</code></pre> <p>Get a set of IDs for all running agents.</p> <p>Returns:</p> <ul> <li> <code>set[AgentId[Any]]</code>           \u2013            <p>Set of agent IDs corresponding to all agents launched by this             launcher that have not completed yet.</p> </li> </ul> Source code in <code>academy/launcher.py</code> <pre><code>def running(self) -&gt; set[AgentId[Any]]:\n    \"\"\"Get a set of IDs for all running agents.\n\n    Returns:\n        Set of agent IDs corresponding to all agents launched by this \\\n        launcher that have not completed yet.\n    \"\"\"\n    running: set[AgentId[Any]] = set()\n    for acb in self._acbs.values():\n        if not acb.done.is_set():\n            running.add(acb.agent_id)\n    return running\n</code></pre>"},{"location":"api/launcher/#academy.launcher.Launcher.wait","title":"wait","text":"<pre><code>wait(\n    agent_id: AgentId[Any],\n    *,\n    ignore_error: bool = False,\n    timeout: float | None = None\n) -&gt; None\n</code></pre> <p>Wait for a launched agent to exit.</p> Note <p>Calling <code>wait()</code> is only valid after <code>launch()</code> has succeeded.</p> <p>Parameters:</p> <ul> <li> <code>agent_id</code>               (<code>AgentId[Any]</code>)           \u2013            <p>ID of launched agent.</p> </li> <li> <code>ignore_error</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Ignore any errors raised by the agent.</p> </li> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional timeout in seconds to wait for agent.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BadEntityIdError</code>             \u2013            <p>If an agent with <code>agent_id</code> was not launched by this launcher.</p> </li> <li> <code>TimeoutError</code>             \u2013            <p>If <code>timeout</code> was exceeded while waiting for agent.</p> </li> <li> <code>Exception</code>             \u2013            <p>Any exception raised by the agent if <code>ignore_error=False</code>.</p> </li> </ul> Source code in <code>academy/launcher.py</code> <pre><code>def wait(\n    self,\n    agent_id: AgentId[Any],\n    *,\n    ignore_error: bool = False,\n    timeout: float | None = None,\n) -&gt; None:\n    \"\"\"Wait for a launched agent to exit.\n\n    Note:\n        Calling `wait()` is only valid after `launch()` has succeeded.\n\n    Args:\n        agent_id: ID of launched agent.\n        ignore_error: Ignore any errors raised by the agent.\n        timeout: Optional timeout in seconds to wait for agent.\n\n    Raises:\n        BadEntityIdError: If an agent with `agent_id` was not\n            launched by this launcher.\n        TimeoutError: If `timeout` was exceeded while waiting for agent.\n        Exception: Any exception raised by the agent if\n            `ignore_error=False`.\n    \"\"\"\n    try:\n        acb = self._acbs[agent_id]\n    except KeyError:\n        raise BadEntityIdError(agent_id) from None\n\n    if not acb.done.wait(timeout):\n        raise TimeoutError(\n            f'Agent did not complete within {timeout}s timeout '\n            f'({acb.agent_id})',\n        )\n\n    # The only time _ACB.future is None is between constructing the _ACB\n    # in launch() and creating the future in _launch().\n    assert acb.future is not None\n    # _ACB.done event should only be set in callback of future so\n    # the future must be done.\n    assert acb.future.done()\n\n    if not ignore_error:\n        exc = acb.future.exception()\n        if exc is not None:\n            raise exc\n</code></pre>"},{"location":"api/launcher/#academy.launcher.ThreadLauncher","title":"ThreadLauncher","text":"<pre><code>ThreadLauncher(\n    max_workers: int | None = None, *, max_restarts: int = 0\n)\n</code></pre> <p>               Bases: <code>Launcher</code></p> <p>Launcher that wraps a default <code>concurrent.futures.ThreadPoolExecutor</code>.</p> <p>Parameters:</p> <ul> <li> <code>max_workers</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The maximum number of threads (i.e., agents) in the pool.</p> </li> <li> <code>max_restarts</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Maximum times to restart an agent if it exits with an error.</p> </li> </ul> Source code in <code>academy/launcher.py</code> <pre><code>def __init__(\n    self,\n    max_workers: int | None = None,\n    *,\n    max_restarts: int = 0,\n) -&gt; None:\n    executor = ThreadPoolExecutor(\n        max_workers=max_workers,\n        thread_name_prefix='launcher',\n    )\n    super().__init__(\n        executor,\n        close_exchange=False,\n        max_restarts=max_restarts,\n    )\n</code></pre>"},{"location":"api/launcher/#academy.launcher.ThreadLauncher.close","title":"close","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the launcher.</p> Warning <p>This will not return until all agents have exited. It is the caller's responsibility to shutdown agents prior to closing the launcher.</p> Source code in <code>academy/launcher.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Close the launcher.\n\n    Warning:\n        This will not return until all agents have exited. It is the\n        caller's responsibility to shutdown agents prior to closing\n        the launcher.\n    \"\"\"\n    logger.debug('Waiting for agents to shutdown...')\n    for acb in self._acbs.values():\n        if acb.done.is_set() and acb.future is not None:\n            # Raise possible errors from agents so user is sure\n            # to see them.\n            acb.future.result()\n    self._executor.shutdown(wait=True, cancel_futures=True)\n    logger.debug('Closed launcher (%s)', self)\n</code></pre>"},{"location":"api/launcher/#academy.launcher.ThreadLauncher.launch","title":"launch","text":"<pre><code>launch(\n    behavior: BehaviorT,\n    exchange: ExchangeClient,\n    *,\n    agent_id: AgentId[BehaviorT] | None = None,\n    name: str | None = None\n) -&gt; BoundRemoteHandle[BehaviorT]\n</code></pre> <p>Launch a new agent with a specified behavior.</p> <p>Parameters:</p> <ul> <li> <code>behavior</code>               (<code>BehaviorT</code>)           \u2013            <p>Behavior the agent should implement.</p> </li> <li> <code>exchange</code>               (<code>ExchangeClient</code>)           \u2013            <p>Exchange the agent will use for messaging.</p> </li> <li> <code>agent_id</code>               (<code>AgentId[BehaviorT] | None</code>, default:                   <code>None</code> )           \u2013            <p>Specify ID of the launched agent. If <code>None</code>, a new agent ID will be created within the exchange.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Readable name of the agent. Ignored if <code>agent_id</code> is provided.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>BoundRemoteHandle[BehaviorT]</code>           \u2013            <p>Handle (unbound) used to interact with the agent.</p> </li> </ul> Source code in <code>academy/launcher.py</code> <pre><code>def launch(\n    self,\n    behavior: BehaviorT,\n    exchange: ExchangeClient,\n    *,\n    agent_id: AgentId[BehaviorT] | None = None,\n    name: str | None = None,\n) -&gt; BoundRemoteHandle[BehaviorT]:\n    \"\"\"Launch a new agent with a specified behavior.\n\n    Args:\n        behavior: Behavior the agent should implement.\n        exchange: Exchange the agent will use for messaging.\n        agent_id: Specify ID of the launched agent. If `None`, a new\n            agent ID will be created within the exchange.\n        name: Readable name of the agent. Ignored if `agent_id` is\n            provided.\n\n    Returns:\n        Handle (unbound) used to interact with the agent.\n    \"\"\"\n    agent_id = (\n        exchange.register_agent(type(behavior), name=name)\n        if agent_id is None\n        else agent_id\n    )\n\n    acb = _ACB(\n        agent_id,\n        behavior,\n        exchange.clone(),\n        done=threading.Event(),\n    )\n    self._acbs[agent_id] = acb\n    self._launch(agent_id)\n\n    return exchange.get_handle(agent_id)\n</code></pre>"},{"location":"api/launcher/#academy.launcher.ThreadLauncher.running","title":"running","text":"<pre><code>running() -&gt; set[AgentId[Any]]\n</code></pre> <p>Get a set of IDs for all running agents.</p> <p>Returns:</p> <ul> <li> <code>set[AgentId[Any]]</code>           \u2013            <p>Set of agent IDs corresponding to all agents launched by this             launcher that have not completed yet.</p> </li> </ul> Source code in <code>academy/launcher.py</code> <pre><code>def running(self) -&gt; set[AgentId[Any]]:\n    \"\"\"Get a set of IDs for all running agents.\n\n    Returns:\n        Set of agent IDs corresponding to all agents launched by this \\\n        launcher that have not completed yet.\n    \"\"\"\n    running: set[AgentId[Any]] = set()\n    for acb in self._acbs.values():\n        if not acb.done.is_set():\n            running.add(acb.agent_id)\n    return running\n</code></pre>"},{"location":"api/launcher/#academy.launcher.ThreadLauncher.wait","title":"wait","text":"<pre><code>wait(\n    agent_id: AgentId[Any],\n    *,\n    ignore_error: bool = False,\n    timeout: float | None = None\n) -&gt; None\n</code></pre> <p>Wait for a launched agent to exit.</p> Note <p>Calling <code>wait()</code> is only valid after <code>launch()</code> has succeeded.</p> <p>Parameters:</p> <ul> <li> <code>agent_id</code>               (<code>AgentId[Any]</code>)           \u2013            <p>ID of launched agent.</p> </li> <li> <code>ignore_error</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Ignore any errors raised by the agent.</p> </li> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional timeout in seconds to wait for agent.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BadEntityIdError</code>             \u2013            <p>If an agent with <code>agent_id</code> was not launched by this launcher.</p> </li> <li> <code>TimeoutError</code>             \u2013            <p>If <code>timeout</code> was exceeded while waiting for agent.</p> </li> <li> <code>Exception</code>             \u2013            <p>Any exception raised by the agent if <code>ignore_error=False</code>.</p> </li> </ul> Source code in <code>academy/launcher.py</code> <pre><code>def wait(\n    self,\n    agent_id: AgentId[Any],\n    *,\n    ignore_error: bool = False,\n    timeout: float | None = None,\n) -&gt; None:\n    \"\"\"Wait for a launched agent to exit.\n\n    Note:\n        Calling `wait()` is only valid after `launch()` has succeeded.\n\n    Args:\n        agent_id: ID of launched agent.\n        ignore_error: Ignore any errors raised by the agent.\n        timeout: Optional timeout in seconds to wait for agent.\n\n    Raises:\n        BadEntityIdError: If an agent with `agent_id` was not\n            launched by this launcher.\n        TimeoutError: If `timeout` was exceeded while waiting for agent.\n        Exception: Any exception raised by the agent if\n            `ignore_error=False`.\n    \"\"\"\n    try:\n        acb = self._acbs[agent_id]\n    except KeyError:\n        raise BadEntityIdError(agent_id) from None\n\n    if not acb.done.wait(timeout):\n        raise TimeoutError(\n            f'Agent did not complete within {timeout}s timeout '\n            f'({acb.agent_id})',\n        )\n\n    # The only time _ACB.future is None is between constructing the _ACB\n    # in launch() and creating the future in _launch().\n    assert acb.future is not None\n    # _ACB.done event should only be set in callback of future so\n    # the future must be done.\n    assert acb.future.done()\n\n    if not ignore_error:\n        exc = acb.future.exception()\n        if exc is not None:\n            raise exc\n</code></pre>"},{"location":"api/logging/","title":"academy.logging","text":"<code>academy/logging.py</code>"},{"location":"api/logging/#academy.logging.init_logging","title":"init_logging","text":"<pre><code>init_logging(\n    level: int | str = INFO,\n    *,\n    logfile: str | Path | None = None,\n    logfile_level: int | str | None = None,\n    color: bool = True,\n    extra: bool = False,\n    force: bool = False\n) -&gt; Logger\n</code></pre> <p>Initialize global logger.</p> <p>Parameters:</p> <ul> <li> <code>level</code>               (<code>int | str</code>, default:                   <code>INFO</code> )           \u2013            <p>Minimum logging level.</p> </li> <li> <code>logfile</code>               (<code>str | Path | None</code>, default:                   <code>None</code> )           \u2013            <p>Configure a file handler for this path.</p> </li> <li> <code>logfile_level</code>               (<code>int | str | None</code>, default:                   <code>None</code> )           \u2013            <p>Minimum logging level for the file handler. Defaults to that of <code>level</code>.</p> </li> <li> <code>color</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Use colorful logging for stdout.</p> </li> <li> <code>extra</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Include extra info in log messages, such as thread ID and process ID. This is helpful for debugging.</p> </li> <li> <code>force</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Remove any existing handlers attached to the root handler. This option is useful to silencing the third-party package logging. Note: should not be set when running inside pytest.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Logger</code>           \u2013            <p>The root logger.</p> </li> </ul> Source code in <code>academy/logging.py</code> <pre><code>def init_logging(  # noqa: PLR0913\n    level: int | str = logging.INFO,\n    *,\n    logfile: str | pathlib.Path | None = None,\n    logfile_level: int | str | None = None,\n    color: bool = True,\n    extra: bool = False,\n    force: bool = False,\n) -&gt; logging.Logger:\n    \"\"\"Initialize global logger.\n\n    Args:\n        level: Minimum logging level.\n        logfile: Configure a file handler for this path.\n        logfile_level: Minimum logging level for the file handler. Defaults\n            to that of `level`.\n        color: Use colorful logging for stdout.\n        extra: Include extra info in log messages, such as thread ID and\n            process ID. This is helpful for debugging.\n        force: Remove any existing handlers attached to the root\n            handler. This option is useful to silencing the third-party\n            package logging. Note: should not be set when running inside\n            pytest.\n\n    Returns:\n        The root logger.\n    \"\"\"\n    stdout_handler = logging.StreamHandler(sys.stdout)\n    stdout_handler.setFormatter(_Formatter(color=color, extra=extra))\n    stdout_handler.setLevel(level)\n    if extra:\n        stdout_handler.addFilter(_os_thread_filter)\n    handlers: list[logging.Handler] = [stdout_handler]\n\n    if logfile is not None:\n        logfile_level = level if logfile_level is None else logfile_level\n        path = pathlib.Path(logfile)\n        path.parent.mkdir(parents=True, exist_ok=True)\n        handler = logging.FileHandler(path)\n        handler.setFormatter(_Formatter(color=False, extra=extra))\n        handler.setLevel(logfile_level)\n        handlers.append(handler)\n\n    logging.basicConfig(\n        datefmt='%Y-%m-%d %H:%M:%S',\n        level=logging.NOTSET,\n        handlers=handlers,\n        force=force,\n    )\n\n    # This needs to be after the configuration of the root logger because\n    # warnings get logged to a 'py.warnings' logger.\n    logging.captureWarnings(True)\n\n    logger = logging.getLogger()\n    logger.info(\n        'Configured logger (stdout-level=%s, logfile=%s, logfile-level=%s)',\n        logging.getLevelName(level) if isinstance(level, int) else level,\n        logfile,\n        logging.getLevelName(logfile_level)\n        if isinstance(logfile_level, int)\n        else logfile_level,\n    )\n\n    return logger\n</code></pre>"},{"location":"api/manager/","title":"academy.manager","text":"<code>academy/manager.py</code>"},{"location":"api/manager/#academy.manager.Manager","title":"Manager","text":"<pre><code>Manager(\n    exchange: ExchangeFactory,\n    launcher: Launcher | MutableMapping[str, Launcher],\n    *,\n    default_launcher: str | None = None\n)\n</code></pre> <p>               Bases: <code>NoPickleMixin</code></p> <p>Launch and manage running agents.</p> <p>The manager is provided as convenience to reduce common boilerplate code for spawning agents and managing handles. Each manager registers itself as a client in the exchange (i.e., each manager has its own mailbox). Handles created by the manager are bound to this mailbox.</p> Tip <p>This class can be used as a context manager. Upon exiting the context, running agents will be shutdown, any agent handles created by the manager will be closed, and the exchange and launcher will be closed.</p> Note <p>The manager takes ownership of the exchange and launcher interfaces. This means the manager will be responsible for closing them once the manager is closed.</p> <p>Parameters:</p> <ul> <li> <code>exchange</code>               (<code>ExchangeFactory</code>)           \u2013            <p>Exchange that agents and clients will use for communication.</p> </li> <li> <code>launcher</code>               (<code>Launcher | MutableMapping[str, Launcher]</code>)           \u2013            <p>A mapping of names to launchers used to execute agents remotely. If a single launcher is provided directly, it is set as the default with name <code>'default'</code>, overriding any value of <code>default_launcher</code>.</p> </li> <li> <code>default_launcher</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Specify the name of the default launcher to use when not specified in <code>launch()</code>.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If <code>default_launcher</code> is specified but does not exist in <code>launchers</code>.</p> </li> </ul> Source code in <code>academy/manager.py</code> <pre><code>def __init__(\n    self,\n    exchange: ExchangeFactory,\n    launcher: Launcher | MutableMapping[str, Launcher],\n    *,\n    default_launcher: str | None = None,\n) -&gt; None:\n    if isinstance(launcher, Launcher):\n        launcher = {'default': launcher}\n        default_launcher = 'default'\n\n    if default_launcher is not None and default_launcher not in launcher:\n        raise ValueError(\n            f'No launcher named \"{default_launcher}\" was provided to '\n            'use as the default.',\n        )\n\n    self._exchange = exchange.bind_as_client()\n    assert isinstance(self._exchange.mailbox_id, ClientId)\n    self._mailbox_id: ClientId = self._exchange.mailbox_id\n    self._launchers = launcher\n    self._default_launcher = default_launcher\n\n    self._handles: dict[AgentId[Any], BoundRemoteHandle[Any]] = {}\n    self._aid_to_launcher: dict[AgentId[Any], str] = {}\n\n    logger.info(\n        'Initialized manager (%s; %s)',\n        self._mailbox_id,\n        self._exchange,\n    )\n</code></pre>"},{"location":"api/manager/#academy.manager.Manager.exchange","title":"exchange  <code>property</code>","text":"<pre><code>exchange: ExchangeClient\n</code></pre> <p>Exchange interface.</p>"},{"location":"api/manager/#academy.manager.Manager.mailbox_id","title":"mailbox_id  <code>property</code>","text":"<pre><code>mailbox_id: ClientId\n</code></pre> <p>EntityId of the mailbox used by this manager.</p>"},{"location":"api/manager/#academy.manager.Manager.close","title":"close","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the manager and cleanup resources.</p> <ol> <li>Call shutdown on all running agents.</li> <li>Close all handles created by the manager.</li> <li>Close the mailbox associated with the manager.</li> <li>Close the exchange.</li> <li>Close all launchers.</li> </ol> Source code in <code>academy/manager.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Close the manager and cleanup resources.\n\n    1. Call shutdown on all running agents.\n    1. Close all handles created by the manager.\n    1. Close the mailbox associated with the manager.\n    1. Close the exchange.\n    1. Close all launchers.\n    \"\"\"\n    for launcher in self._launchers.values():\n        for agent_id in launcher.running():\n            handle = self._handles[agent_id]\n            with contextlib.suppress(MailboxClosedError):\n                handle.shutdown()\n    logger.debug('Instructed managed agents to shutdown')\n    self.exchange.close_bound_handles()\n    self.exchange.terminate(self.mailbox_id)\n    self.exchange.close()\n    for launcher in self._launchers.values():\n        launcher.close()\n    logger.info('Closed manager (%s)', self.mailbox_id)\n</code></pre>"},{"location":"api/manager/#academy.manager.Manager.add_launcher","title":"add_launcher","text":"<pre><code>add_launcher(name: str, launcher: Launcher) -&gt; Self\n</code></pre> <p>Add a launcher to the manager.</p> Note <p>It is not possible to remove a launcher as this could create complications if an agent was already launched using a given launcher.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Name of the launcher.</p> </li> <li> <code>launcher</code>               (<code>Launcher</code>)           \u2013            <p>Launcher instance.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>Self for chaining.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If a launcher with <code>name</code> already exists.</p> </li> </ul> Source code in <code>academy/manager.py</code> <pre><code>def add_launcher(self, name: str, launcher: Launcher) -&gt; Self:\n    \"\"\"Add a launcher to the manager.\n\n    Note:\n        It is not possible to remove a launcher as this could create\n        complications if an agent was already launched using a given\n        launcher.\n\n    Args:\n        name: Name of the launcher.\n        launcher: Launcher instance.\n\n    Returns:\n        Self for chaining.\n\n    Raises:\n        ValueError: If a launcher with `name` already exists.\n    \"\"\"\n    if name in self._launchers:\n        raise ValueError(f'Launcher named \"{name}\" already exists.')\n    self._launchers[name] = launcher\n    return self\n</code></pre>"},{"location":"api/manager/#academy.manager.Manager.set_default_launcher","title":"set_default_launcher","text":"<pre><code>set_default_launcher(name: str | None) -&gt; Self\n</code></pre> <p>Set the name of the default launcher.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str | None</code>)           \u2013            <p>Name of the launcher to default to. If <code>None</code>, no default launcher is set and all calls to <code>launch()</code> must specify the launcher.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>Self for chaining.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If no launcher with <code>name</code> exists.</p> </li> </ul> Source code in <code>academy/manager.py</code> <pre><code>def set_default_launcher(self, name: str | None) -&gt; Self:\n    \"\"\"Set the name of the default launcher.\n\n    Args:\n        name: Name of the launcher to default to. If `None`, no default\n            launcher is set and all calls to `launch()` must specify\n            the launcher.\n\n    Returns:\n        Self for chaining.\n\n    Raises:\n        ValueError: If no launcher with `name` exists.\n    \"\"\"\n    if name not in self._launchers:\n        raise ValueError(f'A launcher name \"{name}\" does not exist.')\n    self._default_launcher = name\n    return self\n</code></pre>"},{"location":"api/manager/#academy.manager.Manager.launch","title":"launch","text":"<pre><code>launch(\n    behavior: BehaviorT,\n    *,\n    agent_id: AgentId[BehaviorT] | None = None,\n    launcher: str | None = None,\n    name: str | None = None\n) -&gt; BoundRemoteHandle[BehaviorT]\n</code></pre> <p>Launch a new agent with a specified behavior.</p> Note <p>Compared to <code>Launcher.launch()</code>, this method will inject the exchange and return a client-bound handle.</p> <p>Parameters:</p> <ul> <li> <code>behavior</code>               (<code>BehaviorT</code>)           \u2013            <p>Behavior the agent should implement.</p> </li> <li> <code>agent_id</code>               (<code>AgentId[BehaviorT] | None</code>, default:                   <code>None</code> )           \u2013            <p>Specify ID of the launched agent. If <code>None</code>, a new agent ID will be created within the exchange.</p> </li> <li> <code>launcher</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Name of the launcher instance to use. In <code>None</code>, uses the default launcher if specified, otherwise raises an error.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Readable name of the agent. Ignored if <code>agent_id</code> is provided.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>BoundRemoteHandle[BehaviorT]</code>           \u2013            <p>Handle (client bound) used to interact with the agent.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If no default launcher is set and <code>launcher</code> is not specified.</p> </li> </ul> Source code in <code>academy/manager.py</code> <pre><code>def launch(\n    self,\n    behavior: BehaviorT,\n    *,\n    agent_id: AgentId[BehaviorT] | None = None,\n    launcher: str | None = None,\n    name: str | None = None,\n) -&gt; BoundRemoteHandle[BehaviorT]:\n    \"\"\"Launch a new agent with a specified behavior.\n\n    Note:\n        Compared to `Launcher.launch()`, this method will inject the\n        exchange and return a client-bound handle.\n\n    Args:\n        behavior: Behavior the agent should implement.\n        agent_id: Specify ID of the launched agent. If `None`, a new\n            agent ID will be created within the exchange.\n        launcher: Name of the launcher instance to use. In `None`, uses\n            the default launcher if specified, otherwise raises an error.\n        name: Readable name of the agent. Ignored if `agent_id` is\n            provided.\n\n    Returns:\n        Handle (client bound) used to interact with the agent.\n\n    Raises:\n        ValueError: If no default launcher is set and `launcher` is not\n            specified.\n    \"\"\"\n    if self._default_launcher is None and launcher is None:\n        raise ValueError(\n            'Must specify the launcher when no default is set.',\n        )\n    launcher = launcher if launcher is not None else self._default_launcher\n    assert launcher is not None\n    launcher_instance = self._launchers[launcher]\n    bound = launcher_instance.launch(\n        behavior,\n        exchange=self.exchange,\n        agent_id=agent_id,\n        name=name,\n    )\n    self._aid_to_launcher[bound.agent_id] = launcher\n    logger.info('Launched agent (%s; %s)', bound.agent_id, behavior)\n    self._handles[bound.agent_id] = bound\n    logger.debug('Bound agent handle to manager (%s)', bound)\n    return bound\n</code></pre>"},{"location":"api/manager/#academy.manager.Manager.shutdown","title":"shutdown","text":"<pre><code>shutdown(\n    agent_id: AgentId[Any],\n    *,\n    blocking: bool = True,\n    timeout: float | None = None\n) -&gt; None\n</code></pre> <p>Shutdown a launched agent.</p> <p>Parameters:</p> <ul> <li> <code>agent_id</code>               (<code>AgentId[Any]</code>)           \u2013            <p>ID of launched agent.</p> </li> <li> <code>blocking</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Wait for the agent to exit before returning.</p> </li> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional timeout is seconds when <code>blocking=True</code>.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BadEntityIdError</code>             \u2013            <p>If an agent with <code>agent_id</code> was not launched by this launcher.</p> </li> <li> <code>TimeoutError</code>             \u2013            <p>If <code>timeout</code> was exceeded while blocking for agent.</p> </li> </ul> Source code in <code>academy/manager.py</code> <pre><code>def shutdown(\n    self,\n    agent_id: AgentId[Any],\n    *,\n    blocking: bool = True,\n    timeout: float | None = None,\n) -&gt; None:\n    \"\"\"Shutdown a launched agent.\n\n    Args:\n        agent_id: ID of launched agent.\n        blocking: Wait for the agent to exit before returning.\n        timeout: Optional timeout is seconds when `blocking=True`.\n\n    Raises:\n        BadEntityIdError: If an agent with `agent_id` was not\n            launched by this launcher.\n        TimeoutError: If `timeout` was exceeded while blocking for agent.\n    \"\"\"\n    try:\n        handle = self._handles[agent_id]\n    except KeyError:\n        raise BadEntityIdError(agent_id) from None\n\n    with contextlib.suppress(MailboxClosedError):\n        handle.shutdown()\n\n    if blocking:\n        self.wait(agent_id, timeout=timeout)\n</code></pre>"},{"location":"api/manager/#academy.manager.Manager.wait","title":"wait","text":"<pre><code>wait(\n    agent: AgentId[Any] | BoundRemoteHandle[Any],\n    *,\n    timeout: float | None = None\n) -&gt; None\n</code></pre> <p>Wait for a launched agent to exit.</p> <p>Parameters:</p> <ul> <li> <code>agent</code>               (<code>AgentId[Any] | BoundRemoteHandle[Any]</code>)           \u2013            <p>ID or handle to the launched agent.</p> </li> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional timeout in seconds to wait for agent.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BadEntityIdError</code>             \u2013            <p>If the agent was not found. This likely means the agent was not launched by this launcher.</p> </li> <li> <code>TimeoutError</code>             \u2013            <p>If <code>timeout</code> was exceeded while waiting for agent.</p> </li> </ul> Source code in <code>academy/manager.py</code> <pre><code>def wait(\n    self,\n    agent: AgentId[Any] | BoundRemoteHandle[Any],\n    *,\n    timeout: float | None = None,\n) -&gt; None:\n    \"\"\"Wait for a launched agent to exit.\n\n    Args:\n        agent: ID or handle to the launched agent.\n        timeout: Optional timeout in seconds to wait for agent.\n\n    Raises:\n        BadEntityIdError: If the agent was not found. This likely means\n            the agent was not launched by this launcher.\n        TimeoutError: If `timeout` was exceeded while waiting for agent.\n    \"\"\"\n    agent_id = (\n        agent.agent_id if isinstance(agent, BoundRemoteHandle) else agent\n    )\n    if agent_id not in self._aid_to_launcher:\n        raise BadEntityIdError(agent_id)\n    launcher_name = self._aid_to_launcher[agent_id]\n    self._launchers[launcher_name].wait(agent_id, timeout=timeout)\n</code></pre>"},{"location":"api/message/","title":"academy.message","text":"<code>academy/message.py</code>"},{"location":"api/message/#academy.message.Message","title":"Message  <code>module-attribute</code>","text":"<pre><code>Message = Union[RequestMessage, ResponseMessage]\n</code></pre> <p>Message union type for type annotations.</p> Tip <p>This is a parameterized generic type meaning that this type cannot be used for [<code>isinstance</code>][<code>builtins.isinstance</code>] checks: <pre><code>isinstance(message, Message)  # Fails\n</code></pre> Instead, use <code>typing.get_args()</code>: <pre><code>from typing import get_args\n\nisinstance(message, get_args(Message))  # Works\n</code></pre></p>"},{"location":"api/message/#academy.message.BaseMessage","title":"BaseMessage  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base message type for messages between entities (agents or clients).</p> Note <p>The <code>hash()</code> of this type is a combination of the message type and message ID.</p> <p>Config:</p> <ul> <li><code>arbitrary_types_allowed</code>: <code>True</code></li> <li><code>extra</code>: <code>forbid</code></li> <li><code>frozen</code>: <code>False</code></li> <li><code>use_enum_values</code>: <code>True</code></li> <li><code>validate_default</code>: <code>True</code></li> </ul> <p>Fields:</p> <ul> <li> <code>tag</code>                 (<code>UUID</code>)             </li> <li> <code>src</code>                 (<code>EntityId</code>)             </li> <li> <code>dest</code>                 (<code>EntityId</code>)             </li> <li> <code>label</code>                 (<code>Optional[UUID]</code>)             </li> </ul>"},{"location":"api/message/#academy.message.BaseMessage.tag","title":"tag  <code>pydantic-field</code>","text":"<pre><code>tag: UUID\n</code></pre> <p>Unique message tag used to match requests and responses.</p>"},{"location":"api/message/#academy.message.BaseMessage.src","title":"src  <code>pydantic-field</code>","text":"<pre><code>src: EntityId\n</code></pre> <p>Source mailbox address.</p>"},{"location":"api/message/#academy.message.BaseMessage.dest","title":"dest  <code>pydantic-field</code>","text":"<pre><code>dest: EntityId\n</code></pre> <p>Destination mailbox address.</p>"},{"location":"api/message/#academy.message.BaseMessage.label","title":"label  <code>pydantic-field</code>","text":"<pre><code>label: Optional[UUID] = None\n</code></pre> <p>Optional label used to disambiguate response messages when multiple objects (i.e., handles) share the same mailbox. This is a different usage from the <code>tag</code>.</p>"},{"location":"api/message/#academy.message.BaseMessage.model_from_json","title":"model_from_json  <code>classmethod</code>","text":"<pre><code>model_from_json(data: str) -&gt; Message\n</code></pre> <p>Reconstruct a specific message from a JSON dump.</p> Example <pre><code>from academy.message import BaseMessage, ActionRequest\n\nmessage = ActionRequest(...)\ndump = message.model_dump_json()\nassert BaseMessage.model_from_json(dump) == message\n</code></pre> Source code in <code>academy/message.py</code> <pre><code>@classmethod\ndef model_from_json(cls, data: str) -&gt; Message:\n    \"\"\"Reconstruct a specific message from a JSON dump.\n\n    Example:\n        ```python\n        from academy.message import BaseMessage, ActionRequest\n\n        message = ActionRequest(...)\n        dump = message.model_dump_json()\n        assert BaseMessage.model_from_json(dump) == message\n        ```\n    \"\"\"\n    return TypeAdapter(Message).validate_json(data)\n</code></pre>"},{"location":"api/message/#academy.message.BaseMessage.model_deserialize","title":"model_deserialize  <code>classmethod</code>","text":"<pre><code>model_deserialize(data: bytes) -&gt; Message\n</code></pre> <p>Deserialize a message.</p> Warning <p>This uses pickle and is therefore suceptible to all the typical pickle warnings about code injection.</p> Source code in <code>academy/message.py</code> <pre><code>@classmethod\ndef model_deserialize(cls, data: bytes) -&gt; Message:\n    \"\"\"Deserialize a message.\n\n    Warning:\n        This uses pickle and is therefore suceptible to all the\n        typical pickle warnings about code injection.\n    \"\"\"\n    message = pickle.loads(data)\n    if not isinstance(message, get_args(Message)):\n        raise TypeError(\n            'Deserialized message is not of type Message.',\n        )\n    return message\n</code></pre>"},{"location":"api/message/#academy.message.BaseMessage.model_serialize","title":"model_serialize","text":"<pre><code>model_serialize() -&gt; bytes\n</code></pre> <p>Serialize a message to bytes.</p> Warning <p>This uses pickle and is therefore suceptible to all the typical pickle warnings about code injection.</p> Source code in <code>academy/message.py</code> <pre><code>def model_serialize(self) -&gt; bytes:\n    \"\"\"Serialize a message to bytes.\n\n    Warning:\n        This uses pickle and is therefore suceptible to all the\n        typical pickle warnings about code injection.\n    \"\"\"\n    return pickle.dumps(self)\n</code></pre>"},{"location":"api/message/#academy.message.ActionRequest","title":"ActionRequest  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseMessage</code></p> <p>Agent action request message.</p> <p>When this message is dumped to a JSON string, the <code>pargs</code> and <code>kargs</code> are pickled and then base64 encoded to a string. This can have non-trivial time and space overheads for large arguments.</p> <p>Fields:</p> <ul> <li> <code>tag</code>                 (<code>UUID</code>)             </li> <li> <code>src</code>                 (<code>EntityId</code>)             </li> <li> <code>dest</code>                 (<code>EntityId</code>)             </li> <li> <code>label</code>                 (<code>Optional[UUID]</code>)             </li> <li> <code>action</code>                 (<code>str</code>)             </li> <li> <code>pargs</code>                 (<code>tuple[Any, ...]</code>)             </li> <li> <code>kargs</code>                 (<code>dict[str, Any]</code>)             </li> <li> <code>kind</code>                 (<code>Literal['action-request']</code>)             </li> </ul> <p>Validators:</p> <ul> <li> <code>_decode_pickled_obj</code>                 \u2192                   <code>pargs</code>,                   <code>kargs</code> </li> </ul>"},{"location":"api/message/#academy.message.ActionRequest.action","title":"action  <code>pydantic-field</code>","text":"<pre><code>action: str\n</code></pre> <p>Name of the requested action.</p>"},{"location":"api/message/#academy.message.ActionRequest.pargs","title":"pargs  <code>pydantic-field</code>","text":"<pre><code>pargs: tuple[Any, ...]\n</code></pre> <p>Positional arguments to the action method.</p>"},{"location":"api/message/#academy.message.ActionRequest.kargs","title":"kargs  <code>pydantic-field</code>","text":"<pre><code>kargs: dict[str, Any]\n</code></pre> <p>Keyword arguments to the action method.</p>"},{"location":"api/message/#academy.message.ActionRequest.tag","title":"tag  <code>pydantic-field</code>","text":"<pre><code>tag: UUID\n</code></pre> <p>Unique message tag used to match requests and responses.</p>"},{"location":"api/message/#academy.message.ActionRequest.src","title":"src  <code>pydantic-field</code>","text":"<pre><code>src: EntityId\n</code></pre> <p>Source mailbox address.</p>"},{"location":"api/message/#academy.message.ActionRequest.dest","title":"dest  <code>pydantic-field</code>","text":"<pre><code>dest: EntityId\n</code></pre> <p>Destination mailbox address.</p>"},{"location":"api/message/#academy.message.ActionRequest.label","title":"label  <code>pydantic-field</code>","text":"<pre><code>label: Optional[UUID] = None\n</code></pre> <p>Optional label used to disambiguate response messages when multiple objects (i.e., handles) share the same mailbox. This is a different usage from the <code>tag</code>.</p>"},{"location":"api/message/#academy.message.ActionRequest.error","title":"error","text":"<pre><code>error(exception: Exception) -&gt; ActionResponse\n</code></pre> <p>Construct an error response to action request.</p> <p>Parameters:</p> <ul> <li> <code>exception</code>               (<code>Exception</code>)           \u2013            <p>Error of the action.</p> </li> </ul> Source code in <code>academy/message.py</code> <pre><code>def error(self, exception: Exception) -&gt; ActionResponse:\n    \"\"\"Construct an error response to action request.\n\n    Args:\n        exception: Error of the action.\n    \"\"\"\n    return ActionResponse(\n        tag=self.tag,\n        src=self.dest,\n        dest=self.src,\n        label=self.label,\n        action=self.action,\n        result=None,\n        exception=exception,\n    )\n</code></pre>"},{"location":"api/message/#academy.message.ActionRequest.response","title":"response","text":"<pre><code>response(result: Any) -&gt; ActionResponse\n</code></pre> <p>Construct a success response to action request.</p> <p>Parameters:</p> <ul> <li> <code>result</code>               (<code>Any</code>)           \u2013            <p>Result of the action.</p> </li> </ul> Source code in <code>academy/message.py</code> <pre><code>def response(self, result: Any) -&gt; ActionResponse:\n    \"\"\"Construct a success response to action request.\n\n    Args:\n        result: Result of the action.\n    \"\"\"\n    return ActionResponse(\n        tag=self.tag,\n        src=self.dest,\n        dest=self.src,\n        label=self.label,\n        action=self.action,\n        result=result,\n        exception=None,\n    )\n</code></pre>"},{"location":"api/message/#academy.message.ActionRequest.model_from_json","title":"model_from_json  <code>classmethod</code>","text":"<pre><code>model_from_json(data: str) -&gt; Message\n</code></pre> <p>Reconstruct a specific message from a JSON dump.</p> Example <pre><code>from academy.message import BaseMessage, ActionRequest\n\nmessage = ActionRequest(...)\ndump = message.model_dump_json()\nassert BaseMessage.model_from_json(dump) == message\n</code></pre> Source code in <code>academy/message.py</code> <pre><code>@classmethod\ndef model_from_json(cls, data: str) -&gt; Message:\n    \"\"\"Reconstruct a specific message from a JSON dump.\n\n    Example:\n        ```python\n        from academy.message import BaseMessage, ActionRequest\n\n        message = ActionRequest(...)\n        dump = message.model_dump_json()\n        assert BaseMessage.model_from_json(dump) == message\n        ```\n    \"\"\"\n    return TypeAdapter(Message).validate_json(data)\n</code></pre>"},{"location":"api/message/#academy.message.ActionRequest.model_deserialize","title":"model_deserialize  <code>classmethod</code>","text":"<pre><code>model_deserialize(data: bytes) -&gt; Message\n</code></pre> <p>Deserialize a message.</p> Warning <p>This uses pickle and is therefore suceptible to all the typical pickle warnings about code injection.</p> Source code in <code>academy/message.py</code> <pre><code>@classmethod\ndef model_deserialize(cls, data: bytes) -&gt; Message:\n    \"\"\"Deserialize a message.\n\n    Warning:\n        This uses pickle and is therefore suceptible to all the\n        typical pickle warnings about code injection.\n    \"\"\"\n    message = pickle.loads(data)\n    if not isinstance(message, get_args(Message)):\n        raise TypeError(\n            'Deserialized message is not of type Message.',\n        )\n    return message\n</code></pre>"},{"location":"api/message/#academy.message.ActionRequest.model_serialize","title":"model_serialize","text":"<pre><code>model_serialize() -&gt; bytes\n</code></pre> <p>Serialize a message to bytes.</p> Warning <p>This uses pickle and is therefore suceptible to all the typical pickle warnings about code injection.</p> Source code in <code>academy/message.py</code> <pre><code>def model_serialize(self) -&gt; bytes:\n    \"\"\"Serialize a message to bytes.\n\n    Warning:\n        This uses pickle and is therefore suceptible to all the\n        typical pickle warnings about code injection.\n    \"\"\"\n    return pickle.dumps(self)\n</code></pre>"},{"location":"api/message/#academy.message.ActionResponse","title":"ActionResponse  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseMessage</code></p> <p>Agent action response message.</p> <p>Fields:</p> <ul> <li> <code>tag</code>                 (<code>UUID</code>)             </li> <li> <code>src</code>                 (<code>EntityId</code>)             </li> <li> <code>dest</code>                 (<code>EntityId</code>)             </li> <li> <code>label</code>                 (<code>Optional[UUID]</code>)             </li> <li> <code>action</code>                 (<code>str</code>)             </li> <li> <code>result</code>                 (<code>Any</code>)             </li> <li> <code>exception</code>                 (<code>Optional[Exception]</code>)             </li> <li> <code>kind</code>                 (<code>Literal['action-response']</code>)             </li> </ul> <p>Validators:</p> <ul> <li> <code>_decode_pickled_obj</code>                 \u2192                   <code>exception</code>,                   <code>result</code> </li> </ul>"},{"location":"api/message/#academy.message.ActionResponse.action","title":"action  <code>pydantic-field</code>","text":"<pre><code>action: str\n</code></pre> <p>Name of the requested action.</p>"},{"location":"api/message/#academy.message.ActionResponse.result","title":"result  <code>pydantic-field</code>","text":"<pre><code>result: Any = None\n</code></pre> <p>Result of the action, if successful.</p>"},{"location":"api/message/#academy.message.ActionResponse.exception","title":"exception  <code>pydantic-field</code>","text":"<pre><code>exception: Optional[Exception] = None\n</code></pre> <p>Exception of the action, if unsuccessful.</p>"},{"location":"api/message/#academy.message.ActionResponse.tag","title":"tag  <code>pydantic-field</code>","text":"<pre><code>tag: UUID\n</code></pre> <p>Unique message tag used to match requests and responses.</p>"},{"location":"api/message/#academy.message.ActionResponse.src","title":"src  <code>pydantic-field</code>","text":"<pre><code>src: EntityId\n</code></pre> <p>Source mailbox address.</p>"},{"location":"api/message/#academy.message.ActionResponse.dest","title":"dest  <code>pydantic-field</code>","text":"<pre><code>dest: EntityId\n</code></pre> <p>Destination mailbox address.</p>"},{"location":"api/message/#academy.message.ActionResponse.label","title":"label  <code>pydantic-field</code>","text":"<pre><code>label: Optional[UUID] = None\n</code></pre> <p>Optional label used to disambiguate response messages when multiple objects (i.e., handles) share the same mailbox. This is a different usage from the <code>tag</code>.</p>"},{"location":"api/message/#academy.message.ActionResponse.model_from_json","title":"model_from_json  <code>classmethod</code>","text":"<pre><code>model_from_json(data: str) -&gt; Message\n</code></pre> <p>Reconstruct a specific message from a JSON dump.</p> Example <pre><code>from academy.message import BaseMessage, ActionRequest\n\nmessage = ActionRequest(...)\ndump = message.model_dump_json()\nassert BaseMessage.model_from_json(dump) == message\n</code></pre> Source code in <code>academy/message.py</code> <pre><code>@classmethod\ndef model_from_json(cls, data: str) -&gt; Message:\n    \"\"\"Reconstruct a specific message from a JSON dump.\n\n    Example:\n        ```python\n        from academy.message import BaseMessage, ActionRequest\n\n        message = ActionRequest(...)\n        dump = message.model_dump_json()\n        assert BaseMessage.model_from_json(dump) == message\n        ```\n    \"\"\"\n    return TypeAdapter(Message).validate_json(data)\n</code></pre>"},{"location":"api/message/#academy.message.ActionResponse.model_deserialize","title":"model_deserialize  <code>classmethod</code>","text":"<pre><code>model_deserialize(data: bytes) -&gt; Message\n</code></pre> <p>Deserialize a message.</p> Warning <p>This uses pickle and is therefore suceptible to all the typical pickle warnings about code injection.</p> Source code in <code>academy/message.py</code> <pre><code>@classmethod\ndef model_deserialize(cls, data: bytes) -&gt; Message:\n    \"\"\"Deserialize a message.\n\n    Warning:\n        This uses pickle and is therefore suceptible to all the\n        typical pickle warnings about code injection.\n    \"\"\"\n    message = pickle.loads(data)\n    if not isinstance(message, get_args(Message)):\n        raise TypeError(\n            'Deserialized message is not of type Message.',\n        )\n    return message\n</code></pre>"},{"location":"api/message/#academy.message.ActionResponse.model_serialize","title":"model_serialize","text":"<pre><code>model_serialize() -&gt; bytes\n</code></pre> <p>Serialize a message to bytes.</p> Warning <p>This uses pickle and is therefore suceptible to all the typical pickle warnings about code injection.</p> Source code in <code>academy/message.py</code> <pre><code>def model_serialize(self) -&gt; bytes:\n    \"\"\"Serialize a message to bytes.\n\n    Warning:\n        This uses pickle and is therefore suceptible to all the\n        typical pickle warnings about code injection.\n    \"\"\"\n    return pickle.dumps(self)\n</code></pre>"},{"location":"api/message/#academy.message.PingRequest","title":"PingRequest  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseMessage</code></p> <p>Ping request message.</p> <p>Fields:</p> <ul> <li> <code>tag</code>                 (<code>UUID</code>)             </li> <li> <code>src</code>                 (<code>EntityId</code>)             </li> <li> <code>dest</code>                 (<code>EntityId</code>)             </li> <li> <code>label</code>                 (<code>Optional[UUID]</code>)             </li> <li> <code>kind</code>                 (<code>Literal['ping-request']</code>)             </li> </ul>"},{"location":"api/message/#academy.message.PingRequest.tag","title":"tag  <code>pydantic-field</code>","text":"<pre><code>tag: UUID\n</code></pre> <p>Unique message tag used to match requests and responses.</p>"},{"location":"api/message/#academy.message.PingRequest.src","title":"src  <code>pydantic-field</code>","text":"<pre><code>src: EntityId\n</code></pre> <p>Source mailbox address.</p>"},{"location":"api/message/#academy.message.PingRequest.dest","title":"dest  <code>pydantic-field</code>","text":"<pre><code>dest: EntityId\n</code></pre> <p>Destination mailbox address.</p>"},{"location":"api/message/#academy.message.PingRequest.label","title":"label  <code>pydantic-field</code>","text":"<pre><code>label: Optional[UUID] = None\n</code></pre> <p>Optional label used to disambiguate response messages when multiple objects (i.e., handles) share the same mailbox. This is a different usage from the <code>tag</code>.</p>"},{"location":"api/message/#academy.message.PingRequest.response","title":"response","text":"<pre><code>response() -&gt; PingResponse\n</code></pre> <p>Construct a ping response message.</p> Source code in <code>academy/message.py</code> <pre><code>def response(self) -&gt; PingResponse:\n    \"\"\"Construct a ping response message.\"\"\"\n    return PingResponse(\n        tag=self.tag,\n        src=self.dest,\n        dest=self.src,\n        label=self.label,\n        exception=None,\n    )\n</code></pre>"},{"location":"api/message/#academy.message.PingRequest.error","title":"error","text":"<pre><code>error(exception: Exception) -&gt; PingResponse\n</code></pre> <p>Construct an error response to ping request.</p> <p>Parameters:</p> <ul> <li> <code>exception</code>               (<code>Exception</code>)           \u2013            <p>Error of the action.</p> </li> </ul> Source code in <code>academy/message.py</code> <pre><code>def error(self, exception: Exception) -&gt; PingResponse:\n    \"\"\"Construct an error response to ping request.\n\n    Args:\n        exception: Error of the action.\n    \"\"\"\n    return PingResponse(\n        tag=self.tag,\n        src=self.dest,\n        dest=self.src,\n        label=self.label,\n        exception=exception,\n    )\n</code></pre>"},{"location":"api/message/#academy.message.PingRequest.model_from_json","title":"model_from_json  <code>classmethod</code>","text":"<pre><code>model_from_json(data: str) -&gt; Message\n</code></pre> <p>Reconstruct a specific message from a JSON dump.</p> Example <pre><code>from academy.message import BaseMessage, ActionRequest\n\nmessage = ActionRequest(...)\ndump = message.model_dump_json()\nassert BaseMessage.model_from_json(dump) == message\n</code></pre> Source code in <code>academy/message.py</code> <pre><code>@classmethod\ndef model_from_json(cls, data: str) -&gt; Message:\n    \"\"\"Reconstruct a specific message from a JSON dump.\n\n    Example:\n        ```python\n        from academy.message import BaseMessage, ActionRequest\n\n        message = ActionRequest(...)\n        dump = message.model_dump_json()\n        assert BaseMessage.model_from_json(dump) == message\n        ```\n    \"\"\"\n    return TypeAdapter(Message).validate_json(data)\n</code></pre>"},{"location":"api/message/#academy.message.PingRequest.model_deserialize","title":"model_deserialize  <code>classmethod</code>","text":"<pre><code>model_deserialize(data: bytes) -&gt; Message\n</code></pre> <p>Deserialize a message.</p> Warning <p>This uses pickle and is therefore suceptible to all the typical pickle warnings about code injection.</p> Source code in <code>academy/message.py</code> <pre><code>@classmethod\ndef model_deserialize(cls, data: bytes) -&gt; Message:\n    \"\"\"Deserialize a message.\n\n    Warning:\n        This uses pickle and is therefore suceptible to all the\n        typical pickle warnings about code injection.\n    \"\"\"\n    message = pickle.loads(data)\n    if not isinstance(message, get_args(Message)):\n        raise TypeError(\n            'Deserialized message is not of type Message.',\n        )\n    return message\n</code></pre>"},{"location":"api/message/#academy.message.PingRequest.model_serialize","title":"model_serialize","text":"<pre><code>model_serialize() -&gt; bytes\n</code></pre> <p>Serialize a message to bytes.</p> Warning <p>This uses pickle and is therefore suceptible to all the typical pickle warnings about code injection.</p> Source code in <code>academy/message.py</code> <pre><code>def model_serialize(self) -&gt; bytes:\n    \"\"\"Serialize a message to bytes.\n\n    Warning:\n        This uses pickle and is therefore suceptible to all the\n        typical pickle warnings about code injection.\n    \"\"\"\n    return pickle.dumps(self)\n</code></pre>"},{"location":"api/message/#academy.message.PingResponse","title":"PingResponse  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseMessage</code></p> <p>Ping response message.</p> <p>Fields:</p> <ul> <li> <code>tag</code>                 (<code>UUID</code>)             </li> <li> <code>src</code>                 (<code>EntityId</code>)             </li> <li> <code>dest</code>                 (<code>EntityId</code>)             </li> <li> <code>label</code>                 (<code>Optional[UUID]</code>)             </li> <li> <code>exception</code>                 (<code>Optional[Exception]</code>)             </li> <li> <code>kind</code>                 (<code>Literal['ping-response']</code>)             </li> </ul> <p>Validators:</p> <ul> <li> <code>_decode_pickled_obj</code>                 \u2192                   <code>exception</code> </li> </ul>"},{"location":"api/message/#academy.message.PingResponse.exception","title":"exception  <code>pydantic-field</code>","text":"<pre><code>exception: Optional[Exception] = None\n</code></pre> <p>Exception of the ping, if unsuccessful.</p>"},{"location":"api/message/#academy.message.PingResponse.tag","title":"tag  <code>pydantic-field</code>","text":"<pre><code>tag: UUID\n</code></pre> <p>Unique message tag used to match requests and responses.</p>"},{"location":"api/message/#academy.message.PingResponse.src","title":"src  <code>pydantic-field</code>","text":"<pre><code>src: EntityId\n</code></pre> <p>Source mailbox address.</p>"},{"location":"api/message/#academy.message.PingResponse.dest","title":"dest  <code>pydantic-field</code>","text":"<pre><code>dest: EntityId\n</code></pre> <p>Destination mailbox address.</p>"},{"location":"api/message/#academy.message.PingResponse.label","title":"label  <code>pydantic-field</code>","text":"<pre><code>label: Optional[UUID] = None\n</code></pre> <p>Optional label used to disambiguate response messages when multiple objects (i.e., handles) share the same mailbox. This is a different usage from the <code>tag</code>.</p>"},{"location":"api/message/#academy.message.PingResponse.model_from_json","title":"model_from_json  <code>classmethod</code>","text":"<pre><code>model_from_json(data: str) -&gt; Message\n</code></pre> <p>Reconstruct a specific message from a JSON dump.</p> Example <pre><code>from academy.message import BaseMessage, ActionRequest\n\nmessage = ActionRequest(...)\ndump = message.model_dump_json()\nassert BaseMessage.model_from_json(dump) == message\n</code></pre> Source code in <code>academy/message.py</code> <pre><code>@classmethod\ndef model_from_json(cls, data: str) -&gt; Message:\n    \"\"\"Reconstruct a specific message from a JSON dump.\n\n    Example:\n        ```python\n        from academy.message import BaseMessage, ActionRequest\n\n        message = ActionRequest(...)\n        dump = message.model_dump_json()\n        assert BaseMessage.model_from_json(dump) == message\n        ```\n    \"\"\"\n    return TypeAdapter(Message).validate_json(data)\n</code></pre>"},{"location":"api/message/#academy.message.PingResponse.model_deserialize","title":"model_deserialize  <code>classmethod</code>","text":"<pre><code>model_deserialize(data: bytes) -&gt; Message\n</code></pre> <p>Deserialize a message.</p> Warning <p>This uses pickle and is therefore suceptible to all the typical pickle warnings about code injection.</p> Source code in <code>academy/message.py</code> <pre><code>@classmethod\ndef model_deserialize(cls, data: bytes) -&gt; Message:\n    \"\"\"Deserialize a message.\n\n    Warning:\n        This uses pickle and is therefore suceptible to all the\n        typical pickle warnings about code injection.\n    \"\"\"\n    message = pickle.loads(data)\n    if not isinstance(message, get_args(Message)):\n        raise TypeError(\n            'Deserialized message is not of type Message.',\n        )\n    return message\n</code></pre>"},{"location":"api/message/#academy.message.PingResponse.model_serialize","title":"model_serialize","text":"<pre><code>model_serialize() -&gt; bytes\n</code></pre> <p>Serialize a message to bytes.</p> Warning <p>This uses pickle and is therefore suceptible to all the typical pickle warnings about code injection.</p> Source code in <code>academy/message.py</code> <pre><code>def model_serialize(self) -&gt; bytes:\n    \"\"\"Serialize a message to bytes.\n\n    Warning:\n        This uses pickle and is therefore suceptible to all the\n        typical pickle warnings about code injection.\n    \"\"\"\n    return pickle.dumps(self)\n</code></pre>"},{"location":"api/message/#academy.message.ShutdownRequest","title":"ShutdownRequest  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseMessage</code></p> <p>Agent shutdown request message.</p> <p>Fields:</p> <ul> <li> <code>tag</code>                 (<code>UUID</code>)             </li> <li> <code>src</code>                 (<code>EntityId</code>)             </li> <li> <code>dest</code>                 (<code>EntityId</code>)             </li> <li> <code>label</code>                 (<code>Optional[UUID]</code>)             </li> <li> <code>kind</code>                 (<code>Literal['shutdown-request']</code>)             </li> </ul> <p>Validators:</p> <ul> <li> <code>_validate_agent</code>                 \u2192                   <code>dest</code> </li> </ul>"},{"location":"api/message/#academy.message.ShutdownRequest.tag","title":"tag  <code>pydantic-field</code>","text":"<pre><code>tag: UUID\n</code></pre> <p>Unique message tag used to match requests and responses.</p>"},{"location":"api/message/#academy.message.ShutdownRequest.src","title":"src  <code>pydantic-field</code>","text":"<pre><code>src: EntityId\n</code></pre> <p>Source mailbox address.</p>"},{"location":"api/message/#academy.message.ShutdownRequest.dest","title":"dest  <code>pydantic-field</code>","text":"<pre><code>dest: EntityId\n</code></pre> <p>Destination mailbox address.</p>"},{"location":"api/message/#academy.message.ShutdownRequest.label","title":"label  <code>pydantic-field</code>","text":"<pre><code>label: Optional[UUID] = None\n</code></pre> <p>Optional label used to disambiguate response messages when multiple objects (i.e., handles) share the same mailbox. This is a different usage from the <code>tag</code>.</p>"},{"location":"api/message/#academy.message.ShutdownRequest.response","title":"response","text":"<pre><code>response() -&gt; ShutdownResponse\n</code></pre> <p>Construct a shutdown response message.</p> Source code in <code>academy/message.py</code> <pre><code>def response(self) -&gt; ShutdownResponse:\n    \"\"\"Construct a shutdown response message.\"\"\"\n    return ShutdownResponse(\n        tag=self.tag,\n        src=self.dest,\n        dest=self.src,\n        label=self.label,\n        exception=None,\n    )\n</code></pre>"},{"location":"api/message/#academy.message.ShutdownRequest.error","title":"error","text":"<pre><code>error(exception: Exception) -&gt; ShutdownResponse\n</code></pre> <p>Construct an error response to shutdown request.</p> <p>Parameters:</p> <ul> <li> <code>exception</code>               (<code>Exception</code>)           \u2013            <p>Error of the action.</p> </li> </ul> Source code in <code>academy/message.py</code> <pre><code>def error(self, exception: Exception) -&gt; ShutdownResponse:\n    \"\"\"Construct an error response to shutdown request.\n\n    Args:\n        exception: Error of the action.\n    \"\"\"\n    return ShutdownResponse(\n        tag=self.tag,\n        src=self.dest,\n        dest=self.src,\n        label=self.label,\n        exception=exception,\n    )\n</code></pre>"},{"location":"api/message/#academy.message.ShutdownRequest.model_from_json","title":"model_from_json  <code>classmethod</code>","text":"<pre><code>model_from_json(data: str) -&gt; Message\n</code></pre> <p>Reconstruct a specific message from a JSON dump.</p> Example <pre><code>from academy.message import BaseMessage, ActionRequest\n\nmessage = ActionRequest(...)\ndump = message.model_dump_json()\nassert BaseMessage.model_from_json(dump) == message\n</code></pre> Source code in <code>academy/message.py</code> <pre><code>@classmethod\ndef model_from_json(cls, data: str) -&gt; Message:\n    \"\"\"Reconstruct a specific message from a JSON dump.\n\n    Example:\n        ```python\n        from academy.message import BaseMessage, ActionRequest\n\n        message = ActionRequest(...)\n        dump = message.model_dump_json()\n        assert BaseMessage.model_from_json(dump) == message\n        ```\n    \"\"\"\n    return TypeAdapter(Message).validate_json(data)\n</code></pre>"},{"location":"api/message/#academy.message.ShutdownRequest.model_deserialize","title":"model_deserialize  <code>classmethod</code>","text":"<pre><code>model_deserialize(data: bytes) -&gt; Message\n</code></pre> <p>Deserialize a message.</p> Warning <p>This uses pickle and is therefore suceptible to all the typical pickle warnings about code injection.</p> Source code in <code>academy/message.py</code> <pre><code>@classmethod\ndef model_deserialize(cls, data: bytes) -&gt; Message:\n    \"\"\"Deserialize a message.\n\n    Warning:\n        This uses pickle and is therefore suceptible to all the\n        typical pickle warnings about code injection.\n    \"\"\"\n    message = pickle.loads(data)\n    if not isinstance(message, get_args(Message)):\n        raise TypeError(\n            'Deserialized message is not of type Message.',\n        )\n    return message\n</code></pre>"},{"location":"api/message/#academy.message.ShutdownRequest.model_serialize","title":"model_serialize","text":"<pre><code>model_serialize() -&gt; bytes\n</code></pre> <p>Serialize a message to bytes.</p> Warning <p>This uses pickle and is therefore suceptible to all the typical pickle warnings about code injection.</p> Source code in <code>academy/message.py</code> <pre><code>def model_serialize(self) -&gt; bytes:\n    \"\"\"Serialize a message to bytes.\n\n    Warning:\n        This uses pickle and is therefore suceptible to all the\n        typical pickle warnings about code injection.\n    \"\"\"\n    return pickle.dumps(self)\n</code></pre>"},{"location":"api/message/#academy.message.ShutdownResponse","title":"ShutdownResponse  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseMessage</code></p> <p>Agent shutdown response message.</p> <p>Fields:</p> <ul> <li> <code>tag</code>                 (<code>UUID</code>)             </li> <li> <code>src</code>                 (<code>EntityId</code>)             </li> <li> <code>dest</code>                 (<code>EntityId</code>)             </li> <li> <code>label</code>                 (<code>Optional[UUID]</code>)             </li> <li> <code>exception</code>                 (<code>Optional[Exception]</code>)             </li> <li> <code>kind</code>                 (<code>Literal['shutdown-response']</code>)             </li> </ul> <p>Validators:</p> <ul> <li> <code>_decode_pickled_obj</code>                 \u2192                   <code>exception</code> </li> </ul>"},{"location":"api/message/#academy.message.ShutdownResponse.exception","title":"exception  <code>pydantic-field</code>","text":"<pre><code>exception: Optional[Exception] = None\n</code></pre> <p>Exception of the request, if unsuccessful.</p>"},{"location":"api/message/#academy.message.ShutdownResponse.tag","title":"tag  <code>pydantic-field</code>","text":"<pre><code>tag: UUID\n</code></pre> <p>Unique message tag used to match requests and responses.</p>"},{"location":"api/message/#academy.message.ShutdownResponse.src","title":"src  <code>pydantic-field</code>","text":"<pre><code>src: EntityId\n</code></pre> <p>Source mailbox address.</p>"},{"location":"api/message/#academy.message.ShutdownResponse.dest","title":"dest  <code>pydantic-field</code>","text":"<pre><code>dest: EntityId\n</code></pre> <p>Destination mailbox address.</p>"},{"location":"api/message/#academy.message.ShutdownResponse.label","title":"label  <code>pydantic-field</code>","text":"<pre><code>label: Optional[UUID] = None\n</code></pre> <p>Optional label used to disambiguate response messages when multiple objects (i.e., handles) share the same mailbox. This is a different usage from the <code>tag</code>.</p>"},{"location":"api/message/#academy.message.ShutdownResponse.model_from_json","title":"model_from_json  <code>classmethod</code>","text":"<pre><code>model_from_json(data: str) -&gt; Message\n</code></pre> <p>Reconstruct a specific message from a JSON dump.</p> Example <pre><code>from academy.message import BaseMessage, ActionRequest\n\nmessage = ActionRequest(...)\ndump = message.model_dump_json()\nassert BaseMessage.model_from_json(dump) == message\n</code></pre> Source code in <code>academy/message.py</code> <pre><code>@classmethod\ndef model_from_json(cls, data: str) -&gt; Message:\n    \"\"\"Reconstruct a specific message from a JSON dump.\n\n    Example:\n        ```python\n        from academy.message import BaseMessage, ActionRequest\n\n        message = ActionRequest(...)\n        dump = message.model_dump_json()\n        assert BaseMessage.model_from_json(dump) == message\n        ```\n    \"\"\"\n    return TypeAdapter(Message).validate_json(data)\n</code></pre>"},{"location":"api/message/#academy.message.ShutdownResponse.model_deserialize","title":"model_deserialize  <code>classmethod</code>","text":"<pre><code>model_deserialize(data: bytes) -&gt; Message\n</code></pre> <p>Deserialize a message.</p> Warning <p>This uses pickle and is therefore suceptible to all the typical pickle warnings about code injection.</p> Source code in <code>academy/message.py</code> <pre><code>@classmethod\ndef model_deserialize(cls, data: bytes) -&gt; Message:\n    \"\"\"Deserialize a message.\n\n    Warning:\n        This uses pickle and is therefore suceptible to all the\n        typical pickle warnings about code injection.\n    \"\"\"\n    message = pickle.loads(data)\n    if not isinstance(message, get_args(Message)):\n        raise TypeError(\n            'Deserialized message is not of type Message.',\n        )\n    return message\n</code></pre>"},{"location":"api/message/#academy.message.ShutdownResponse.model_serialize","title":"model_serialize","text":"<pre><code>model_serialize() -&gt; bytes\n</code></pre> <p>Serialize a message to bytes.</p> Warning <p>This uses pickle and is therefore suceptible to all the typical pickle warnings about code injection.</p> Source code in <code>academy/message.py</code> <pre><code>def model_serialize(self) -&gt; bytes:\n    \"\"\"Serialize a message to bytes.\n\n    Warning:\n        This uses pickle and is therefore suceptible to all the\n        typical pickle warnings about code injection.\n    \"\"\"\n    return pickle.dumps(self)\n</code></pre>"},{"location":"api/mypy_plugin/","title":"academy.mypy_plugin","text":"<code>academy/mypy_plugin.py</code> <p>Academy mypy plugin.</p> <p>This plugin enables mypy to perform static type inference on <code>Handle</code> types.</p> <p>For example, the return type of an action invocation on a remote agent via a handle is a <code>Future</code> wrapping the return type of the action. <pre><code>from academy.behavior import Behavior, action\nfrom academy.handle import Handle\n\nclass Example(Behavior):\n    @action\n    def get_value(self) -&gt; int: ...\n\nhandle: Handle[Example]\n\nreveal_type(handle.get_value())\n# note: Revealed type is \"Future[int]\"\n</code></pre> Without the plugin, mypy will default to <code>Any</code>.</p> Note <p>The plugin makes a best effort to warn users about incorrect use of agent handles. This includes raising errors when accessing attributes of a behavior, rather than methods, via a handle and when incorrect parameter types are passed to an action. However, the plugin cannot distinguish which callable attributes of a handle are annotated as actions, but this will still produce an error at runtime.</p> <p>Enable the plugin by adding <code>academy.mypy_plugin</code> to the list of plugins in your mypy config file.</p> <ul> <li><code>pyproject.toml</code> <pre><code>[tools.mypy]\nplugins = [\"academy.mypy_plugin\"]\n</code></pre></li> <li><code>mypy.ini</code> and <code>setup.cfg</code> <pre><code>[mypy]\nplugins = academy.mypy_plugin\n</code></pre></li> </ul>"},{"location":"api/serialize/","title":"academy.serialize","text":"<code>academy/serialize.py</code>"},{"location":"api/serialize/#academy.serialize.NoPickleMixin","title":"NoPickleMixin","text":"<p>Mixin that raises an error if a type is pickled.</p>"},{"location":"api/socket/","title":"academy.socket","text":"<code>academy/socket.py</code>"},{"location":"api/socket/#academy.socket.SocketClosedError","title":"SocketClosedError","text":"<p>               Bases: <code>Exception</code></p> <p>Socket is already closed.</p>"},{"location":"api/socket/#academy.socket.SocketOpenError","title":"SocketOpenError","text":"<p>               Bases: <code>Exception</code></p> <p>Failed to open socket.</p>"},{"location":"api/socket/#academy.socket.SimpleSocket","title":"SimpleSocket","text":"<pre><code>SimpleSocket(\n    host: str, port: int, *, timeout: float | None = None\n)\n</code></pre> <p>Simple socket wrapper.</p> <p>Configures a client connection using a blocking TCP socket over IPv4. The send and recv methods handle byte encoding, message delimiters, and partial message buffering.</p> Note <p>This class can be used as a context manager.</p> <p>Parameters:</p> <ul> <li> <code>host</code>               (<code>str</code>)           \u2013            <p>Host address to connect to.</p> </li> <li> <code>port</code>               (<code>int</code>)           \u2013            <p>Port to connect to.</p> </li> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Connection establish timeout.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>SocketOpenError</code>             \u2013            <p>if creating the socket fails. The <code>__cause__</code> of the exception will be set to the underlying <code>OSError</code>.</p> </li> </ul> Source code in <code>academy/socket.py</code> <pre><code>def __init__(\n    self,\n    host: str,\n    port: int,\n    *,\n    timeout: float | None = None,\n) -&gt; None:\n    self.host = host\n    self.port = port\n    self.timeout = timeout\n    self.closed = False\n    try:\n        self.socket = socket.create_connection(\n            (self.host, self.port),\n            timeout=self.timeout,\n        )\n    except OSError as e:\n        raise SocketOpenError() from e\n</code></pre>"},{"location":"api/socket/#academy.socket.SimpleSocket.close","title":"close","text":"<pre><code>close(shutdown: bool = True) -&gt; None\n</code></pre> <p>Close the socket.</p> Source code in <code>academy/socket.py</code> <pre><code>def close(self, shutdown: bool = True) -&gt; None:\n    \"\"\"Close the socket.\"\"\"\n    if self.closed:\n        return\n    if shutdown:  # pragma: no branch\n        with contextlib.suppress(OSError):\n            # Some platforms may raise ENOTCONN here\n            self.socket.shutdown(socket.SHUT_RDWR)\n    self.socket.close()\n    self.closed = True\n</code></pre>"},{"location":"api/socket/#academy.socket.SimpleSocket.send","title":"send","text":"<pre><code>send(message: bytes) -&gt; None\n</code></pre> <p>Send bytes to the socket.</p> Note <p>This is a noop if the message is empty.</p> <p>Parameters:</p> <ul> <li> <code>message</code>               (<code>bytes</code>)           \u2013            <p>Message to send.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>SocketClosedError</code>             \u2013            <p>if the socket was closed.</p> </li> <li> <code>OSError</code>             \u2013            <p>if an error occurred.</p> </li> </ul> Source code in <code>academy/socket.py</code> <pre><code>def send(self, message: bytes) -&gt; None:\n    \"\"\"Send bytes to the socket.\n\n    Note:\n        This is a noop if the message is empty.\n\n    Args:\n        message: Message to send.\n\n    Raises:\n        SocketClosedError: if the socket was closed.\n        OSError: if an error occurred.\n    \"\"\"\n    message_size = len(message)\n    if message_size == 0:\n        return\n    header = _make_header(message)\n    self._send_with_error_wrapping(header)\n\n    sent_size = 0\n    while sent_size &lt; message_size:\n        nbytes = min(message_size - sent_size, MESSAGE_CHUNK_SIZE)\n        chunk = message[sent_size : sent_size + nbytes]\n        self._send_with_error_wrapping(chunk)\n        sent_size += len(chunk)\n</code></pre>"},{"location":"api/socket/#academy.socket.SimpleSocket.send_string","title":"send_string","text":"<pre><code>send_string(message: str) -&gt; None\n</code></pre> <p>Send a string to the socket.</p> <p>Strings are encoded with UTF-8.</p> <p>Parameters:</p> <ul> <li> <code>message</code>               (<code>str</code>)           \u2013            <p>Message to send.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>SocketClosedError</code>             \u2013            <p>if the socket was closed.</p> </li> <li> <code>OSError</code>             \u2013            <p>if an error occurred.</p> </li> </ul> Source code in <code>academy/socket.py</code> <pre><code>def send_string(self, message: str) -&gt; None:\n    \"\"\"Send a string to the socket.\n\n    Strings are encoded with UTF-8.\n\n    Args:\n        message: Message to send.\n\n    Raises:\n        SocketClosedError: if the socket was closed.\n        OSError: if an error occurred.\n    \"\"\"\n    self.send(message.encode('utf-8'))\n</code></pre>"},{"location":"api/socket/#academy.socket.SimpleSocket.recv","title":"recv","text":"<pre><code>recv() -&gt; bytes | bytearray\n</code></pre> <p>Receive the next message from the socket.</p> <p>Returns:</p> <ul> <li> <code>bytes | bytearray</code>           \u2013            <p>Bytes containing the message.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>SocketClosedError</code>             \u2013            <p>if the socket was closed.</p> </li> <li> <code>OSError</code>             \u2013            <p>if an error occurred.</p> </li> </ul> Source code in <code>academy/socket.py</code> <pre><code>def recv(self) -&gt; bytes | bytearray:\n    \"\"\"Receive the next message from the socket.\n\n    Returns:\n        Bytes containing the message.\n\n    Raises:\n        SocketClosedError: if the socket was closed.\n        OSError: if an error occurred.\n    \"\"\"\n    header = _recv_from_socket(self.socket, MESSAGE_HEADER_SIZE)\n    message_size = _get_size_from_header(header)\n\n    buffer = bytearray(message_size)\n    received = 0\n    while received &lt; message_size:\n        nbytes = min(message_size - received, MESSAGE_CHUNK_SIZE)\n        chunk = _recv_from_socket(self.socket, nbytes)\n        # buffer.extend(chunk)\n        buffer[received : received + len(chunk)] = chunk\n        received += len(chunk)\n\n    return buffer\n</code></pre>"},{"location":"api/socket/#academy.socket.SimpleSocket.recv_string","title":"recv_string","text":"<pre><code>recv_string() -&gt; str\n</code></pre> <p>Receive the next message from the socket.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>Message decoded as a UTF-8 string.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>SocketClosedError</code>             \u2013            <p>if the socket was closed.</p> </li> <li> <code>OSError</code>             \u2013            <p>if an error occurred.</p> </li> </ul> Source code in <code>academy/socket.py</code> <pre><code>def recv_string(self) -&gt; str:\n    \"\"\"Receive the next message from the socket.\n\n    Returns:\n        Message decoded as a UTF-8 string.\n\n    Raises:\n        SocketClosedError: if the socket was closed.\n        OSError: if an error occurred.\n    \"\"\"\n    return self.recv().decode('utf-8')\n</code></pre>"},{"location":"api/socket/#academy.socket.SimpleSocketServer","title":"SimpleSocketServer","text":"<pre><code>SimpleSocketServer(\n    handler: Callable[[bytes], bytes | None],\n    *,\n    host: str = \"0.0.0.0\",\n    port: int | None = None,\n    timeout: float | None = 5\n)\n</code></pre> <p>Simple asyncio TCP socket server.</p> <p>Parameters:</p> <ul> <li> <code>handler</code>               (<code>Callable[[bytes], bytes | None]</code>)           \u2013            <p>Callback that handles a message and returns the response string. The handler is called synchronously within the client handler so it should not perform any heavy/blocking operations.</p> </li> <li> <code>host</code>               (<code>str</code>, default:                   <code>'0.0.0.0'</code> )           \u2013            <p>Host to bind to.</p> </li> <li> <code>port</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Port to bind to. If <code>None</code>, a random port is bound to.</p> </li> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>5</code> )           \u2013            <p>Seconds to wait for the server to startup and shutdown.</p> </li> </ul> Source code in <code>academy/socket.py</code> <pre><code>def __init__(\n    self,\n    handler: Callable[[bytes], bytes | None],\n    *,\n    host: str = '0.0.0.0',\n    port: int | None = None,\n    timeout: float | None = 5,\n) -&gt; None:\n    self.host = host\n    self.port = port if port is not None else open_port()\n    self.handler = handler\n    self.timeout = timeout\n    self._started = threading.Event()\n    self._signal_stop: asyncio.Future[None] | None = None\n    self._loop: asyncio.AbstractEventLoop | None = None\n    self._thread: threading.Thread | None = None\n    self._lock = threading.Lock()\n    self._client_tasks: set[asyncio.Task[None]] = set()\n</code></pre>"},{"location":"api/socket/#academy.socket.SimpleSocketServer.serve_forever","title":"serve_forever  <code>async</code>","text":"<pre><code>serve_forever(stop: Future[None]) -&gt; None\n</code></pre> <p>Accept and handles connections forever.</p> <p>Parameters:</p> <ul> <li> <code>stop</code>               (<code>Future[None]</code>)           \u2013            <p>An asyncio future that this method blocks on. Can be used to signal externally that the coroutine should exit.</p> </li> </ul> Source code in <code>academy/socket.py</code> <pre><code>async def serve_forever(self, stop: asyncio.Future[None]) -&gt; None:\n    \"\"\"Accept and handles connections forever.\n\n    Args:\n        stop: An asyncio future that this method blocks on. Can be used\n            to signal externally that the coroutine should exit.\n    \"\"\"\n    self._signal_stop = stop\n    server = await asyncio.start_server(\n        self._register_client_task,\n        host=self.host,\n        port=self.port,\n    )\n    logger.debug('TCP server listening at %s:%s', self.host, self.port)\n    self._started.set()\n\n    async with server:\n        await server.start_serving()\n        await self._signal_stop\n\n        for task in tuple(self._client_tasks):\n            task.cancel('Server has been closed.')\n            with contextlib.suppress(asyncio.CancelledError):\n                await task\n\n    if sys.version_info &gt;= (3, 13):  # pragma: &gt;=3.13 cover\n        server.close_clients()\n    self._started.clear()\n    logger.debug('TCP server finished at %s:%s', self.host, self.port)\n</code></pre>"},{"location":"api/socket/#academy.socket.SimpleSocketServer.start_server_thread","title":"start_server_thread","text":"<pre><code>start_server_thread() -&gt; None\n</code></pre> <p>Start the server in a new thread.</p> Source code in <code>academy/socket.py</code> <pre><code>def start_server_thread(self) -&gt; None:\n    \"\"\"Start the server in a new thread.\"\"\"\n    with self._lock:\n        loop = asyncio.new_event_loop()\n        stop = loop.create_future()\n\n        def _target() -&gt; None:\n            asyncio.set_event_loop(loop)\n            loop.run_until_complete(self.serve_forever(stop))\n            loop.close()\n\n        self._loop = loop\n        self._thread = threading.Thread(\n            target=_target,\n            name='socket-server',\n        )\n        self._thread.start()\n        self._started.wait(self.timeout)\n</code></pre>"},{"location":"api/socket/#academy.socket.SimpleSocketServer.stop_server_thread","title":"stop_server_thread","text":"<pre><code>stop_server_thread() -&gt; None\n</code></pre> <p>Stop the server thread.</p> Source code in <code>academy/socket.py</code> <pre><code>def stop_server_thread(self) -&gt; None:\n    \"\"\"Stop the server thread.\"\"\"\n    with self._lock:\n        if self._loop is None or self._thread is None:\n            return\n        assert self._signal_stop is not None\n        self._loop.call_soon_threadsafe(self._signal_stop.set_result, None)\n        self._thread.join(timeout=self.timeout)\n        if self._thread.is_alive():  # pragma: no cover\n            raise TimeoutError(\n                'Server thread did not gracefully exit '\n                f'within {self.timeout}s.',\n            )\n        self._loop = None\n        self._thread = None\n</code></pre>"},{"location":"api/socket/#academy.socket.address_by_hostname","title":"address_by_hostname","text":"<pre><code>address_by_hostname() -&gt; str\n</code></pre> <p>Get the IP address from the hostname of the local host.</p> Source code in <code>academy/socket.py</code> <pre><code>def address_by_hostname() -&gt; str:\n    \"\"\"Get the IP address from the hostname of the local host.\"\"\"\n    return socket.gethostbyname(platform.node())\n</code></pre>"},{"location":"api/socket/#academy.socket.address_by_interface","title":"address_by_interface","text":"<pre><code>address_by_interface(ifname: str) -&gt; str\n</code></pre> <p>Get the IP address of the given interface.</p> <p>Source: https://stackoverflow.com/questions/24196932/how-can-i-get-the-ip-address-of-eth0-in-python#24196955</p> <p>Parameters:</p> <ul> <li> <code>ifname</code>               (<code>str</code>)           \u2013            <p>Name of the interface whose address is to be returned.</p> </li> </ul> Source code in <code>academy/socket.py</code> <pre><code>def address_by_interface(ifname: str) -&gt; str:  # pragma: darwin no cover\n    \"\"\"Get the IP address of the given interface.\n\n    Source: https://stackoverflow.com/questions/24196932/how-can-i-get-the-ip-address-of-eth0-in-python#24196955\n\n    Args:\n        ifname: Name of the interface whose address is to be returned.\n    \"\"\"\n    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    return socket.inet_ntoa(\n        fcntl.ioctl(\n            s.fileno(),\n            0x8915,  # SIOCGIFADDR\n            struct.pack('256s', bytes(ifname[:15], 'utf-8')),\n        )[20:24],\n    )\n</code></pre>"},{"location":"api/socket/#academy.socket.open_port","title":"open_port","text":"<pre><code>open_port() -&gt; int\n</code></pre> <p>Return open port.</p> <p>Source: https://stackoverflow.com/questions/2838244</p> Source code in <code>academy/socket.py</code> <pre><code>def open_port() -&gt; int:\n    \"\"\"Return open port.\n\n    Source: https://stackoverflow.com/questions/2838244\n    \"\"\"\n    while True:\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        s.bind(('', 0))\n        s.listen(1)\n        port = s.getsockname()[1]\n        s.close()\n        if port not in _used_ports:  # pragma: no branch\n            _used_ports.add(port)\n            return port\n</code></pre>"},{"location":"api/socket/#academy.socket.wait_connection","title":"wait_connection","text":"<pre><code>wait_connection(\n    host: str,\n    port: int,\n    *,\n    sleep: float = 0.01,\n    timeout: float | None = None\n) -&gt; None\n</code></pre> <p>Wait for a socket connection to be established.</p> <p>Repeatedly tries to open and close a socket connection to <code>host:port</code>. If successful, the function returns. If unsuccessful before the timeout, a <code>TimeoutError</code> is raised. The function will sleep for <code>sleep</code> seconds in between successive connection attempts.</p> <p>Parameters:</p> <ul> <li> <code>host</code>               (<code>str</code>)           \u2013            <p>Host address to connect to.</p> </li> <li> <code>port</code>               (<code>int</code>)           \u2013            <p>Host port to connect to.</p> </li> <li> <code>sleep</code>               (<code>float</code>, default:                   <code>0.01</code> )           \u2013            <p>Seconds to sleep after unsuccessful connections.</p> </li> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Maximum number of seconds to wait for successful connections.</p> </li> </ul> Source code in <code>academy/socket.py</code> <pre><code>def wait_connection(\n    host: str,\n    port: int,\n    *,\n    sleep: float = 0.01,\n    timeout: float | None = None,\n) -&gt; None:\n    \"\"\"Wait for a socket connection to be established.\n\n    Repeatedly tries to open and close a socket connection to `host:port`.\n    If successful, the function returns. If unsuccessful before the timeout,\n    a `TimeoutError` is raised. The function will sleep for `sleep` seconds\n    in between successive connection attempts.\n\n    Args:\n        host: Host address to connect to.\n        port: Host port to connect to.\n        sleep: Seconds to sleep after unsuccessful connections.\n        timeout: Maximum number of seconds to wait for successful connections.\n    \"\"\"\n    sleep = min(sleep, timeout) if timeout is not None else sleep\n    waited = 0.0\n\n    while True:\n        try:\n            start = time.perf_counter()\n            with socket.create_connection((host, port), timeout=timeout):\n                break\n        except OSError as e:\n            connection_time = time.perf_counter() - start\n            waited += connection_time\n            if timeout is not None and waited &gt;= timeout:\n                raise TimeoutError from e\n            time.sleep(sleep)\n            waited += sleep\n</code></pre>"},{"location":"api/state/","title":"academy.state","text":"<code>academy/state.py</code>"},{"location":"api/state/#academy.state.FileState","title":"FileState","text":"<pre><code>FileState(\n    filename: str | Path,\n    *,\n    flag: Literal[\"r\", \"w\", \"c\", \"n\"] = \"c\",\n    protocol: int | None = DEFAULT_PICKLE_PROTOCOL,\n    writeback: bool = False\n)\n</code></pre> <p>               Bases: <code>DbfilenameShelf[ValueT]</code></p> <p>Dictionary interface for persistent state.</p> <p>Persists arbitrary Python objects to disk using pickle and a dbm database.</p> Note <p>This class uses the shelve module so refer there for additional caveats.</p> Example <pre><code>from typing import Any\nfrom academy.behavior import Behavior, action\nfrom academy.state import FileState\n\nclass Example(Behavior):\n    def __init__(self) -&gt; None:\n        self.state_path = '/tmp/agent-state.dbm'\n\n    def on_setup(self) -&gt; None:\n        self.state: FileState[Any] = FileState(self.state_path)\n\n    def on_shutdown(self) -&gt; None:\n        self.state.close()\n\n    @action\n    def get_state(self, key: str) -&gt; Any:\n        return self.state[key]\n\n    @action\n    def modify_state(self, key: str, value: Any) -&gt; None:\n        self.state[key] = value\n</code></pre> <p>Parameters:</p> <ul> <li> <code>filename</code>               (<code>str | Path</code>)           \u2013            <p>Base filename for the underlying databased used to store key-value pairs.</p> </li> <li> <code>flag</code>               (<code>Literal['r', 'w', 'c', 'n']</code>, default:                   <code>'c'</code> )           \u2013            <p>Open an existing database read-only: <code>r</code>; open an existing database for read and write: <code>w</code>; open a database for read and write, creating it if not existent: <code>c</code> (default); always create a new empty database for read and write: <code>n</code>.</p> </li> <li> <code>protocol</code>               (<code>int | None</code>, default:                   <code>DEFAULT_PICKLE_PROTOCOL</code> )           \u2013            <p>Pickling protocol. Defaults to version 5; <code>None</code> uses the pickle default version.</p> </li> <li> <code>writeback</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>By default (<code>False</code>), modified objects are only written when assigned. If <code>True</code>, the object will hold a cache of all entries accessed and write them back to the dict at sync and close times. This allows natural operations on mutable entries, but can consume much more memory and make sync and close take a long time.</p> </li> </ul> Source code in <code>academy/state.py</code> <pre><code>def __init__(\n    self,\n    filename: str | pathlib.Path,\n    *,\n    flag: Literal['r', 'w', 'c', 'n'] = 'c',\n    protocol: int | None = DEFAULT_PICKLE_PROTOCOL,\n    writeback: bool = False,\n) -&gt; None:\n    super().__init__(\n        str(filename),\n        flag=flag,\n        protocol=protocol,\n        writeback=writeback,\n    )\n</code></pre>"},{"location":"api/exchange/","title":"academy.exchange","text":"<code>academy/exchange/__init__.py</code>"},{"location":"api/exchange/#academy.exchange.ExchangeFactory","title":"ExchangeFactory","text":"<p>               Bases: <code>ABC</code></p> <p>Message exchange client protocol.</p> <p>A message exchange hosts mailboxes for each entity (i.e., agent or client) in a multi-agent system. With <code>ExchangeClient</code>, This protocol defines the client interface to an arbitrary exchange. An unbound exchange is used to attach to an existing mailbox or create a new mailbox. No messages or commands can be sent till a client is bound to a mailbox.</p> Warning <p>ExchangeFactory implementations should be efficiently pickleable so that agents and remote clients can establish client connections to the same exchange.</p>"},{"location":"api/exchange/#academy.exchange.ExchangeFactory.bind_as_client","title":"bind_as_client","text":"<pre><code>bind_as_client(\n    *, name: str | None = None, start_listener: bool = True\n) -&gt; ExchangeClient\n</code></pre> <p>Bind exchange to a new client mailbox.</p> <p>This method will create a new mailbox and enable this client to message other entities on the exchange.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Display name of the client on the exchange.</p> </li> <li> <code>start_listener</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Start a thread to receive messages and multiplex to handles.</p> </li> </ul> Source code in <code>academy/exchange/__init__.py</code> <pre><code>def bind_as_client(\n    self,\n    *,\n    name: str | None = None,\n    start_listener: bool = True,\n) -&gt; ExchangeClient:\n    \"\"\"Bind exchange to a new client mailbox.\n\n    This method will create a new mailbox and enable this client to\n    message other entities on the exchange.\n\n    Args:\n        name: Display name of the client on the exchange.\n        start_listener: Start a thread to receive messages and multiplex\n            to handles.\n    \"\"\"\n    return self._bind(\n        mailbox_id=None,\n        name=name,\n        handler=None,\n        start_listener=start_listener,\n    )\n</code></pre>"},{"location":"api/exchange/#academy.exchange.ExchangeFactory.bind_as_agent","title":"bind_as_agent","text":"<pre><code>bind_as_agent(\n    agent_id: AgentId[Any],\n    *,\n    name: str | None = None,\n    handler: Callable[[RequestMessage], None] | None = None\n) -&gt; ExchangeClient\n</code></pre> <p>Bind exchange to an agent mailbox.</p> <p>This method creates a exchange client bound to an agent ID. The agent ID must be previously created on the exchange.</p> <p>Parameters:</p> <ul> <li> <code>agent_id</code>               (<code>AgentId[Any]</code>)           \u2013            <p>ID of the mailbox to receive and send messages.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Display name of the client on the exchange.</p> </li> <li> <code>handler</code>               (<code>Callable[[RequestMessage], None] | None</code>, default:                   <code>None</code> )           \u2013            <p>Agent callback to process messages.</p> </li> </ul> Source code in <code>academy/exchange/__init__.py</code> <pre><code>def bind_as_agent(\n    self,\n    agent_id: AgentId[Any],\n    *,\n    name: str | None = None,\n    handler: Callable[[RequestMessage], None] | None = None,\n) -&gt; ExchangeClient:\n    \"\"\"Bind exchange to an agent mailbox.\n\n    This method creates a exchange client bound to an agent ID.\n    The agent ID must be previously created on the exchange.\n\n    Args:\n        agent_id: ID of the mailbox to receive and send messages.\n        name: Display name of the client on the exchange.\n        handler: Agent callback to process messages.\n    \"\"\"\n    return self._bind(\n        mailbox_id=agent_id,\n        name=name,\n        handler=handler,\n        start_listener=False,\n    )\n</code></pre>"},{"location":"api/exchange/#academy.exchange.ExchangeClient","title":"ExchangeClient","text":"<pre><code>ExchangeClient(\n    mailbox_id: EntityId | None,\n    *,\n    name: str | None,\n    handler: Callable[[RequestMessage], None] | None,\n    start_listener: bool\n)\n</code></pre> <p>               Bases: <code>ABC</code></p> <p>Message exchange client protocol.</p> <p>A message exchange hosts mailboxes for each entity (i.e., agent or client) in a multi-agent system. With <code>ExchangeFactory</code>, This protocol defines the client interface to an arbitrary exchange.</p> Note <p>When implementing this class super().init should likely be the last method called in the initializer. It relies on  \"self._register_client\" or \"self.status\".</p> Warning <p>A <code>ExchangeClient</code> should not be replicated. Multiple clients listening to the same mailbox will lead to undefined behavior depending on the implementation of the exchange. Instead, clients should be bound to a new mailbox to be replicated.</p> <p>Parameters:</p> <ul> <li> <code>mailbox_id</code>               (<code>EntityId | None</code>)           \u2013            <p>Identifier of the mailbox on the exchange. If there is not an id provided, the exchange will create a new client mailbox.</p> </li> <li> <code>name</code>               (<code>str | None</code>)           \u2013            <p>Display name of mailbox on exchange.</p> </li> <li> <code>handler</code>               (<code>Callable[[RequestMessage], None] | None</code>)           \u2013            <p>Callback to handler requests to this exchange.</p> </li> </ul> Source code in <code>academy/exchange/__init__.py</code> <pre><code>def __init__(\n    self,\n    mailbox_id: EntityId | None,\n    *,\n    name: str | None,\n    handler: Callable[[RequestMessage], None] | None,\n    start_listener: bool,\n):\n    self.bound_handles: dict[uuid.UUID, BoundRemoteHandle[Any]] = {}\n    if mailbox_id is None:\n        self.mailbox_id: EntityId = self._register_client(name=name)\n    else:\n        self.mailbox_id = mailbox_id\n        if self.status(mailbox_id) != MailboxStatus.ACTIVE:\n            raise BadEntityIdError(mailbox_id)\n\n    self.request_handler = handler\n\n    self.listener_started = start_listener\n    if start_listener:\n        self._listener_thread = threading.Thread(\n            target=self.listen,\n            name=f'exchange-{self.mailbox_id.uid}-listener',\n        )\n        self._listener_thread.start()\n</code></pre>"},{"location":"api/exchange/#academy.exchange.ExchangeClient.status","title":"status  <code>abstractmethod</code>","text":"<pre><code>status(mailbox_id: EntityId) -&gt; MailboxStatus\n</code></pre> <p>Check status of a mailbox in the exchange.</p> Source code in <code>academy/exchange/__init__.py</code> <pre><code>@abc.abstractmethod\ndef status(self, mailbox_id: EntityId) -&gt; MailboxStatus:\n    \"\"\"Check status of a mailbox in the exchange.\"\"\"\n    ...\n</code></pre>"},{"location":"api/exchange/#academy.exchange.ExchangeClient.register_agent","title":"register_agent  <code>abstractmethod</code>","text":"<pre><code>register_agent(\n    behavior: type[BehaviorT],\n    *,\n    agent_id: AgentId[BehaviorT] | None = None,\n    name: str | None = None\n) -&gt; AgentId[BehaviorT]\n</code></pre> <p>Create a new agent identifier and associated mailbox.</p> <p>Parameters:</p> <ul> <li> <code>behavior</code>               (<code>type[BehaviorT]</code>)           \u2013            <p>Behavior type of the agent.</p> </li> <li> <code>agent_id</code>               (<code>AgentId[BehaviorT] | None</code>, default:                   <code>None</code> )           \u2013            <p>Specify the ID of the agent. Randomly generated default.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional human-readable name for the agent. Ignored if <code>agent_id</code> is provided.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AgentId[BehaviorT]</code>           \u2013            <p>Unique identifier for the agent's mailbox.</p> </li> </ul> Source code in <code>academy/exchange/__init__.py</code> <pre><code>@abc.abstractmethod\ndef register_agent(\n    self,\n    behavior: type[BehaviorT],\n    *,\n    agent_id: AgentId[BehaviorT] | None = None,\n    name: str | None = None,\n) -&gt; AgentId[BehaviorT]:\n    \"\"\"Create a new agent identifier and associated mailbox.\n\n    Args:\n        behavior: Behavior type of the agent.\n        agent_id: Specify the ID of the agent. Randomly generated default.\n        name: Optional human-readable name for the agent. Ignored if\n            `agent_id` is provided.\n\n    Returns:\n        Unique identifier for the agent's mailbox.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/exchange/#academy.exchange.ExchangeClient.terminate","title":"terminate  <code>abstractmethod</code>","text":"<pre><code>terminate(uid: EntityId) -&gt; None\n</code></pre> <p>Close the mailbox for an entity from the exchange.</p> Note <p>This method is a no-op if the mailbox does not exist.</p> <p>Parameters:</p> <ul> <li> <code>uid</code>               (<code>EntityId</code>)           \u2013            <p>Entity identifier of the mailbox to close.</p> </li> </ul> Source code in <code>academy/exchange/__init__.py</code> <pre><code>@abc.abstractmethod\ndef terminate(self, uid: EntityId) -&gt; None:\n    \"\"\"Close the mailbox for an entity from the exchange.\n\n    Note:\n        This method is a no-op if the mailbox does not exist.\n\n    Args:\n        uid: Entity identifier of the mailbox to close.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/exchange/#academy.exchange.ExchangeClient.discover","title":"discover  <code>abstractmethod</code>","text":"<pre><code>discover(\n    behavior: type[Behavior],\n    *,\n    allow_subclasses: bool = True\n) -&gt; tuple[AgentId[Any], ...]\n</code></pre> <p>Discover peer agents with a given behavior.</p> <p>Parameters:</p> <ul> <li> <code>behavior</code>               (<code>type[Behavior]</code>)           \u2013            <p>Behavior type of interest.</p> </li> <li> <code>allow_subclasses</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Return agents implementing subclasses of the behavior.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[AgentId[Any], ...]</code>           \u2013            <p>Tuple of agent IDs implementing the behavior.</p> </li> </ul> Source code in <code>academy/exchange/__init__.py</code> <pre><code>@abc.abstractmethod\ndef discover(\n    self,\n    behavior: type[Behavior],\n    *,\n    allow_subclasses: bool = True,\n) -&gt; tuple[AgentId[Any], ...]:\n    \"\"\"Discover peer agents with a given behavior.\n\n    Args:\n        behavior: Behavior type of interest.\n        allow_subclasses: Return agents implementing subclasses of the\n            behavior.\n\n    Returns:\n        Tuple of agent IDs implementing the behavior.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/exchange/#academy.exchange.ExchangeClient.send","title":"send  <code>abstractmethod</code>","text":"<pre><code>send(uid: EntityId, message: Message) -&gt; None\n</code></pre> <p>Send a message to a mailbox.</p> <p>Parameters:</p> <ul> <li> <code>uid</code>               (<code>EntityId</code>)           \u2013            <p>Destination address of the message.</p> </li> <li> <code>message</code>               (<code>Message</code>)           \u2013            <p>Message to send.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BadEntityIdError</code>             \u2013            <p>if a mailbox for <code>uid</code> does not exist.</p> </li> <li> <code>MailboxClosedError</code>             \u2013            <p>if the mailbox was closed.</p> </li> </ul> Source code in <code>academy/exchange/__init__.py</code> <pre><code>@abc.abstractmethod\ndef send(self, uid: EntityId, message: Message) -&gt; None:\n    \"\"\"Send a message to a mailbox.\n\n    Args:\n        uid: Destination address of the message.\n        message: Message to send.\n\n    Raises:\n        BadEntityIdError: if a mailbox for `uid` does not exist.\n        MailboxClosedError: if the mailbox was closed.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/exchange/#academy.exchange.ExchangeClient.recv","title":"recv  <code>abstractmethod</code>","text":"<pre><code>recv(timeout: float | None = None) -&gt; Message\n</code></pre> <p>Receive the next message in the mailbox.</p> <p>This blocks until the next message is received or the mailbox is closed.</p> <p>Parameters:</p> <ul> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional timeout in seconds to wait for the next message. If <code>None</code>, the default, block forever until the next message or the mailbox is closed.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>MailboxClosedError</code>             \u2013            <p>if the mailbox was closed.</p> </li> <li> <code>TimeoutError</code>             \u2013            <p>if a <code>timeout</code> was specified and exceeded.</p> </li> </ul> Source code in <code>academy/exchange/__init__.py</code> <pre><code>@abc.abstractmethod\ndef recv(self, timeout: float | None = None) -&gt; Message:\n    \"\"\"Receive the next message in the mailbox.\n\n    This blocks until the next message is received or the mailbox\n    is closed.\n\n    Args:\n        timeout: Optional timeout in seconds to wait for the next\n            message. If `None`, the default, block forever until the\n            next message or the mailbox is closed.\n\n    Raises:\n        MailboxClosedError: if the mailbox was closed.\n        TimeoutError: if a `timeout` was specified and exceeded.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/exchange/#academy.exchange.ExchangeClient.close","title":"close  <code>abstractmethod</code>","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the exchange client.</p> <p>Stop listening for incoming messages. This should be called before concrete close actions to avoid errors on the listener thread.</p> Warning <p>This does not alter the state of the mailbox in the exchange for agent mailboxes. I.e., the exchange will still accept new messages to this mailbox, but this client will no longer be listening for them.</p> Source code in <code>academy/exchange/__init__.py</code> <pre><code>@abc.abstractmethod\ndef close(self) -&gt; None:\n    \"\"\"Close the exchange client.\n\n    Stop listening for incoming messages. This should be called before\n    concrete close actions to avoid errors on the listener thread.\n\n    Warning:\n        This does not alter the state of the mailbox in the exchange for\n        agent mailboxes. I.e., the exchange will still accept new messages\n        to this mailbox, but this client will no longer be listening for\n        them.\n    \"\"\"\n    if isinstance(self.mailbox_id, ClientId):\n        self.terminate(self.mailbox_id)\n        logger.debug(f'Terminated client mailbox {self.mailbox_id}')\n\n    if self.listener_started:\n        self._listener_thread.join()\n</code></pre>"},{"location":"api/exchange/#academy.exchange.ExchangeClient.clone","title":"clone  <code>abstractmethod</code>","text":"<pre><code>clone() -&gt; ExchangeFactory\n</code></pre> <p>Shallow copy exchange to new, unbound version.</p> Source code in <code>academy/exchange/__init__.py</code> <pre><code>@abc.abstractmethod\ndef clone(self) -&gt; ExchangeFactory:\n    \"\"\"Shallow copy exchange to new, unbound version.\"\"\"\n    ...\n</code></pre>"},{"location":"api/exchange/#academy.exchange.ExchangeClient.get_handle","title":"get_handle","text":"<pre><code>get_handle(\n    aid: AgentId[BehaviorT],\n) -&gt; BoundRemoteHandle[BehaviorT]\n</code></pre> <p>Create a new handle to an agent.</p> <p>A handle enables a client to invoke actions on the agent.</p> Note <p>It is not possible to create a handle to a client since a handle is essentially a new client of a specific agent.</p> <p>Parameters:</p> <ul> <li> <code>aid</code>               (<code>AgentId[BehaviorT]</code>)           \u2013            <p>EntityId of the agent to create an handle to.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>BoundRemoteHandle[BehaviorT]</code>           \u2013            <p>Handle to the agent.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>if <code>aid</code> is not an instance of <code>AgentId</code>.</p> </li> </ul> Source code in <code>academy/exchange/__init__.py</code> <pre><code>def get_handle(\n    self,\n    aid: AgentId[BehaviorT],\n) -&gt; BoundRemoteHandle[BehaviorT]:\n    \"\"\"Create a new handle to an agent.\n\n    A handle enables a client to invoke actions on the agent.\n\n    Note:\n        It is not possible to create a handle to a client since a handle\n        is essentially a new client of a specific agent.\n\n    Args:\n        aid: EntityId of the agent to create an handle to.\n\n    Returns:\n        Handle to the agent.\n\n    Raises:\n        TypeError: if `aid` is not an instance of\n            [`AgentId`][academy.identifier.AgentId].\n    \"\"\"\n    if not isinstance(aid, AgentId):\n        raise TypeError(\n            f'Handle must be created from an {AgentId.__name__} '\n            f'but got identifier with type {type(aid).__name__}.',\n        )\n\n    hdl = BoundRemoteHandle(self, aid, self.mailbox_id)\n    self.bound_handles[hdl.handle_id] = hdl\n    return hdl\n</code></pre>"},{"location":"api/exchange/#academy.exchange.ExchangeClient.close_bound_handles","title":"close_bound_handles","text":"<pre><code>close_bound_handles() -&gt; None\n</code></pre> <p>Close all handles bound to this mailbox.</p> Source code in <code>academy/exchange/__init__.py</code> <pre><code>def close_bound_handles(self) -&gt; None:\n    \"\"\"Close all handles bound to this mailbox.\"\"\"\n    for key in tuple(self.bound_handles):\n        handle = self.bound_handles.pop(key)\n        handle.close(wait_futures=False)\n</code></pre>"},{"location":"api/exchange/#academy.exchange.ExchangeClient.listen","title":"listen","text":"<pre><code>listen() -&gt; None\n</code></pre> <p>Listen for new messages in the mailbox and process them.</p> <p>Request messages are processed via the <code>request_handler</code>, and response messages are dispatched to the handle that created the corresponding request.</p> Warning <p>This method loops forever, until the mailbox is closed. Thus this method is typically run inside of a thread.</p> Note <p>Response messages intended for a handle that does not exist will be logged and discarded.</p> Source code in <code>academy/exchange/__init__.py</code> <pre><code>def listen(self) -&gt; None:\n    \"\"\"Listen for new messages in the mailbox and process them.\n\n    Request messages are processed via the `request_handler`, and response\n    messages are dispatched to the handle that created the corresponding\n    request.\n\n    Warning:\n        This method loops forever, until the mailbox is closed. Thus this\n        method is typically run inside of a thread.\n\n    Note:\n        Response messages intended for a handle that does not exist\n        will be logged and discarded.\n    \"\"\"\n    try:\n        while True:\n            message = self.recv()\n            self._message_handler(message)\n    except MailboxClosedError:\n        pass\n</code></pre>"},{"location":"api/exchange/hybrid/","title":"academy.exchange.hybrid","text":"<code>academy/exchange/hybrid.py</code>"},{"location":"api/exchange/hybrid/#academy.exchange.hybrid.HybridExchangeFactory","title":"HybridExchangeFactory","text":"<pre><code>HybridExchangeFactory(\n    redis_host: str,\n    redis_port: int,\n    *,\n    interface: str | None = None,\n    namespace: str | None = \"default\",\n    redis_kwargs: dict[str, Any] | None = None,\n    ports: Iterable[int] | None = None\n)\n</code></pre> <p>               Bases: <code>ExchangeFactory</code></p> <p>Hybrid exchange.</p> <p>The hybrid exchange uses peer-to-peer communication via TCP and a central Redis server for mailbox state and queueing messages for offline entities.</p> <p>Parameters:</p> <ul> <li> <code>redis_host</code>               (<code>str</code>)           \u2013            <p>Redis server hostname.</p> </li> <li> <code>redis_port</code>               (<code>int</code>)           \u2013            <p>Redis server port.</p> </li> <li> <code>interface</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Network interface use for peer-to-peer communication. If <code>None</code>, the hostname of the local host is used.</p> </li> <li> <code>namespace</code>               (<code>str | None</code>, default:                   <code>'default'</code> )           \u2013            <p>Redis key namespace. If <code>None</code> a random key prefix is generated.</p> </li> <li> <code>redis_kwargs</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Extra keyword arguments to pass to <code>redis.Redis()</code>.</p> </li> <li> <code>ports</code>               (<code>Iterable[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>An iterable of ports to give each client a unique port from a user defined set. A StopIteration exception will be raised in bind_* methods if the number of clients in the process is greater than the length of the iterable.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ConnectionError</code>             \u2013            <p>If the Redis server is not reachable.</p> </li> </ul> Source code in <code>academy/exchange/hybrid.py</code> <pre><code>def __init__(  # noqa: PLR0913\n    self,\n    redis_host: str,\n    redis_port: int,\n    *,\n    interface: str | None = None,\n    namespace: str | None = 'default',\n    redis_kwargs: dict[str, Any] | None = None,\n    ports: Iterable[int] | None = None,\n) -&gt; None:\n    self._namespace = (\n        namespace\n        if namespace is not None\n        else uuid_to_base32(uuid.uuid4())\n    )\n    self._interface = interface\n    self._redis_host = redis_host\n    self._redis_port = redis_port\n    self._redis_kwargs = redis_kwargs if redis_kwargs is not None else {}\n    self._ports = None if ports is None else iter(ports)\n</code></pre>"},{"location":"api/exchange/hybrid/#academy.exchange.hybrid.HybridExchangeFactory.bind_as_client","title":"bind_as_client","text":"<pre><code>bind_as_client(\n    *, name: str | None = None, start_listener: bool = True\n) -&gt; ExchangeClient\n</code></pre> <p>Bind exchange to a new client mailbox.</p> <p>This method will create a new mailbox and enable this client to message other entities on the exchange.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Display name of the client on the exchange.</p> </li> <li> <code>start_listener</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Start a thread to receive messages and multiplex to handles.</p> </li> </ul> Source code in <code>academy/exchange/__init__.py</code> <pre><code>def bind_as_client(\n    self,\n    *,\n    name: str | None = None,\n    start_listener: bool = True,\n) -&gt; ExchangeClient:\n    \"\"\"Bind exchange to a new client mailbox.\n\n    This method will create a new mailbox and enable this client to\n    message other entities on the exchange.\n\n    Args:\n        name: Display name of the client on the exchange.\n        start_listener: Start a thread to receive messages and multiplex\n            to handles.\n    \"\"\"\n    return self._bind(\n        mailbox_id=None,\n        name=name,\n        handler=None,\n        start_listener=start_listener,\n    )\n</code></pre>"},{"location":"api/exchange/hybrid/#academy.exchange.hybrid.HybridExchangeFactory.bind_as_agent","title":"bind_as_agent","text":"<pre><code>bind_as_agent(\n    agent_id: AgentId[Any],\n    *,\n    name: str | None = None,\n    handler: Callable[[RequestMessage], None] | None = None\n) -&gt; ExchangeClient\n</code></pre> <p>Bind exchange to an agent mailbox.</p> <p>This method creates a exchange client bound to an agent ID. The agent ID must be previously created on the exchange.</p> <p>Parameters:</p> <ul> <li> <code>agent_id</code>               (<code>AgentId[Any]</code>)           \u2013            <p>ID of the mailbox to receive and send messages.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Display name of the client on the exchange.</p> </li> <li> <code>handler</code>               (<code>Callable[[RequestMessage], None] | None</code>, default:                   <code>None</code> )           \u2013            <p>Agent callback to process messages.</p> </li> </ul> Source code in <code>academy/exchange/__init__.py</code> <pre><code>def bind_as_agent(\n    self,\n    agent_id: AgentId[Any],\n    *,\n    name: str | None = None,\n    handler: Callable[[RequestMessage], None] | None = None,\n) -&gt; ExchangeClient:\n    \"\"\"Bind exchange to an agent mailbox.\n\n    This method creates a exchange client bound to an agent ID.\n    The agent ID must be previously created on the exchange.\n\n    Args:\n        agent_id: ID of the mailbox to receive and send messages.\n        name: Display name of the client on the exchange.\n        handler: Agent callback to process messages.\n    \"\"\"\n    return self._bind(\n        mailbox_id=agent_id,\n        name=name,\n        handler=handler,\n        start_listener=False,\n    )\n</code></pre>"},{"location":"api/exchange/hybrid/#academy.exchange.hybrid.HybridExchangeClient","title":"HybridExchangeClient","text":"<pre><code>HybridExchangeClient(\n    unbound: HybridExchangeFactory,\n    mailbox_id: EntityId | None = None,\n    *,\n    name: str | None = None,\n    handler: Callable[[RequestMessage], None] | None = None,\n    start_listener: bool,\n    port: int | None = None\n)\n</code></pre> <p>               Bases: <code>ExchangeClient</code></p> <p>Hybrid exchange.</p> <p>The hybrid exchange uses peer-to-peer communication via TCP and a central Redis server for mailbox state and queueing messages for offline entities.</p> <p>Parameters:</p> <ul> <li> <code>unbound</code>               (<code>HybridExchangeFactory</code>)           \u2013            <p>An unbound exchange client containing information to connect to the exchange.</p> </li> <li> <code>mailbox_id</code>               (<code>EntityId | None</code>, default:                   <code>None</code> )           \u2013            <p>Identifier of the mailbox on the exchange. If there is not an id provided, the exchange will create a new client mail- box.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Display name of mailbox on exchange.</p> </li> <li> <code>handler</code>               (<code>Callable[[RequestMessage], None] | None</code>, default:                   <code>None</code> )           \u2013            <p>Callback to handler requests to this exchange.</p> </li> <li> <code>start_listener</code>               (<code>bool</code>)           \u2013            <p>Start the listener thread to multiplex messages to handles.</p> </li> <li> <code>port</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>What port to listen for direct messages on. If none, assigned to any open port.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ConnectionError</code>             \u2013            <p>If the Redis server is not reachable.</p> </li> </ul> Source code in <code>academy/exchange/hybrid.py</code> <pre><code>def __init__(  # noqa: PLR0913\n    self,\n    unbound: HybridExchangeFactory,\n    mailbox_id: EntityId | None = None,\n    *,\n    name: str | None = None,\n    handler: Callable[[RequestMessage], None] | None = None,\n    start_listener: bool,\n    port: int | None = None,\n) -&gt; None:\n    self._namespace = unbound._namespace\n    self._interface = unbound._interface\n    self._redis_host = unbound._redis_host\n    self._redis_port = unbound._redis_port\n    self._redis_kwargs = unbound._redis_kwargs\n\n    # How can we pass the port through the bind method?\n    self._port = port\n\n    self._init_connections()\n    self._messages: Queue[Message] = Queue()\n\n    try:\n        super().__init__(\n            mailbox_id,\n            name=name,\n            handler=handler,\n            start_listener=start_listener,\n        )\n    except Exception as e:\n        self._redis_client.close()\n        self._socket_pool.close()\n        raise e\n\n    self._start_mailbox_server()\n</code></pre>"},{"location":"api/exchange/hybrid/#academy.exchange.hybrid.HybridExchangeClient.close","title":"close","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the exchange interface.</p> Source code in <code>academy/exchange/hybrid.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Close the exchange interface.\"\"\"\n    # This is necessary to get the listener thread to exit.\n    # This should be replaced in the async implementation\n    self._messages.close()\n\n    super().close()\n\n    self._close_mailbox_server()\n    self._redis_client.close()\n    self._socket_pool.close()\n    logger.debug('Closed exchange (%s)', self)\n</code></pre>"},{"location":"api/exchange/hybrid/#academy.exchange.hybrid.HybridExchangeClient.status","title":"status","text":"<pre><code>status(mailbox_id: EntityId) -&gt; MailboxStatus\n</code></pre> <p>Check status of mailbox on exchange.</p> Source code in <code>academy/exchange/hybrid.py</code> <pre><code>def status(self, mailbox_id: EntityId) -&gt; MailboxStatus:\n    \"\"\"Check status of mailbox on exchange.\"\"\"\n    status = self._redis_client.get(self._status_key(mailbox_id))\n    if status is None:\n        return MailboxStatus.MISSING\n    elif status == _MailboxState.INACTIVE.value:\n        return MailboxStatus.TERMINATED\n    else:\n        return MailboxStatus.ACTIVE\n</code></pre>"},{"location":"api/exchange/hybrid/#academy.exchange.hybrid.HybridExchangeClient.register_agent","title":"register_agent","text":"<pre><code>register_agent(\n    behavior: type[BehaviorT],\n    *,\n    agent_id: AgentId[BehaviorT] | None = None,\n    name: str | None = None\n) -&gt; AgentId[BehaviorT]\n</code></pre> <p>Create a new agent identifier and associated mailbox.</p> <p>Parameters:</p> <ul> <li> <code>behavior</code>               (<code>type[BehaviorT]</code>)           \u2013            <p>Type of the behavior this agent will implement.</p> </li> <li> <code>agent_id</code>               (<code>AgentId[BehaviorT] | None</code>, default:                   <code>None</code> )           \u2013            <p>Specify the ID of the agent. Randomly generated default.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional human-readable name for the agent. Ignored if <code>agent_id</code> is provided.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AgentId[BehaviorT]</code>           \u2013            <p>Unique identifier for the agent's mailbox.</p> </li> </ul> Source code in <code>academy/exchange/hybrid.py</code> <pre><code>def register_agent(\n    self,\n    behavior: type[BehaviorT],\n    *,\n    agent_id: AgentId[BehaviorT] | None = None,\n    name: str | None = None,\n) -&gt; AgentId[BehaviorT]:\n    \"\"\"Create a new agent identifier and associated mailbox.\n\n    Args:\n        behavior: Type of the behavior this agent will implement.\n        agent_id: Specify the ID of the agent. Randomly generated\n            default.\n        name: Optional human-readable name for the agent. Ignored if\n            `agent_id` is provided.\n\n    Returns:\n        Unique identifier for the agent's mailbox.\n    \"\"\"\n    aid = AgentId.new(name=name) if agent_id is None else agent_id\n    self._redis_client.set(\n        self._status_key(aid),\n        _MailboxState.ACTIVE.value,\n    )\n    self._redis_client.set(\n        self._behavior_key(aid),\n        ','.join(behavior.behavior_mro()),\n    )\n    logger.debug('Registered %s in %s', aid, self)\n    return aid\n</code></pre>"},{"location":"api/exchange/hybrid/#academy.exchange.hybrid.HybridExchangeClient.terminate","title":"terminate","text":"<pre><code>terminate(uid: EntityId) -&gt; None\n</code></pre> <p>Close the mailbox for an entity from the exchange.</p> <p>This sets the state of the mailbox to inactive in the Redis server, and deletes any queued messages in Redis.</p> <p>Parameters:</p> <ul> <li> <code>uid</code>               (<code>EntityId</code>)           \u2013            <p>Entity identifier of the mailbox to close.</p> </li> </ul> Source code in <code>academy/exchange/hybrid.py</code> <pre><code>def terminate(self, uid: EntityId) -&gt; None:\n    \"\"\"Close the mailbox for an entity from the exchange.\n\n    This sets the state of the mailbox to inactive in the Redis server,\n    and deletes any queued messages in Redis.\n\n    Args:\n        uid: Entity identifier of the mailbox to close.\n    \"\"\"\n    self._redis_client.set(\n        self._status_key(uid),\n        _MailboxState.INACTIVE.value,\n    )\n    # Sending a close sentinel to the queue is a quick way to force\n    # the entity waiting on messages to the mailbox to stop blocking.\n    # This assumes that only one entity is reading from the mailbox.\n    self._redis_client.rpush(self._queue_key(uid), _CLOSE_SENTINEL)\n    if isinstance(uid, AgentId):\n        self._redis_client.delete(self._behavior_key(uid))\n    logger.debug('Closed mailbox for %s (%s)', uid, self)\n</code></pre>"},{"location":"api/exchange/hybrid/#academy.exchange.hybrid.HybridExchangeClient.discover","title":"discover","text":"<pre><code>discover(\n    behavior: type[Behavior],\n    *,\n    allow_subclasses: bool = True\n) -&gt; tuple[AgentId[Any], ...]\n</code></pre> <p>Discover peer agents with a given behavior.</p> Warning <p>This method is O(n) and scans all keys in the Redis server.</p> <p>Parameters:</p> <ul> <li> <code>behavior</code>               (<code>type[Behavior]</code>)           \u2013            <p>Behavior type of interest.</p> </li> <li> <code>allow_subclasses</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Return agents implementing subclasses of the behavior.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[AgentId[Any], ...]</code>           \u2013            <p>Tuple of agent IDs implementing the behavior.</p> </li> </ul> Source code in <code>academy/exchange/hybrid.py</code> <pre><code>def discover(\n    self,\n    behavior: type[Behavior],\n    *,\n    allow_subclasses: bool = True,\n) -&gt; tuple[AgentId[Any], ...]:\n    \"\"\"Discover peer agents with a given behavior.\n\n    Warning:\n        This method is O(n) and scans all keys in the Redis server.\n\n    Args:\n        behavior: Behavior type of interest.\n        allow_subclasses: Return agents implementing subclasses of the\n            behavior.\n\n    Returns:\n        Tuple of agent IDs implementing the behavior.\n    \"\"\"\n    found: list[AgentId[Any]] = []\n    fqp = f'{behavior.__module__}.{behavior.__name__}'\n    for key in self._redis_client.scan_iter(\n        f'{self._namespace}:behavior:*',\n    ):\n        mro_str = self._redis_client.get(key)\n        assert isinstance(mro_str, str)\n        mro = mro_str.split(',')\n        if fqp == mro[0] or (allow_subclasses and fqp in mro):\n            aid: AgentId[Any] = AgentId(\n                uid=base32_to_uuid(key.split(':')[-1]),\n            )\n            found.append(aid)\n    active: list[AgentId[Any]] = []\n    for aid in found:\n        status = self._redis_client.get(self._status_key(aid))\n        if status == _MailboxState.ACTIVE.value:  # pragma: no branch\n            active.append(aid)\n    return tuple(active)\n</code></pre>"},{"location":"api/exchange/hybrid/#academy.exchange.hybrid.HybridExchangeClient.send","title":"send","text":"<pre><code>send(uid: EntityId, message: Message) -&gt; None\n</code></pre> <p>Send a message to a mailbox.</p> <p>To send a message, the client first checks that the state of the mailbox in Redis is active; otherwise, an error is raised. Then, the client checks to see if the peer entity is available by checking for an address of the peer in Redis. If the peer's address is found, the message is sent directly to the peer via ZMQ; otherwise, the message is put in a Redis queue for later retrieval.</p> <p>Parameters:</p> <ul> <li> <code>uid</code>               (<code>EntityId</code>)           \u2013            <p>Destination address of the message.</p> </li> <li> <code>message</code>               (<code>Message</code>)           \u2013            <p>Message to send.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BadEntityIdError</code>             \u2013            <p>if a mailbox for <code>uid</code> does not exist.</p> </li> <li> <code>MailboxClosedError</code>             \u2013            <p>if the mailbox was closed.</p> </li> </ul> Source code in <code>academy/exchange/hybrid.py</code> <pre><code>def send(self, uid: EntityId, message: Message) -&gt; None:\n    \"\"\"Send a message to a mailbox.\n\n    To send a message, the client first checks that the state of the\n    mailbox in Redis is active; otherwise, an error is raised. Then,\n    the client checks to see if the peer entity is available by\n    checking for an address of the peer in Redis. If the peer's address\n    is found, the message is sent directly to the peer via ZMQ; otherwise,\n    the message is put in a Redis queue for later retrieval.\n\n    Args:\n        uid: Destination address of the message.\n        message: Message to send.\n\n    Raises:\n        BadEntityIdError: if a mailbox for `uid` does not exist.\n        MailboxClosedError: if the mailbox was closed.\n    \"\"\"\n    address = self._address_cache.get(uid, None)\n    if address is not None:\n        try:\n            # This is as optimistic as possible. If the address of the\n            # peer is cached, we assume the mailbox is still active and\n            # the peer is still listening.\n            self._send_direct(address, message)\n        except (SocketClosedError, OSError):\n            # Our optimism let us down so clear the cache and try the\n            # standard flow.\n            self._address_cache.pop(uid)\n        else:\n            return\n\n    status = self._redis_client.get(self._status_key(uid))\n    if status is None:\n        raise BadEntityIdError(uid)\n    elif status == _MailboxState.INACTIVE.value:\n        raise MailboxClosedError(uid)\n\n    maybe_address = self._redis_client.get(self._address_key(uid))\n    try:\n        # This branching is a little odd. We want to fall back to\n        # Redis for message sending on two conditions: direct send fails\n        # or no address was found. We raise a TypeError if no address\n        # was found as a shortcut to get to the fall back.\n        if isinstance(maybe_address, (bytes, str)):\n            decoded_address = (\n                maybe_address.decode('utf-8')\n                if isinstance(maybe_address, bytes)\n                else maybe_address\n            )\n            self._send_direct(decoded_address, message)\n            self._address_cache[uid] = decoded_address\n        else:\n            raise TypeError('Did not active peer address in Redis.')\n    except (TypeError, SocketClosedError, OSError):\n        self._redis_client.rpush(\n            self._queue_key(uid),\n            message.model_serialize(),\n        )\n        logger.debug(\n            'Sent %s to %s via redis',\n            type(message).__name__,\n            uid,\n        )\n</code></pre>"},{"location":"api/exchange/hybrid/#academy.exchange.hybrid.HybridExchangeClient.recv","title":"recv","text":"<pre><code>recv(timeout: float | None = None) -&gt; Message\n</code></pre> <p>Receive the next message in the mailbox.</p> <p>This blocks until the next message is received or the mailbox is closed.</p> <p>Parameters:</p> <ul> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional timeout in seconds to wait for the next message. If <code>None</code>, the default, block forever until the next message or the mailbox is closed. Note that this will be cast to an int which is required by the Redis API.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>MailboxClosedError</code>             \u2013            <p>if the mailbox was closed.</p> </li> <li> <code>TimeoutError</code>             \u2013            <p>if a <code>timeout</code> was specified and exceeded.</p> </li> </ul> Source code in <code>academy/exchange/hybrid.py</code> <pre><code>def recv(self, timeout: float | None = None) -&gt; Message:\n    \"\"\"Receive the next message in the mailbox.\n\n    This blocks until the next message is received or the mailbox\n    is closed.\n\n    Args:\n        timeout: Optional timeout in seconds to wait for the next\n            message. If `None`, the default, block forever until the\n            next message or the mailbox is closed. Note that this will\n            be cast to an int which is required by the Redis API.\n\n    Raises:\n        MailboxClosedError: if the mailbox was closed.\n        TimeoutError: if a `timeout` was specified and exceeded.\n    \"\"\"\n    try:\n        logger.debug(\n            f'Getting message from queue for mailbox: {self.mailbox_id}',\n        )\n        return self._messages.get(timeout=timeout)\n    except QueueClosedError:\n        raise MailboxClosedError(self.mailbox_id) from None\n</code></pre>"},{"location":"api/exchange/hybrid/#academy.exchange.hybrid.HybridExchangeClient.clone","title":"clone","text":"<pre><code>clone() -&gt; HybridExchangeFactory\n</code></pre> <p>Shallow copy exchange to new, unbound version.</p> Source code in <code>academy/exchange/hybrid.py</code> <pre><code>def clone(self) -&gt; HybridExchangeFactory:\n    \"\"\"Shallow copy exchange to new, unbound version.\"\"\"\n    return HybridExchangeFactory(\n        self._redis_host,\n        self._redis_port,\n        interface=self._interface,\n        namespace=self._namespace,\n        redis_kwargs=self._redis_kwargs,\n    )\n</code></pre>"},{"location":"api/exchange/hybrid/#academy.exchange.hybrid.HybridExchangeClient.get_handle","title":"get_handle","text":"<pre><code>get_handle(\n    aid: AgentId[BehaviorT],\n) -&gt; BoundRemoteHandle[BehaviorT]\n</code></pre> <p>Create a new handle to an agent.</p> <p>A handle enables a client to invoke actions on the agent.</p> Note <p>It is not possible to create a handle to a client since a handle is essentially a new client of a specific agent.</p> <p>Parameters:</p> <ul> <li> <code>aid</code>               (<code>AgentId[BehaviorT]</code>)           \u2013            <p>EntityId of the agent to create an handle to.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>BoundRemoteHandle[BehaviorT]</code>           \u2013            <p>Handle to the agent.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>if <code>aid</code> is not an instance of <code>AgentId</code>.</p> </li> </ul> Source code in <code>academy/exchange/__init__.py</code> <pre><code>def get_handle(\n    self,\n    aid: AgentId[BehaviorT],\n) -&gt; BoundRemoteHandle[BehaviorT]:\n    \"\"\"Create a new handle to an agent.\n\n    A handle enables a client to invoke actions on the agent.\n\n    Note:\n        It is not possible to create a handle to a client since a handle\n        is essentially a new client of a specific agent.\n\n    Args:\n        aid: EntityId of the agent to create an handle to.\n\n    Returns:\n        Handle to the agent.\n\n    Raises:\n        TypeError: if `aid` is not an instance of\n            [`AgentId`][academy.identifier.AgentId].\n    \"\"\"\n    if not isinstance(aid, AgentId):\n        raise TypeError(\n            f'Handle must be created from an {AgentId.__name__} '\n            f'but got identifier with type {type(aid).__name__}.',\n        )\n\n    hdl = BoundRemoteHandle(self, aid, self.mailbox_id)\n    self.bound_handles[hdl.handle_id] = hdl\n    return hdl\n</code></pre>"},{"location":"api/exchange/hybrid/#academy.exchange.hybrid.HybridExchangeClient.close_bound_handles","title":"close_bound_handles","text":"<pre><code>close_bound_handles() -&gt; None\n</code></pre> <p>Close all handles bound to this mailbox.</p> Source code in <code>academy/exchange/__init__.py</code> <pre><code>def close_bound_handles(self) -&gt; None:\n    \"\"\"Close all handles bound to this mailbox.\"\"\"\n    for key in tuple(self.bound_handles):\n        handle = self.bound_handles.pop(key)\n        handle.close(wait_futures=False)\n</code></pre>"},{"location":"api/exchange/hybrid/#academy.exchange.hybrid.HybridExchangeClient.listen","title":"listen","text":"<pre><code>listen() -&gt; None\n</code></pre> <p>Listen for new messages in the mailbox and process them.</p> <p>Request messages are processed via the <code>request_handler</code>, and response messages are dispatched to the handle that created the corresponding request.</p> Warning <p>This method loops forever, until the mailbox is closed. Thus this method is typically run inside of a thread.</p> Note <p>Response messages intended for a handle that does not exist will be logged and discarded.</p> Source code in <code>academy/exchange/__init__.py</code> <pre><code>def listen(self) -&gt; None:\n    \"\"\"Listen for new messages in the mailbox and process them.\n\n    Request messages are processed via the `request_handler`, and response\n    messages are dispatched to the handle that created the corresponding\n    request.\n\n    Warning:\n        This method loops forever, until the mailbox is closed. Thus this\n        method is typically run inside of a thread.\n\n    Note:\n        Response messages intended for a handle that does not exist\n        will be logged and discarded.\n    \"\"\"\n    try:\n        while True:\n            message = self.recv()\n            self._message_handler(message)\n    except MailboxClosedError:\n        pass\n</code></pre>"},{"location":"api/exchange/hybrid/#academy.exchange.hybrid.base32_to_uuid","title":"base32_to_uuid","text":"<pre><code>base32_to_uuid(uid: str) -&gt; UUID\n</code></pre> <p>Parse a base32 string as a UUID.</p> Source code in <code>academy/exchange/hybrid.py</code> <pre><code>def base32_to_uuid(uid: str) -&gt; uuid.UUID:\n    \"\"\"Parse a base32 string as a UUID.\"\"\"\n    padding = '=' * ((8 - len(uid) % 8) % 8)\n    padded = uid + padding\n    uid_bytes = base64.b32decode(padded)\n    return uuid.UUID(bytes=uid_bytes)\n</code></pre>"},{"location":"api/exchange/hybrid/#academy.exchange.hybrid.uuid_to_base32","title":"uuid_to_base32","text":"<pre><code>uuid_to_base32(uid: UUID) -&gt; str\n</code></pre> <p>Encode a UUID as a trimmed base32 string.</p> Source code in <code>academy/exchange/hybrid.py</code> <pre><code>def uuid_to_base32(uid: uuid.UUID) -&gt; str:\n    \"\"\"Encode a UUID as a trimmed base32 string.\"\"\"\n    uid_bytes = uid.bytes\n    base32_bytes = base64.b32encode(uid_bytes).rstrip(b'=')\n    return base32_bytes.decode('utf-8')\n</code></pre>"},{"location":"api/exchange/proxystore/","title":"academy.exchange.proxystore","text":"<code>academy/exchange/proxystore.py</code>"},{"location":"api/exchange/proxystore/#academy.exchange.proxystore.ProxyStoreExchangeFactory","title":"ProxyStoreExchangeFactory","text":"<pre><code>ProxyStoreExchangeFactory(\n    exchange: ExchangeFactory,\n    store: Store[Any] | None,\n    should_proxy: Callable[[Any], bool],\n    *,\n    resolve_async: bool = False\n)\n</code></pre> <p>               Bases: <code>ExchangeFactory</code></p> <p>Proxystore exchange not bound to mailbox.</p> <p>A proxystore exchange is used to wrap an underlying exchange so large objects may be passed by reference.</p> Source code in <code>academy/exchange/proxystore.py</code> <pre><code>def __init__(\n    self,\n    exchange: ExchangeFactory,\n    store: Store[Any] | None,\n    should_proxy: Callable[[Any], bool],\n    *,\n    resolve_async: bool = False,\n) -&gt; None:\n    self.exchange = exchange\n    self.store = store\n    self.should_proxy = should_proxy\n    self.resolve_async = resolve_async\n</code></pre>"},{"location":"api/exchange/proxystore/#academy.exchange.proxystore.ProxyStoreExchangeFactory.bind_as_client","title":"bind_as_client","text":"<pre><code>bind_as_client(\n    *, name: str | None = None, start_listener: bool = True\n) -&gt; ExchangeClient\n</code></pre> <p>Bind exchange to a new client mailbox.</p> <p>This method will create a new mailbox and enable this client to message other entities on the exchange.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Display name of the client on the exchange.</p> </li> <li> <code>start_listener</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Start a thread to receive messages and multiplex to handles.</p> </li> </ul> Source code in <code>academy/exchange/__init__.py</code> <pre><code>def bind_as_client(\n    self,\n    *,\n    name: str | None = None,\n    start_listener: bool = True,\n) -&gt; ExchangeClient:\n    \"\"\"Bind exchange to a new client mailbox.\n\n    This method will create a new mailbox and enable this client to\n    message other entities on the exchange.\n\n    Args:\n        name: Display name of the client on the exchange.\n        start_listener: Start a thread to receive messages and multiplex\n            to handles.\n    \"\"\"\n    return self._bind(\n        mailbox_id=None,\n        name=name,\n        handler=None,\n        start_listener=start_listener,\n    )\n</code></pre>"},{"location":"api/exchange/proxystore/#academy.exchange.proxystore.ProxyStoreExchangeFactory.bind_as_agent","title":"bind_as_agent","text":"<pre><code>bind_as_agent(\n    agent_id: AgentId[Any],\n    *,\n    name: str | None = None,\n    handler: Callable[[RequestMessage], None] | None = None\n) -&gt; ExchangeClient\n</code></pre> <p>Bind exchange to an agent mailbox.</p> <p>This method creates a exchange client bound to an agent ID. The agent ID must be previously created on the exchange.</p> <p>Parameters:</p> <ul> <li> <code>agent_id</code>               (<code>AgentId[Any]</code>)           \u2013            <p>ID of the mailbox to receive and send messages.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Display name of the client on the exchange.</p> </li> <li> <code>handler</code>               (<code>Callable[[RequestMessage], None] | None</code>, default:                   <code>None</code> )           \u2013            <p>Agent callback to process messages.</p> </li> </ul> Source code in <code>academy/exchange/__init__.py</code> <pre><code>def bind_as_agent(\n    self,\n    agent_id: AgentId[Any],\n    *,\n    name: str | None = None,\n    handler: Callable[[RequestMessage], None] | None = None,\n) -&gt; ExchangeClient:\n    \"\"\"Bind exchange to an agent mailbox.\n\n    This method creates a exchange client bound to an agent ID.\n    The agent ID must be previously created on the exchange.\n\n    Args:\n        agent_id: ID of the mailbox to receive and send messages.\n        name: Display name of the client on the exchange.\n        handler: Agent callback to process messages.\n    \"\"\"\n    return self._bind(\n        mailbox_id=agent_id,\n        name=name,\n        handler=handler,\n        start_listener=False,\n    )\n</code></pre>"},{"location":"api/exchange/proxystore/#academy.exchange.proxystore.ProxyStoreExchangeClient","title":"ProxyStoreExchangeClient","text":"<pre><code>ProxyStoreExchangeClient(\n    exchange: ExchangeClient,\n    store: Store[Any],\n    should_proxy: Callable[[Any], bool],\n    *,\n    resolve_async: bool = False\n)\n</code></pre> <p>               Bases: <code>ExchangeClient</code></p> <p>Wrap an Exchange with ProxyStore support.</p> <p>Sending large action payloads via the exchange can result in considerable slowdowns. This Exchange wrapper can replace arguments in action requests and results in action responses with proxies to reduce communication costs.</p> <p>Parameters:</p> <ul> <li> <code>exchange</code>               (<code>ExchangeClient</code>)           \u2013            <p>Exchange to wrap.</p> </li> <li> <code>store</code>               (<code>Store[Any]</code>)           \u2013            <p>Store to use for proxying data.</p> </li> <li> <code>should_proxy</code>               (<code>Callable[[Any], bool]</code>)           \u2013            <p>A callable that returns <code>True</code> if an object should be proxied. This is applied to every positional and keyword argument and result value.</p> </li> <li> <code>resolve_async</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Resolve proxies asynchronously when received.</p> </li> </ul> Source code in <code>academy/exchange/proxystore.py</code> <pre><code>def __init__(\n    self,\n    exchange: ExchangeClient,\n    store: Store[Any],\n    should_proxy: Callable[[Any], bool],\n    *,\n    resolve_async: bool = False,\n) -&gt; None:\n    self.exchange = exchange\n    self.store = store\n    self.should_proxy = should_proxy\n    self.resolve_async = resolve_async\n    register_store(store, exist_ok=True)\n\n    # Forward properties from exchange\n    self.mailbox_id = self.exchange.mailbox_id\n    self.bound_handles = self.exchange.bound_handles\n    self.request_handler = self.exchange.request_handler\n</code></pre>"},{"location":"api/exchange/proxystore/#academy.exchange.proxystore.ProxyStoreExchangeClient.close","title":"close","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the exchange client.</p> Note <p>This does not alter the state of the exchange.</p> Source code in <code>academy/exchange/proxystore.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Close the exchange client.\n\n    Note:\n        This does not alter the state of the exchange.\n    \"\"\"\n    self.exchange.close()\n</code></pre>"},{"location":"api/exchange/proxystore/#academy.exchange.proxystore.ProxyStoreExchangeClient.status","title":"status","text":"<pre><code>status(mailbox_id: EntityId) -&gt; MailboxStatus\n</code></pre> <p>Check status of mailbox on exchange.</p> Source code in <code>academy/exchange/proxystore.py</code> <pre><code>def status(self, mailbox_id: EntityId) -&gt; MailboxStatus:\n    \"\"\"Check status of mailbox on exchange.\"\"\"\n    return self.exchange.status(mailbox_id)\n</code></pre>"},{"location":"api/exchange/proxystore/#academy.exchange.proxystore.ProxyStoreExchangeClient.register_agent","title":"register_agent","text":"<pre><code>register_agent(\n    behavior: type[BehaviorT],\n    *,\n    agent_id: AgentId[BehaviorT] | None = None,\n    name: str | None = None\n) -&gt; AgentId[BehaviorT]\n</code></pre> <p>Create a new agent identifier and associated mailbox.</p> <p>Parameters:</p> <ul> <li> <code>behavior</code>               (<code>type[BehaviorT]</code>)           \u2013            <p>Type of the behavior this agent will implement.</p> </li> <li> <code>agent_id</code>               (<code>AgentId[BehaviorT] | None</code>, default:                   <code>None</code> )           \u2013            <p>Specify the ID of the agent. Randomly generated default.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional human-readable name for the agent. Ignored if <code>agent_id</code> is provided.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AgentId[BehaviorT]</code>           \u2013            <p>Unique identifier for the agent's mailbox.</p> </li> </ul> Source code in <code>academy/exchange/proxystore.py</code> <pre><code>def register_agent(\n    self,\n    behavior: type[BehaviorT],\n    *,\n    agent_id: AgentId[BehaviorT] | None = None,\n    name: str | None = None,\n) -&gt; AgentId[BehaviorT]:\n    \"\"\"Create a new agent identifier and associated mailbox.\n\n    Args:\n        behavior: Type of the behavior this agent will implement.\n        agent_id: Specify the ID of the agent. Randomly generated\n            default.\n        name: Optional human-readable name for the agent. Ignored if\n            `agent_id` is provided.\n\n    Returns:\n        Unique identifier for the agent's mailbox.\n    \"\"\"\n    return self.exchange.register_agent(\n        behavior,\n        agent_id=agent_id,\n        name=name,\n    )\n</code></pre>"},{"location":"api/exchange/proxystore/#academy.exchange.proxystore.ProxyStoreExchangeClient.terminate","title":"terminate","text":"<pre><code>terminate(uid: EntityId) -&gt; None\n</code></pre> <p>Close the mailbox for an entity from the exchange.</p> Note <p>This method is a no-op if the mailbox does not exist.</p> <p>Parameters:</p> <ul> <li> <code>uid</code>               (<code>EntityId</code>)           \u2013            <p>Entity identifier of the mailbox to close.</p> </li> </ul> Source code in <code>academy/exchange/proxystore.py</code> <pre><code>def terminate(self, uid: EntityId) -&gt; None:\n    \"\"\"Close the mailbox for an entity from the exchange.\n\n    Note:\n        This method is a no-op if the mailbox does not exist.\n\n    Args:\n        uid: Entity identifier of the mailbox to close.\n    \"\"\"\n    self.exchange.terminate(uid)\n</code></pre>"},{"location":"api/exchange/proxystore/#academy.exchange.proxystore.ProxyStoreExchangeClient.discover","title":"discover","text":"<pre><code>discover(\n    behavior: type[Behavior],\n    *,\n    allow_subclasses: bool = True\n) -&gt; tuple[AgentId[Any], ...]\n</code></pre> <p>Discover peer agents with a given behavior.</p> <p>Parameters:</p> <ul> <li> <code>behavior</code>               (<code>type[Behavior]</code>)           \u2013            <p>Behavior type of interest.</p> </li> <li> <code>allow_subclasses</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Return agents implementing subclasses of the behavior.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[AgentId[Any], ...]</code>           \u2013            <p>Tuple of agent IDs implementing the behavior.</p> </li> </ul> Source code in <code>academy/exchange/proxystore.py</code> <pre><code>def discover(\n    self,\n    behavior: type[Behavior],\n    *,\n    allow_subclasses: bool = True,\n) -&gt; tuple[AgentId[Any], ...]:\n    \"\"\"Discover peer agents with a given behavior.\n\n    Args:\n        behavior: Behavior type of interest.\n        allow_subclasses: Return agents implementing subclasses of the\n            behavior.\n\n    Returns:\n        Tuple of agent IDs implementing the behavior.\n    \"\"\"\n    return self.exchange.discover(\n        behavior,\n        allow_subclasses=allow_subclasses,\n    )\n</code></pre>"},{"location":"api/exchange/proxystore/#academy.exchange.proxystore.ProxyStoreExchangeClient.send","title":"send","text":"<pre><code>send(uid: EntityId, message: Message) -&gt; None\n</code></pre> <p>Send a message to a mailbox.</p> <p>Parameters:</p> <ul> <li> <code>uid</code>               (<code>EntityId</code>)           \u2013            <p>Destination address of the message.</p> </li> <li> <code>message</code>               (<code>Message</code>)           \u2013            <p>Message to send.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BadEntityIdError</code>             \u2013            <p>if a mailbox for <code>uid</code> does not exist.</p> </li> <li> <code>MailboxClosedError</code>             \u2013            <p>if the mailbox was closed.</p> </li> </ul> Source code in <code>academy/exchange/proxystore.py</code> <pre><code>def send(self, uid: EntityId, message: Message) -&gt; None:\n    \"\"\"Send a message to a mailbox.\n\n    Args:\n        uid: Destination address of the message.\n        message: Message to send.\n\n    Raises:\n        BadEntityIdError: if a mailbox for `uid` does not exist.\n        MailboxClosedError: if the mailbox was closed.\n    \"\"\"\n    if isinstance(message, ActionRequest):\n        message.pargs = _proxy_iterable(\n            message.pargs,\n            self.store,\n            self.should_proxy,\n        )\n        message.kargs = _proxy_mapping(\n            message.kargs,\n            self.store,\n            self.should_proxy,\n        )\n    if isinstance(message, ActionResponse) and message.result is not None:\n        message.result = _proxy_item(\n            message.result,\n            self.store,\n            self.should_proxy,\n        )\n\n    self.exchange.send(uid, message)\n</code></pre>"},{"location":"api/exchange/proxystore/#academy.exchange.proxystore.ProxyStoreExchangeClient.recv","title":"recv","text":"<pre><code>recv(timeout: float | None = None) -&gt; Message\n</code></pre> <p>Receive the next message in the mailbox.</p> <p>This blocks until the next message is received or the mailbox is closed.</p> <p>Parameters:</p> <ul> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional timeout in seconds to wait for the next message. If <code>None</code>, the default, block forever until the next message or the mailbox is closed.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>MailboxClosedError</code>             \u2013            <p>if the mailbox was closed.</p> </li> <li> <code>TimeoutError</code>             \u2013            <p>if a <code>timeout</code> was specified and exceeded.</p> </li> </ul> Source code in <code>academy/exchange/proxystore.py</code> <pre><code>def recv(self, timeout: float | None = None) -&gt; Message:\n    \"\"\"Receive the next message in the mailbox.\n\n    This blocks until the next message is received or the mailbox\n    is closed.\n\n    Args:\n        timeout: Optional timeout in seconds to wait for the next\n            message. If `None`, the default, block forever until the\n            next message or the mailbox is closed.\n\n    Raises:\n        MailboxClosedError: if the mailbox was closed.\n        TimeoutError: if a `timeout` was specified and exceeded.\n    \"\"\"\n    message = self.exchange.recv(timeout)\n    if self.resolve_async and isinstance(message, ActionRequest):\n        for arg in (*message.pargs, *message.kargs.values()):\n            if type(arg) is Proxy:\n                resolve_async(arg)\n    elif (\n        self.resolve_async\n        and isinstance(message, ActionResponse)\n        and type(message.result) is Proxy\n    ):\n        resolve_async(message.result)\n    return message\n</code></pre>"},{"location":"api/exchange/proxystore/#academy.exchange.proxystore.ProxyStoreExchangeClient.clone","title":"clone","text":"<pre><code>clone() -&gt; ProxyStoreExchangeFactory\n</code></pre> <p>Shallow copy exchange to new, unbound version.</p> Source code in <code>academy/exchange/proxystore.py</code> <pre><code>def clone(self) -&gt; ProxyStoreExchangeFactory:\n    \"\"\"Shallow copy exchange to new, unbound version.\"\"\"\n    return ProxyStoreExchangeFactory(\n        self.exchange.clone(),\n        self.store,\n        self.should_proxy,\n        resolve_async=self.resolve_async,\n    )\n</code></pre>"},{"location":"api/exchange/proxystore/#academy.exchange.proxystore.ProxyStoreExchangeClient.get_handle","title":"get_handle","text":"<pre><code>get_handle(\n    aid: AgentId[BehaviorT],\n) -&gt; BoundRemoteHandle[BehaviorT]\n</code></pre> <p>Create a new handle to an agent.</p> <p>A handle enables a client to invoke actions on the agent.</p> Note <p>It is not possible to create a handle to a client since a handle is essentially a new client of a specific agent.</p> <p>Parameters:</p> <ul> <li> <code>aid</code>               (<code>AgentId[BehaviorT]</code>)           \u2013            <p>EntityId of the agent to create an handle to.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>BoundRemoteHandle[BehaviorT]</code>           \u2013            <p>Handle to the agent.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>if <code>aid</code> is not an instance of <code>AgentId</code>.</p> </li> </ul> Source code in <code>academy/exchange/__init__.py</code> <pre><code>def get_handle(\n    self,\n    aid: AgentId[BehaviorT],\n) -&gt; BoundRemoteHandle[BehaviorT]:\n    \"\"\"Create a new handle to an agent.\n\n    A handle enables a client to invoke actions on the agent.\n\n    Note:\n        It is not possible to create a handle to a client since a handle\n        is essentially a new client of a specific agent.\n\n    Args:\n        aid: EntityId of the agent to create an handle to.\n\n    Returns:\n        Handle to the agent.\n\n    Raises:\n        TypeError: if `aid` is not an instance of\n            [`AgentId`][academy.identifier.AgentId].\n    \"\"\"\n    if not isinstance(aid, AgentId):\n        raise TypeError(\n            f'Handle must be created from an {AgentId.__name__} '\n            f'but got identifier with type {type(aid).__name__}.',\n        )\n\n    hdl = BoundRemoteHandle(self, aid, self.mailbox_id)\n    self.bound_handles[hdl.handle_id] = hdl\n    return hdl\n</code></pre>"},{"location":"api/exchange/proxystore/#academy.exchange.proxystore.ProxyStoreExchangeClient.close_bound_handles","title":"close_bound_handles","text":"<pre><code>close_bound_handles() -&gt; None\n</code></pre> <p>Close all handles bound to this mailbox.</p> Source code in <code>academy/exchange/__init__.py</code> <pre><code>def close_bound_handles(self) -&gt; None:\n    \"\"\"Close all handles bound to this mailbox.\"\"\"\n    for key in tuple(self.bound_handles):\n        handle = self.bound_handles.pop(key)\n        handle.close(wait_futures=False)\n</code></pre>"},{"location":"api/exchange/proxystore/#academy.exchange.proxystore.ProxyStoreExchangeClient.listen","title":"listen","text":"<pre><code>listen() -&gt; None\n</code></pre> <p>Listen for new messages in the mailbox and process them.</p> <p>Request messages are processed via the <code>request_handler</code>, and response messages are dispatched to the handle that created the corresponding request.</p> Warning <p>This method loops forever, until the mailbox is closed. Thus this method is typically run inside of a thread.</p> Note <p>Response messages intended for a handle that does not exist will be logged and discarded.</p> Source code in <code>academy/exchange/__init__.py</code> <pre><code>def listen(self) -&gt; None:\n    \"\"\"Listen for new messages in the mailbox and process them.\n\n    Request messages are processed via the `request_handler`, and response\n    messages are dispatched to the handle that created the corresponding\n    request.\n\n    Warning:\n        This method loops forever, until the mailbox is closed. Thus this\n        method is typically run inside of a thread.\n\n    Note:\n        Response messages intended for a handle that does not exist\n        will be logged and discarded.\n    \"\"\"\n    try:\n        while True:\n            message = self.recv()\n            self._message_handler(message)\n    except MailboxClosedError:\n        pass\n</code></pre>"},{"location":"api/exchange/queue/","title":"academy.exchange.queue","text":"<code>academy/exchange/queue.py</code>"},{"location":"api/exchange/queue/#academy.exchange.queue.QueueClosedError","title":"QueueClosedError","text":"<p>               Bases: <code>Exception</code></p> <p>Queue has been closed exception.</p>"},{"location":"api/exchange/queue/#academy.exchange.queue.AsyncQueue","title":"AsyncQueue","text":"<pre><code>AsyncQueue()\n</code></pre> <p>               Bases: <code>Generic[T]</code></p> <p>Simple async queue.</p> <p>This is a simple backport of Python 3.13 queues which have a shutdown method and exception type.</p> Source code in <code>academy/exchange/queue.py</code> <pre><code>def __init__(self) -&gt; None:\n    self._queue: asyncio.PriorityQueue[_Item[T]] = asyncio.PriorityQueue()\n    self._closed = False\n</code></pre>"},{"location":"api/exchange/queue/#academy.exchange.queue.AsyncQueue.close","title":"close  <code>async</code>","text":"<pre><code>close(immediate: bool = False) -&gt; None\n</code></pre> <p>Close the queue.</p> <p>This will cause <code>get</code> and <code>put</code> to raise <code>QueueClosedError</code>.</p> <p>Parameters:</p> <ul> <li> <code>immediate</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Close the queue immediately, rather than once the queue is empty.</p> </li> </ul> Source code in <code>academy/exchange/queue.py</code> <pre><code>async def close(self, immediate: bool = False) -&gt; None:\n    \"\"\"Close the queue.\n\n    This will cause `get` and `put` to raise `QueueClosedError`.\n\n    Args:\n        immediate: Close the queue immediately, rather than once the\n            queue is empty.\n    \"\"\"\n    if not self.closed():\n        self._closed = True\n        priority = CLOSE_PRIORITY if immediate else DEFAULT_PRIORITY\n        await self._queue.put(_Item(priority, CLOSE_SENTINEL))\n</code></pre>"},{"location":"api/exchange/queue/#academy.exchange.queue.AsyncQueue.closed","title":"closed","text":"<pre><code>closed() -&gt; bool\n</code></pre> <p>Check if the queue has been closed.</p> Source code in <code>academy/exchange/queue.py</code> <pre><code>def closed(self) -&gt; bool:\n    \"\"\"Check if the queue has been closed.\"\"\"\n    return self._closed\n</code></pre>"},{"location":"api/exchange/queue/#academy.exchange.queue.AsyncQueue.get","title":"get  <code>async</code>","text":"<pre><code>get() -&gt; T\n</code></pre> <p>Remove and return the next item from the queue (blocking).</p> Source code in <code>academy/exchange/queue.py</code> <pre><code>async def get(self) -&gt; T:\n    \"\"\"Remove and return the next item from the queue (blocking).\"\"\"\n    item = await self._queue.get()\n    if item.value is CLOSE_SENTINEL:\n        raise QueueClosedError\n    return cast(T, item.value)\n</code></pre>"},{"location":"api/exchange/queue/#academy.exchange.queue.AsyncQueue.put","title":"put  <code>async</code>","text":"<pre><code>put(item: T) -&gt; None\n</code></pre> <p>Put an item on the queue.</p> Source code in <code>academy/exchange/queue.py</code> <pre><code>async def put(self, item: T) -&gt; None:\n    \"\"\"Put an item on the queue.\"\"\"\n    if self.closed():\n        raise QueueClosedError\n    await self._queue.put(_Item(DEFAULT_PRIORITY, item))\n</code></pre>"},{"location":"api/exchange/queue/#academy.exchange.queue.Queue","title":"Queue","text":"<pre><code>Queue()\n</code></pre> <p>               Bases: <code>Generic[T]</code></p> <p>Simple queue.</p> <p>This is a simple backport of Python 3.13 queues which have a shutdown method and exception type.</p> Source code in <code>academy/exchange/queue.py</code> <pre><code>def __init__(self) -&gt; None:\n    self._queue: queue.PriorityQueue[_Item[T]] = queue.PriorityQueue()\n    self._closed = False\n</code></pre>"},{"location":"api/exchange/queue/#academy.exchange.queue.Queue.close","title":"close","text":"<pre><code>close(immediate: bool = False) -&gt; None\n</code></pre> <p>Close the queue.</p> <p>This will cause <code>get</code> and <code>put</code> to raise <code>QueueClosedError</code>.</p> <p>Parameters:</p> <ul> <li> <code>immediate</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Close the queue immediately, rather than once the queue is empty.</p> </li> </ul> Source code in <code>academy/exchange/queue.py</code> <pre><code>def close(self, immediate: bool = False) -&gt; None:\n    \"\"\"Close the queue.\n\n    This will cause `get` and `put` to raise `QueueClosedError`.\n\n    Args:\n        immediate: Close the queue immediately, rather than once the\n            queue is empty.\n    \"\"\"\n    if not self.closed():\n        self._closed = True\n        priority = CLOSE_PRIORITY if immediate else DEFAULT_PRIORITY\n        self._queue.put(_Item(priority, CLOSE_SENTINEL))\n</code></pre>"},{"location":"api/exchange/queue/#academy.exchange.queue.Queue.closed","title":"closed","text":"<pre><code>closed() -&gt; bool\n</code></pre> <p>Check if the queue has been closed.</p> Source code in <code>academy/exchange/queue.py</code> <pre><code>def closed(self) -&gt; bool:\n    \"\"\"Check if the queue has been closed.\"\"\"\n    return self._closed\n</code></pre>"},{"location":"api/exchange/queue/#academy.exchange.queue.Queue.get","title":"get","text":"<pre><code>get(timeout: float | None = None) -&gt; T\n</code></pre> <p>Remove and return the next item from the queue (blocking).</p> <p>Parameters:</p> <ul> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Block at most <code>timeout</code> seconds.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TimeoutError</code>             \u2013            <p>if no item was available within <code>timeout</code> seconds.</p> </li> <li> <code>QueueClosedError</code>             \u2013            <p>if the queue was closed.</p> </li> </ul> Source code in <code>academy/exchange/queue.py</code> <pre><code>def get(self, timeout: float | None = None) -&gt; T:\n    \"\"\"Remove and return the next item from the queue (blocking).\n\n    Args:\n        timeout: Block at most `timeout` seconds.\n\n    Raises:\n        TimeoutError: if no item was available within `timeout` seconds.\n        QueueClosedError: if the queue was closed.\n    \"\"\"\n    try:\n        item = self._queue.get(timeout=timeout)\n    except queue.Empty:\n        raise TimeoutError from None\n    if item.value is CLOSE_SENTINEL:\n        # Push the sentinel back to the queue in case another thread\n        # has called get.\n        self._queue.put(_Item(CLOSE_PRIORITY, CLOSE_SENTINEL))\n        raise QueueClosedError\n    return cast(T, item.value)\n</code></pre>"},{"location":"api/exchange/queue/#academy.exchange.queue.Queue.put","title":"put","text":"<pre><code>put(item: T) -&gt; None\n</code></pre> <p>Put an item on the queue.</p> <p>Parameters:</p> <ul> <li> <code>item</code>               (<code>T</code>)           \u2013            <p>The item to put on the queue.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>QueueClosedError</code>             \u2013            <p>if the queue was closed.</p> </li> </ul> Source code in <code>academy/exchange/queue.py</code> <pre><code>def put(self, item: T) -&gt; None:\n    \"\"\"Put an item on the queue.\n\n    Args:\n        item: The item to put on the queue.\n\n    Raises:\n        QueueClosedError: if the queue was closed.\n    \"\"\"\n    if self.closed():\n        raise QueueClosedError\n    self._queue.put(_Item(DEFAULT_PRIORITY, item))\n</code></pre>"},{"location":"api/exchange/redis/","title":"academy.exchange.redis","text":"<code>academy/exchange/redis.py</code>"},{"location":"api/exchange/redis/#academy.exchange.redis.RedisExchangeFactory","title":"RedisExchangeFactory","text":"<pre><code>RedisExchangeFactory(\n    hostname: str,\n    port: int,\n    *,\n    timeout: int | None = None,\n    **kwargs: Any\n)\n</code></pre> <p>               Bases: <code>ExchangeFactory</code></p> <p>Redis-hosted message exchange interface.</p> <p>Parameters:</p> <ul> <li> <code>hostname</code>               (<code>str</code>)           \u2013            <p>Redis server hostname.</p> </li> <li> <code>port</code>               (<code>int</code>)           \u2013            <p>Redis server port.</p> </li> <li> <code>kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Extra keyword arguments to pass to <code>redis.Redis()</code>.</p> </li> <li> <code>timeout</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Timeout for waiting on the next message. If <code>None</code>, the timeout will be set to one second but will loop indefinitely.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ConnectionError</code>             \u2013            <p>If the Redis server is not reachable.</p> </li> </ul> Source code in <code>academy/exchange/redis.py</code> <pre><code>def __init__(\n    self,\n    hostname: str,\n    port: int,\n    *,\n    timeout: int | None = None,\n    **kwargs: Any,\n) -&gt; None:\n    self.hostname = hostname\n    self.port = port\n    self.timeout = timeout\n    self._kwargs = kwargs\n</code></pre>"},{"location":"api/exchange/redis/#academy.exchange.redis.RedisExchangeFactory.bind_as_client","title":"bind_as_client","text":"<pre><code>bind_as_client(\n    *, name: str | None = None, start_listener: bool = True\n) -&gt; ExchangeClient\n</code></pre> <p>Bind exchange to a new client mailbox.</p> <p>This method will create a new mailbox and enable this client to message other entities on the exchange.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Display name of the client on the exchange.</p> </li> <li> <code>start_listener</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Start a thread to receive messages and multiplex to handles.</p> </li> </ul> Source code in <code>academy/exchange/__init__.py</code> <pre><code>def bind_as_client(\n    self,\n    *,\n    name: str | None = None,\n    start_listener: bool = True,\n) -&gt; ExchangeClient:\n    \"\"\"Bind exchange to a new client mailbox.\n\n    This method will create a new mailbox and enable this client to\n    message other entities on the exchange.\n\n    Args:\n        name: Display name of the client on the exchange.\n        start_listener: Start a thread to receive messages and multiplex\n            to handles.\n    \"\"\"\n    return self._bind(\n        mailbox_id=None,\n        name=name,\n        handler=None,\n        start_listener=start_listener,\n    )\n</code></pre>"},{"location":"api/exchange/redis/#academy.exchange.redis.RedisExchangeFactory.bind_as_agent","title":"bind_as_agent","text":"<pre><code>bind_as_agent(\n    agent_id: AgentId[Any],\n    *,\n    name: str | None = None,\n    handler: Callable[[RequestMessage], None] | None = None\n) -&gt; ExchangeClient\n</code></pre> <p>Bind exchange to an agent mailbox.</p> <p>This method creates a exchange client bound to an agent ID. The agent ID must be previously created on the exchange.</p> <p>Parameters:</p> <ul> <li> <code>agent_id</code>               (<code>AgentId[Any]</code>)           \u2013            <p>ID of the mailbox to receive and send messages.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Display name of the client on the exchange.</p> </li> <li> <code>handler</code>               (<code>Callable[[RequestMessage], None] | None</code>, default:                   <code>None</code> )           \u2013            <p>Agent callback to process messages.</p> </li> </ul> Source code in <code>academy/exchange/__init__.py</code> <pre><code>def bind_as_agent(\n    self,\n    agent_id: AgentId[Any],\n    *,\n    name: str | None = None,\n    handler: Callable[[RequestMessage], None] | None = None,\n) -&gt; ExchangeClient:\n    \"\"\"Bind exchange to an agent mailbox.\n\n    This method creates a exchange client bound to an agent ID.\n    The agent ID must be previously created on the exchange.\n\n    Args:\n        agent_id: ID of the mailbox to receive and send messages.\n        name: Display name of the client on the exchange.\n        handler: Agent callback to process messages.\n    \"\"\"\n    return self._bind(\n        mailbox_id=agent_id,\n        name=name,\n        handler=handler,\n        start_listener=False,\n    )\n</code></pre>"},{"location":"api/exchange/redis/#academy.exchange.redis.RedisExchangeClient","title":"RedisExchangeClient","text":"<pre><code>RedisExchangeClient(\n    unbound: RedisExchangeFactory,\n    mailbox_id: EntityId | None = None,\n    *,\n    name: str | None = None,\n    handler: Callable[[RequestMessage], None] | None = None,\n    start_listener: bool\n)\n</code></pre> <p>               Bases: <code>ExchangeClient</code></p> <p>Redis-hosted message exchange interface.</p> <p>Parameters:</p> <ul> <li> <code>unbound</code>               (<code>RedisExchangeFactory</code>)           \u2013            <p>The unbound exchange to use to create this client.</p> </li> <li> <code>mailbox_id</code>               (<code>EntityId | None</code>, default:                   <code>None</code> )           \u2013            <p>Identifier of the mailbox on the exchange. If there is not an id provided, the exchange will create a new client mailbox.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Display name of mailbox on exchange.</p> </li> <li> <code>handler</code>               (<code>Callable[[RequestMessage], None] | None</code>, default:                   <code>None</code> )           \u2013            <p>Callback to handler requests to this exchange.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ConnectionError</code>             \u2013            <p>If the Redis server is not reachable.</p> </li> </ul> Source code in <code>academy/exchange/redis.py</code> <pre><code>def __init__(\n    self,\n    unbound: RedisExchangeFactory,\n    mailbox_id: EntityId | None = None,\n    *,\n    name: str | None = None,\n    handler: Callable[[RequestMessage], None] | None = None,\n    start_listener: bool,\n) -&gt; None:\n    self.hostname = unbound.hostname\n    self.port = unbound.port\n    self.timeout = unbound.timeout\n    self._kwargs = unbound._kwargs\n    self._client = redis.Redis(\n        host=self.hostname,\n        port=self.port,\n        decode_responses=False,\n        **self._kwargs,\n    )\n    self._client.ping()\n\n    super().__init__(\n        mailbox_id,\n        name=name,\n        handler=handler,\n        start_listener=start_listener,\n    )\n</code></pre>"},{"location":"api/exchange/redis/#academy.exchange.redis.RedisExchangeClient.close","title":"close","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the exchange interface.</p> Source code in <code>academy/exchange/redis.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Close the exchange interface.\"\"\"\n    super().close()\n\n    self._client.close()\n    logger.debug('Closed exchange (%s)', self)\n</code></pre>"},{"location":"api/exchange/redis/#academy.exchange.redis.RedisExchangeClient.status","title":"status","text":"<pre><code>status(mailbox_id: EntityId) -&gt; MailboxStatus\n</code></pre> <p>Check status of mailbox on exchange.</p> Source code in <code>academy/exchange/redis.py</code> <pre><code>def status(self, mailbox_id: EntityId) -&gt; MailboxStatus:\n    \"\"\"Check status of mailbox on exchange.\"\"\"\n    status = self._client.get(self._active_key(mailbox_id))\n    if status is None:\n        return MailboxStatus.MISSING\n    elif status == _MailboxState.INACTIVE.value:\n        return MailboxStatus.TERMINATED\n    else:\n        return MailboxStatus.ACTIVE\n</code></pre>"},{"location":"api/exchange/redis/#academy.exchange.redis.RedisExchangeClient.register_agent","title":"register_agent","text":"<pre><code>register_agent(\n    behavior: type[BehaviorT],\n    *,\n    agent_id: AgentId[BehaviorT] | None = None,\n    name: str | None = None\n) -&gt; AgentId[BehaviorT]\n</code></pre> <p>Create a new agent identifier and associated mailbox.</p> <p>Parameters:</p> <ul> <li> <code>behavior</code>               (<code>type[BehaviorT]</code>)           \u2013            <p>Type of the behavior this agent will implement.</p> </li> <li> <code>agent_id</code>               (<code>AgentId[BehaviorT] | None</code>, default:                   <code>None</code> )           \u2013            <p>Specify the ID of the agent. Randomly generated default.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional human-readable name for the agent. Ignored if <code>agent_id</code> is provided.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AgentId[BehaviorT]</code>           \u2013            <p>Unique identifier for the agent's mailbox.</p> </li> </ul> Source code in <code>academy/exchange/redis.py</code> <pre><code>def register_agent(\n    self,\n    behavior: type[BehaviorT],\n    *,\n    agent_id: AgentId[BehaviorT] | None = None,\n    name: str | None = None,\n) -&gt; AgentId[BehaviorT]:\n    \"\"\"Create a new agent identifier and associated mailbox.\n\n    Args:\n        behavior: Type of the behavior this agent will implement.\n        agent_id: Specify the ID of the agent. Randomly generated\n            default.\n        name: Optional human-readable name for the agent. Ignored if\n            `agent_id` is provided.\n\n    Returns:\n        Unique identifier for the agent's mailbox.\n    \"\"\"\n    aid = AgentId.new(name=name) if agent_id is None else agent_id\n    self._client.set(self._active_key(aid), _MailboxState.ACTIVE.value)\n    self._client.set(\n        self._behavior_key(aid),\n        ','.join(behavior.behavior_mro()),\n    )\n    logger.debug('Registered %s in %s', aid, self)\n    return aid\n</code></pre>"},{"location":"api/exchange/redis/#academy.exchange.redis.RedisExchangeClient.terminate","title":"terminate","text":"<pre><code>terminate(uid: EntityId) -&gt; None\n</code></pre> <p>Close the mailbox for an entity from the exchange.</p> Note <p>This method is a no-op if the mailbox does not exist.</p> <p>Parameters:</p> <ul> <li> <code>uid</code>               (<code>EntityId</code>)           \u2013            <p>Entity identifier of the mailbox to close.</p> </li> </ul> Source code in <code>academy/exchange/redis.py</code> <pre><code>def terminate(self, uid: EntityId) -&gt; None:\n    \"\"\"Close the mailbox for an entity from the exchange.\n\n    Note:\n        This method is a no-op if the mailbox does not exist.\n\n    Args:\n        uid: Entity identifier of the mailbox to close.\n    \"\"\"\n    self._client.set(self._active_key(uid), _MailboxState.INACTIVE.value)\n    # Sending a close sentinel to the queue is a quick way to force\n    # the entity waiting on messages to the mailbox to stop blocking.\n    # This assumes that only one entity is reading from the mailbox.\n    self._client.rpush(self._queue_key(uid), _CLOSE_SENTINEL)\n    if isinstance(uid, AgentId):\n        self._client.delete(self._behavior_key(uid))\n    logger.debug('Closed mailbox for %s (%s)', uid, self)\n</code></pre>"},{"location":"api/exchange/redis/#academy.exchange.redis.RedisExchangeClient.discover","title":"discover","text":"<pre><code>discover(\n    behavior: type[Behavior], allow_subclasses: bool = True\n) -&gt; tuple[AgentId[Any], ...]\n</code></pre> <p>Discover peer agents with a given behavior.</p> Warning <p>This method is O(n) and scans all keys in the Redis server.</p> <p>Parameters:</p> <ul> <li> <code>behavior</code>               (<code>type[Behavior]</code>)           \u2013            <p>Behavior type of interest.</p> </li> <li> <code>allow_subclasses</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Return agents implementing subclasses of the behavior.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[AgentId[Any], ...]</code>           \u2013            <p>Tuple of agent IDs implementing the behavior.</p> </li> </ul> Source code in <code>academy/exchange/redis.py</code> <pre><code>def discover(\n    self,\n    behavior: type[Behavior],\n    allow_subclasses: bool = True,\n) -&gt; tuple[AgentId[Any], ...]:\n    \"\"\"Discover peer agents with a given behavior.\n\n    Warning:\n        This method is O(n) and scans all keys in the Redis server.\n\n    Args:\n        behavior: Behavior type of interest.\n        allow_subclasses: Return agents implementing subclasses of the\n            behavior.\n\n    Returns:\n        Tuple of agent IDs implementing the behavior.\n    \"\"\"\n    found: list[AgentId[Any]] = []\n    fqp = f'{behavior.__module__}.{behavior.__name__}'\n    for key in self._client.scan_iter('behavior:*'):\n        mro_str = self._client.get(key)\n        assert isinstance(mro_str, str)\n        mro = mro_str.split(',')\n        if fqp == mro[0] or (allow_subclasses and fqp in mro):\n            aid: AgentId[Any] = AgentId(uid=uuid.UUID(key.split(':')[-1]))\n            found.append(aid)\n    active: list[AgentId[Any]] = []\n    for aid in found:\n        status = self._client.get(self._active_key(aid))\n        if status == _MailboxState.ACTIVE.value:  # pragma: no branch\n            active.append(aid)\n    return tuple(active)\n</code></pre>"},{"location":"api/exchange/redis/#academy.exchange.redis.RedisExchangeClient.send","title":"send","text":"<pre><code>send(uid: EntityId, message: Message) -&gt; None\n</code></pre> <p>Send a message to a mailbox.</p> <p>Parameters:</p> <ul> <li> <code>uid</code>               (<code>EntityId</code>)           \u2013            <p>Destination address of the message.</p> </li> <li> <code>message</code>               (<code>Message</code>)           \u2013            <p>Message to send.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BadEntityIdError</code>             \u2013            <p>if a mailbox for <code>uid</code> does not exist.</p> </li> <li> <code>MailboxClosedError</code>             \u2013            <p>if the mailbox was closed.</p> </li> </ul> Source code in <code>academy/exchange/redis.py</code> <pre><code>def send(self, uid: EntityId, message: Message) -&gt; None:\n    \"\"\"Send a message to a mailbox.\n\n    Args:\n        uid: Destination address of the message.\n        message: Message to send.\n\n    Raises:\n        BadEntityIdError: if a mailbox for `uid` does not exist.\n        MailboxClosedError: if the mailbox was closed.\n    \"\"\"\n    status = self._client.get(self._active_key(uid))\n    if status is None:\n        raise BadEntityIdError(uid)\n    elif status == _MailboxState.INACTIVE.value:\n        raise MailboxClosedError(uid)\n    else:\n        self._client.rpush(self._queue_key(uid), message.model_serialize())\n        logger.debug('Sent %s to %s', type(message).__name__, uid)\n</code></pre>"},{"location":"api/exchange/redis/#academy.exchange.redis.RedisExchangeClient.recv","title":"recv","text":"<pre><code>recv(timeout: float | None = None) -&gt; Message\n</code></pre> <p>Receive the next message in the mailbox.</p> <p>This blocks until the next message is received or the mailbox is closed.</p> <p>Parameters:</p> <ul> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional timeout in seconds to wait for the next message. If <code>None</code>, the default, block forever until the next message or the mailbox is closed. Note that this will be cast to an int which is required by the Redis API.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>MailboxClosedError</code>             \u2013            <p>if the mailbox was closed.</p> </li> <li> <code>TimeoutError</code>             \u2013            <p>if a <code>timeout</code> was specified and exceeded.</p> </li> </ul> Source code in <code>academy/exchange/redis.py</code> <pre><code>def recv(self, timeout: float | None = None) -&gt; Message:\n    \"\"\"Receive the next message in the mailbox.\n\n    This blocks until the next message is received or the mailbox\n    is closed.\n\n    Args:\n        timeout: Optional timeout in seconds to wait for the next\n            message. If `None`, the default, block forever until the\n            next message or the mailbox is closed. Note that this will\n            be cast to an int which is required by the Redis API.\n\n    Raises:\n        MailboxClosedError: if the mailbox was closed.\n        TimeoutError: if a `timeout` was specified and exceeded.\n    \"\"\"\n    _timeout = int(timeout) if timeout is not None else 1\n    while True:\n        status = self._client.get(\n            self._active_key(self.mailbox_id),\n        )\n        if status is None:\n            raise AssertionError(\n                f'Status for mailbox {self.mailbox_id} did not exist in '\n                'Redis server. This means that something incorrectly '\n                'deleted the key.',\n            )\n        elif status == _MailboxState.INACTIVE.value:\n            raise MailboxClosedError(self.mailbox_id)\n\n        raw = self._client.blpop(\n            [self._queue_key(self.mailbox_id)],\n            timeout=_timeout,\n        )\n        if raw is None and timeout is not None:\n            raise TimeoutError(\n                f'Timeout waiting for next message for {self.mailbox_id} '\n                f'after {timeout} seconds.',\n            )\n        elif raw is None:  # pragma: no cover\n            continue\n\n        # Only passed one key to blpop to result is [key, item]\n        assert isinstance(raw, (tuple, list))\n        assert len(raw) == 2  # noqa: PLR2004\n        if raw[1] == _CLOSE_SENTINEL:  # pragma: no cover\n            raise MailboxClosedError(self.mailbox_id)\n        message = BaseMessage.model_deserialize(raw[1])\n        assert isinstance(message, get_args(Message))\n        logger.debug(\n            'Received %s to %s',\n            type(message).__name__,\n            self.mailbox_id,\n        )\n        return message\n</code></pre>"},{"location":"api/exchange/redis/#academy.exchange.redis.RedisExchangeClient.clone","title":"clone","text":"<pre><code>clone() -&gt; RedisExchangeFactory\n</code></pre> <p>Shallow copy exchange to new, unbound version.</p> Source code in <code>academy/exchange/redis.py</code> <pre><code>def clone(self) -&gt; RedisExchangeFactory:\n    \"\"\"Shallow copy exchange to new, unbound version.\"\"\"\n    return RedisExchangeFactory(\n        self.hostname,\n        self.port,\n        timeout=self.timeout,\n        **self._kwargs,\n    )\n</code></pre>"},{"location":"api/exchange/redis/#academy.exchange.redis.RedisExchangeClient.get_handle","title":"get_handle","text":"<pre><code>get_handle(\n    aid: AgentId[BehaviorT],\n) -&gt; BoundRemoteHandle[BehaviorT]\n</code></pre> <p>Create a new handle to an agent.</p> <p>A handle enables a client to invoke actions on the agent.</p> Note <p>It is not possible to create a handle to a client since a handle is essentially a new client of a specific agent.</p> <p>Parameters:</p> <ul> <li> <code>aid</code>               (<code>AgentId[BehaviorT]</code>)           \u2013            <p>EntityId of the agent to create an handle to.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>BoundRemoteHandle[BehaviorT]</code>           \u2013            <p>Handle to the agent.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>if <code>aid</code> is not an instance of <code>AgentId</code>.</p> </li> </ul> Source code in <code>academy/exchange/__init__.py</code> <pre><code>def get_handle(\n    self,\n    aid: AgentId[BehaviorT],\n) -&gt; BoundRemoteHandle[BehaviorT]:\n    \"\"\"Create a new handle to an agent.\n\n    A handle enables a client to invoke actions on the agent.\n\n    Note:\n        It is not possible to create a handle to a client since a handle\n        is essentially a new client of a specific agent.\n\n    Args:\n        aid: EntityId of the agent to create an handle to.\n\n    Returns:\n        Handle to the agent.\n\n    Raises:\n        TypeError: if `aid` is not an instance of\n            [`AgentId`][academy.identifier.AgentId].\n    \"\"\"\n    if not isinstance(aid, AgentId):\n        raise TypeError(\n            f'Handle must be created from an {AgentId.__name__} '\n            f'but got identifier with type {type(aid).__name__}.',\n        )\n\n    hdl = BoundRemoteHandle(self, aid, self.mailbox_id)\n    self.bound_handles[hdl.handle_id] = hdl\n    return hdl\n</code></pre>"},{"location":"api/exchange/redis/#academy.exchange.redis.RedisExchangeClient.close_bound_handles","title":"close_bound_handles","text":"<pre><code>close_bound_handles() -&gt; None\n</code></pre> <p>Close all handles bound to this mailbox.</p> Source code in <code>academy/exchange/__init__.py</code> <pre><code>def close_bound_handles(self) -&gt; None:\n    \"\"\"Close all handles bound to this mailbox.\"\"\"\n    for key in tuple(self.bound_handles):\n        handle = self.bound_handles.pop(key)\n        handle.close(wait_futures=False)\n</code></pre>"},{"location":"api/exchange/redis/#academy.exchange.redis.RedisExchangeClient.listen","title":"listen","text":"<pre><code>listen() -&gt; None\n</code></pre> <p>Listen for new messages in the mailbox and process them.</p> <p>Request messages are processed via the <code>request_handler</code>, and response messages are dispatched to the handle that created the corresponding request.</p> Warning <p>This method loops forever, until the mailbox is closed. Thus this method is typically run inside of a thread.</p> Note <p>Response messages intended for a handle that does not exist will be logged and discarded.</p> Source code in <code>academy/exchange/__init__.py</code> <pre><code>def listen(self) -&gt; None:\n    \"\"\"Listen for new messages in the mailbox and process them.\n\n    Request messages are processed via the `request_handler`, and response\n    messages are dispatched to the handle that created the corresponding\n    request.\n\n    Warning:\n        This method loops forever, until the mailbox is closed. Thus this\n        method is typically run inside of a thread.\n\n    Note:\n        Response messages intended for a handle that does not exist\n        will be logged and discarded.\n    \"\"\"\n    try:\n        while True:\n            message = self.recv()\n            self._message_handler(message)\n    except MailboxClosedError:\n        pass\n</code></pre>"},{"location":"api/exchange/thread/","title":"academy.exchange.thread","text":"<code>academy/exchange/thread.py</code>"},{"location":"api/exchange/thread/#academy.exchange.thread.ThreadExchangeState","title":"ThreadExchangeState","text":"<pre><code>ThreadExchangeState()\n</code></pre> <p>               Bases: <code>NoPickleMixin</code></p> <p>Local process message exchange for threaded agents.</p> <p>ThreadExchange is a special case of an exchange where the mailboxes of the exchange live in process memory. This class stores the state of the exchange.</p> Source code in <code>academy/exchange/thread.py</code> <pre><code>def __init__(self) -&gt; None:\n    self.queues: dict[EntityId, Queue[Message]] = {}\n    self.behaviors: dict[AgentId[Any], type[Behavior]] = {}\n</code></pre>"},{"location":"api/exchange/thread/#academy.exchange.thread.ThreadExchangeFactory","title":"ThreadExchangeFactory","text":"<pre><code>ThreadExchangeFactory(\n    exchange_state: ThreadExchangeState | None = None,\n)\n</code></pre> <p>               Bases: <code>ExchangeFactory</code></p> <p>A unbound thread exchange.</p> <p>A thread exchange can be used to pass messages between agents within a process.</p> <p>Parameters:</p> <ul> <li> <code>exchange_state</code>               (<code>ThreadExchangeState | None</code>, default:                   <code>None</code> )           \u2013            <p>The state of the queues used by the exchange</p> </li> </ul> Source code in <code>academy/exchange/thread.py</code> <pre><code>def __init__(self, exchange_state: ThreadExchangeState | None = None):\n    self._state = (\n        ThreadExchangeState() if exchange_state is None else exchange_state\n    )\n</code></pre>"},{"location":"api/exchange/thread/#academy.exchange.thread.ThreadExchangeFactory.bind_as_client","title":"bind_as_client","text":"<pre><code>bind_as_client(\n    *, name: str | None = None, start_listener: bool = True\n) -&gt; ExchangeClient\n</code></pre> <p>Bind exchange to a new client mailbox.</p> <p>This method will create a new mailbox and enable this client to message other entities on the exchange.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Display name of the client on the exchange.</p> </li> <li> <code>start_listener</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Start a thread to receive messages and multiplex to handles.</p> </li> </ul> Source code in <code>academy/exchange/__init__.py</code> <pre><code>def bind_as_client(\n    self,\n    *,\n    name: str | None = None,\n    start_listener: bool = True,\n) -&gt; ExchangeClient:\n    \"\"\"Bind exchange to a new client mailbox.\n\n    This method will create a new mailbox and enable this client to\n    message other entities on the exchange.\n\n    Args:\n        name: Display name of the client on the exchange.\n        start_listener: Start a thread to receive messages and multiplex\n            to handles.\n    \"\"\"\n    return self._bind(\n        mailbox_id=None,\n        name=name,\n        handler=None,\n        start_listener=start_listener,\n    )\n</code></pre>"},{"location":"api/exchange/thread/#academy.exchange.thread.ThreadExchangeFactory.bind_as_agent","title":"bind_as_agent","text":"<pre><code>bind_as_agent(\n    agent_id: AgentId[Any],\n    *,\n    name: str | None = None,\n    handler: Callable[[RequestMessage], None] | None = None\n) -&gt; ExchangeClient\n</code></pre> <p>Bind exchange to an agent mailbox.</p> <p>This method creates a exchange client bound to an agent ID. The agent ID must be previously created on the exchange.</p> <p>Parameters:</p> <ul> <li> <code>agent_id</code>               (<code>AgentId[Any]</code>)           \u2013            <p>ID of the mailbox to receive and send messages.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Display name of the client on the exchange.</p> </li> <li> <code>handler</code>               (<code>Callable[[RequestMessage], None] | None</code>, default:                   <code>None</code> )           \u2013            <p>Agent callback to process messages.</p> </li> </ul> Source code in <code>academy/exchange/__init__.py</code> <pre><code>def bind_as_agent(\n    self,\n    agent_id: AgentId[Any],\n    *,\n    name: str | None = None,\n    handler: Callable[[RequestMessage], None] | None = None,\n) -&gt; ExchangeClient:\n    \"\"\"Bind exchange to an agent mailbox.\n\n    This method creates a exchange client bound to an agent ID.\n    The agent ID must be previously created on the exchange.\n\n    Args:\n        agent_id: ID of the mailbox to receive and send messages.\n        name: Display name of the client on the exchange.\n        handler: Agent callback to process messages.\n    \"\"\"\n    return self._bind(\n        mailbox_id=agent_id,\n        name=name,\n        handler=handler,\n        start_listener=False,\n    )\n</code></pre>"},{"location":"api/exchange/thread/#academy.exchange.thread.ThreadExchangeClient","title":"ThreadExchangeClient","text":"<pre><code>ThreadExchangeClient(\n    exchange_state: ThreadExchangeState,\n    mailbox_id: EntityId | None = None,\n    *,\n    name: str | None = None,\n    handler: Callable[[RequestMessage], None] | None = None,\n    start_listener: bool\n)\n</code></pre> <p>               Bases: <code>ExchangeClient</code></p> <p>A thread exchange bound to a mailbox.</p> <p>A thread exchange can be used to pass messages between agents within a process.</p> <p>Parameters:</p> <ul> <li> <code>exchange_state</code>               (<code>ThreadExchangeState</code>)           \u2013            <p>The state of the queues used by the exchange</p> </li> <li> <code>mailbox_id</code>               (<code>EntityId | None</code>, default:                   <code>None</code> )           \u2013            <p>Identifier of the mailbox on the exchange. If there is not an id provided, the exchange will create a new client mailbox.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Display name of mailbox on exchange.</p> </li> <li> <code>handler</code>               (<code>Callable[[RequestMessage], None] | None</code>, default:                   <code>None</code> )           \u2013            <p>Callback to handler requests to this exchange.</p> </li> </ul> Source code in <code>academy/exchange/thread.py</code> <pre><code>def __init__(\n    self,\n    exchange_state: ThreadExchangeState,\n    mailbox_id: EntityId | None = None,\n    *,\n    name: str | None = None,\n    handler: Callable[[RequestMessage], None] | None = None,\n    start_listener: bool,\n):\n    self._state = exchange_state\n    super().__init__(\n        mailbox_id,\n        name=name,\n        handler=handler,\n        start_listener=start_listener,\n    )\n</code></pre>"},{"location":"api/exchange/thread/#academy.exchange.thread.ThreadExchangeClient.close","title":"close","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the exchange.</p> <p>This will leave the queues in the state open.</p> Source code in <code>academy/exchange/thread.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Close the exchange.\n\n    This will leave the queues in the state open.\n    \"\"\"\n    super().close()\n    logger.debug('Closed exchange (%s)', self)\n</code></pre>"},{"location":"api/exchange/thread/#academy.exchange.thread.ThreadExchangeClient.status","title":"status","text":"<pre><code>status(mailbox_id: EntityId) -&gt; MailboxStatus\n</code></pre> <p>Check status of mailbox on exchange.</p> Source code in <code>academy/exchange/thread.py</code> <pre><code>def status(self, mailbox_id: EntityId) -&gt; MailboxStatus:\n    \"\"\"Check status of mailbox on exchange.\"\"\"\n    if mailbox_id not in self._state.queues:\n        return MailboxStatus.MISSING\n    if self._state.queues[mailbox_id].closed():\n        return MailboxStatus.TERMINATED\n    return MailboxStatus.ACTIVE\n</code></pre>"},{"location":"api/exchange/thread/#academy.exchange.thread.ThreadExchangeClient.register_agent","title":"register_agent","text":"<pre><code>register_agent(\n    behavior: type[BehaviorT],\n    *,\n    agent_id: AgentId[BehaviorT] | None = None,\n    name: str | None = None\n) -&gt; AgentId[BehaviorT]\n</code></pre> <p>Create a new agent identifier and associated mailbox.</p> <p>Parameters:</p> <ul> <li> <code>behavior</code>               (<code>type[BehaviorT]</code>)           \u2013            <p>Type of the behavior this agent will implement.</p> </li> <li> <code>agent_id</code>               (<code>AgentId[BehaviorT] | None</code>, default:                   <code>None</code> )           \u2013            <p>Specify the ID of the agent. Randomly generated default.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional human-readable name for the agent. Ignored if <code>agent_id</code> is provided.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AgentId[BehaviorT]</code>           \u2013            <p>Unique identifier for the agent's mailbox.</p> </li> </ul> Source code in <code>academy/exchange/thread.py</code> <pre><code>def register_agent(\n    self,\n    behavior: type[BehaviorT],\n    *,\n    agent_id: AgentId[BehaviorT] | None = None,\n    name: str | None = None,\n) -&gt; AgentId[BehaviorT]:\n    \"\"\"Create a new agent identifier and associated mailbox.\n\n    Args:\n        behavior: Type of the behavior this agent will implement.\n        agent_id: Specify the ID of the agent. Randomly generated\n            default.\n        name: Optional human-readable name for the agent. Ignored if\n            `agent_id` is provided.\n\n    Returns:\n        Unique identifier for the agent's mailbox.\n    \"\"\"\n    aid = AgentId.new(name=name) if agent_id is None else agent_id\n    if aid not in self._state.queues or self._state.queues[aid].closed():\n        self._state.queues[aid] = Queue()\n        self._state.behaviors[aid] = behavior\n        logger.debug('Registered %s in %s', aid, self)\n    return aid\n</code></pre>"},{"location":"api/exchange/thread/#academy.exchange.thread.ThreadExchangeClient.terminate","title":"terminate","text":"<pre><code>terminate(uid: EntityId) -&gt; None\n</code></pre> <p>Close the mailbox for an entity from the exchange.</p> Note <p>This method is a no-op if the mailbox does not exists.</p> <p>Parameters:</p> <ul> <li> <code>uid</code>               (<code>EntityId</code>)           \u2013            <p>Entity identifier of the mailbox to close.</p> </li> </ul> Source code in <code>academy/exchange/thread.py</code> <pre><code>def terminate(self, uid: EntityId) -&gt; None:\n    \"\"\"Close the mailbox for an entity from the exchange.\n\n    Note:\n        This method is a no-op if the mailbox does not exists.\n\n    Args:\n        uid: Entity identifier of the mailbox to close.\n    \"\"\"\n    queue = self._state.queues.get(uid, None)\n    if queue is not None and not queue.closed():\n        queue.close()\n        if isinstance(uid, AgentId):\n            self._state.behaviors.pop(uid, None)\n        logger.debug('Closed mailbox for %s (%s)', uid, self)\n</code></pre>"},{"location":"api/exchange/thread/#academy.exchange.thread.ThreadExchangeClient.discover","title":"discover","text":"<pre><code>discover(\n    behavior: type[Behavior],\n    *,\n    allow_subclasses: bool = True\n) -&gt; tuple[AgentId[Any], ...]\n</code></pre> <p>Discover peer agents with a given behavior.</p> <p>Parameters:</p> <ul> <li> <code>behavior</code>               (<code>type[Behavior]</code>)           \u2013            <p>Behavior type of interest.</p> </li> <li> <code>allow_subclasses</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Return agents implementing subclasses of the behavior.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[AgentId[Any], ...]</code>           \u2013            <p>Tuple of agent IDs implementing the behavior.</p> </li> </ul> Source code in <code>academy/exchange/thread.py</code> <pre><code>def discover(\n    self,\n    behavior: type[Behavior],\n    *,\n    allow_subclasses: bool = True,\n) -&gt; tuple[AgentId[Any], ...]:\n    \"\"\"Discover peer agents with a given behavior.\n\n    Args:\n        behavior: Behavior type of interest.\n        allow_subclasses: Return agents implementing subclasses of the\n            behavior.\n\n    Returns:\n        Tuple of agent IDs implementing the behavior.\n    \"\"\"\n    found: list[AgentId[Any]] = []\n    for aid, type_ in self._state.behaviors.items():\n        if behavior is type_ or (\n            allow_subclasses and issubclass(type_, behavior)\n        ):\n            found.append(aid)\n    alive = tuple(\n        aid for aid in found if not self._state.queues[aid].closed()\n    )\n    return alive\n</code></pre>"},{"location":"api/exchange/thread/#academy.exchange.thread.ThreadExchangeClient.send","title":"send","text":"<pre><code>send(uid: EntityId, message: Message) -&gt; None\n</code></pre> <p>Send a message to a mailbox.</p> <p>Parameters:</p> <ul> <li> <code>uid</code>               (<code>EntityId</code>)           \u2013            <p>Destination address of the message.</p> </li> <li> <code>message</code>               (<code>Message</code>)           \u2013            <p>Message to send.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BadEntityIdError</code>             \u2013            <p>if a mailbox for <code>uid</code> does not exist.</p> </li> <li> <code>MailboxClosedError</code>             \u2013            <p>if the mailbox was closed.</p> </li> </ul> Source code in <code>academy/exchange/thread.py</code> <pre><code>def send(self, uid: EntityId, message: Message) -&gt; None:\n    \"\"\"Send a message to a mailbox.\n\n    Args:\n        uid: Destination address of the message.\n        message: Message to send.\n\n    Raises:\n        BadEntityIdError: if a mailbox for `uid` does not exist.\n        MailboxClosedError: if the mailbox was closed.\n    \"\"\"\n    queue = self._state.queues.get(uid, None)\n    if queue is None:\n        raise BadEntityIdError(uid)\n    try:\n        queue.put(message)\n        logger.debug('Sent %s to %s', type(message).__name__, uid)\n    except QueueClosedError as e:\n        raise MailboxClosedError(uid) from e\n</code></pre>"},{"location":"api/exchange/thread/#academy.exchange.thread.ThreadExchangeClient.recv","title":"recv","text":"<pre><code>recv(timeout: float | None = None) -&gt; Message\n</code></pre> <p>Receive the next message in the mailbox.</p> <p>This blocks until the next message is received or the mailbox is closed.</p> <p>Parameters:</p> <ul> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional timeout in seconds to wait for the next message. If <code>None</code>, the default, block forever until the next message or the mailbox is closed.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>MailboxClosedError</code>             \u2013            <p>if the mailbox was closed.</p> </li> <li> <code>TimeoutError</code>             \u2013            <p>if a <code>timeout</code> was specified and exceeded.</p> </li> </ul> Source code in <code>academy/exchange/thread.py</code> <pre><code>def recv(self, timeout: float | None = None) -&gt; Message:\n    \"\"\"Receive the next message in the mailbox.\n\n    This blocks until the next message is received or the mailbox\n    is closed.\n\n    Args:\n        timeout: Optional timeout in seconds to wait for the next\n            message. If `None`, the default, block forever until the\n            next message or the mailbox is closed.\n\n    Raises:\n        MailboxClosedError: if the mailbox was closed.\n        TimeoutError: if a `timeout` was specified and exceeded.\n    \"\"\"\n    try:\n        message = self._state.queues[self.mailbox_id].get(timeout=timeout)\n        logger.debug(\n            'Received %s to %s',\n            type(message).__name__,\n            self.mailbox_id,\n        )\n        return message\n    except QueueClosedError as e:\n        raise MailboxClosedError(self.mailbox_id) from e\n</code></pre>"},{"location":"api/exchange/thread/#academy.exchange.thread.ThreadExchangeClient.clone","title":"clone","text":"<pre><code>clone() -&gt; ThreadExchangeFactory\n</code></pre> <p>Shallow copy exchange to new, unbound version.</p> Source code in <code>academy/exchange/thread.py</code> <pre><code>def clone(self) -&gt; ThreadExchangeFactory:\n    \"\"\"Shallow copy exchange to new, unbound version.\"\"\"\n    return ThreadExchangeFactory(self._state)\n</code></pre>"},{"location":"api/exchange/thread/#academy.exchange.thread.ThreadExchangeClient.get_handle","title":"get_handle","text":"<pre><code>get_handle(\n    aid: AgentId[BehaviorT],\n) -&gt; BoundRemoteHandle[BehaviorT]\n</code></pre> <p>Create a new handle to an agent.</p> <p>A handle enables a client to invoke actions on the agent.</p> Note <p>It is not possible to create a handle to a client since a handle is essentially a new client of a specific agent.</p> <p>Parameters:</p> <ul> <li> <code>aid</code>               (<code>AgentId[BehaviorT]</code>)           \u2013            <p>EntityId of the agent to create an handle to.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>BoundRemoteHandle[BehaviorT]</code>           \u2013            <p>Handle to the agent.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>if <code>aid</code> is not an instance of <code>AgentId</code>.</p> </li> </ul> Source code in <code>academy/exchange/__init__.py</code> <pre><code>def get_handle(\n    self,\n    aid: AgentId[BehaviorT],\n) -&gt; BoundRemoteHandle[BehaviorT]:\n    \"\"\"Create a new handle to an agent.\n\n    A handle enables a client to invoke actions on the agent.\n\n    Note:\n        It is not possible to create a handle to a client since a handle\n        is essentially a new client of a specific agent.\n\n    Args:\n        aid: EntityId of the agent to create an handle to.\n\n    Returns:\n        Handle to the agent.\n\n    Raises:\n        TypeError: if `aid` is not an instance of\n            [`AgentId`][academy.identifier.AgentId].\n    \"\"\"\n    if not isinstance(aid, AgentId):\n        raise TypeError(\n            f'Handle must be created from an {AgentId.__name__} '\n            f'but got identifier with type {type(aid).__name__}.',\n        )\n\n    hdl = BoundRemoteHandle(self, aid, self.mailbox_id)\n    self.bound_handles[hdl.handle_id] = hdl\n    return hdl\n</code></pre>"},{"location":"api/exchange/thread/#academy.exchange.thread.ThreadExchangeClient.close_bound_handles","title":"close_bound_handles","text":"<pre><code>close_bound_handles() -&gt; None\n</code></pre> <p>Close all handles bound to this mailbox.</p> Source code in <code>academy/exchange/__init__.py</code> <pre><code>def close_bound_handles(self) -&gt; None:\n    \"\"\"Close all handles bound to this mailbox.\"\"\"\n    for key in tuple(self.bound_handles):\n        handle = self.bound_handles.pop(key)\n        handle.close(wait_futures=False)\n</code></pre>"},{"location":"api/exchange/thread/#academy.exchange.thread.ThreadExchangeClient.listen","title":"listen","text":"<pre><code>listen() -&gt; None\n</code></pre> <p>Listen for new messages in the mailbox and process them.</p> <p>Request messages are processed via the <code>request_handler</code>, and response messages are dispatched to the handle that created the corresponding request.</p> Warning <p>This method loops forever, until the mailbox is closed. Thus this method is typically run inside of a thread.</p> Note <p>Response messages intended for a handle that does not exist will be logged and discarded.</p> Source code in <code>academy/exchange/__init__.py</code> <pre><code>def listen(self) -&gt; None:\n    \"\"\"Listen for new messages in the mailbox and process them.\n\n    Request messages are processed via the `request_handler`, and response\n    messages are dispatched to the handle that created the corresponding\n    request.\n\n    Warning:\n        This method loops forever, until the mailbox is closed. Thus this\n        method is typically run inside of a thread.\n\n    Note:\n        Response messages intended for a handle that does not exist\n        will be logged and discarded.\n    \"\"\"\n    try:\n        while True:\n            message = self.recv()\n            self._message_handler(message)\n    except MailboxClosedError:\n        pass\n</code></pre>"},{"location":"api/exchange/cloud/","title":"academy.exchange.cloud","text":"<code>academy/exchange/cloud/__init__.py</code>"},{"location":"api/exchange/cloud/authenticate/","title":"academy.exchange.cloud.authenticate","text":"<code>academy/exchange/cloud/authenticate.py</code> <p>Authenticate users from request headers.</p>"},{"location":"api/exchange/cloud/authenticate/#academy.exchange.cloud.authenticate.Authenticator","title":"Authenticator","text":"<p>               Bases: <code>Protocol</code></p> <p>Authenticate users from request headers.</p>"},{"location":"api/exchange/cloud/authenticate/#academy.exchange.cloud.authenticate.Authenticator.authenticate_user","title":"authenticate_user","text":"<pre><code>authenticate_user(headers: Mapping[str, str]) -&gt; UUID\n</code></pre> <p>Authenticate user from request headers.</p> Warning <p>This method must be thread safe!</p> <p>Parameters:</p> <ul> <li> <code>headers</code>               (<code>Mapping[str, str]</code>)           \u2013            <p>Request headers.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>UUID</code>           \u2013            <p>A user id upon authentication success.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ForbiddenError</code>             \u2013            <p>user is authenticated but is missing permissions or accessing forbidden resources.</p> </li> <li> <code>UnauthorizedError</code>             \u2013            <p>user authentication fails.</p> </li> </ul> Source code in <code>academy/exchange/cloud/authenticate.py</code> <pre><code>def authenticate_user(self, headers: Mapping[str, str]) -&gt; uuid.UUID:\n    \"\"\"Authenticate user from request headers.\n\n    Warning:\n        This method must be thread safe!\n\n    Args:\n        headers: Request headers.\n\n    Returns:\n        A user id upon authentication success.\n\n    Raises:\n        ForbiddenError: user is authenticated but is missing permissions\n            or accessing forbidden resources.\n        UnauthorizedError: user authentication fails.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/exchange/cloud/authenticate/#academy.exchange.cloud.authenticate.NullAuthenticator","title":"NullAuthenticator","text":"<p>Authenticator that implements no authentication.</p>"},{"location":"api/exchange/cloud/authenticate/#academy.exchange.cloud.authenticate.NullAuthenticator.authenticate_user","title":"authenticate_user","text":"<pre><code>authenticate_user(headers: Mapping[str, str]) -&gt; UUID\n</code></pre> <p>Authenticate user from request headers.</p> <p>Parameters:</p> <ul> <li> <code>headers</code>               (<code>Mapping[str, str]</code>)           \u2013            <p>Request headers.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>UUID</code>           \u2013            <p>Null user regardless of provided headers.</p> </li> </ul> Source code in <code>academy/exchange/cloud/authenticate.py</code> <pre><code>def authenticate_user(self, headers: Mapping[str, str]) -&gt; uuid.UUID:\n    \"\"\"Authenticate user from request headers.\n\n    Args:\n        headers: Request headers.\n\n    Returns:\n        Null user regardless of provided headers.\n    \"\"\"\n    return uuid.UUID(int=0)\n</code></pre>"},{"location":"api/exchange/cloud/authenticate/#academy.exchange.cloud.authenticate.GlobusAuthenticator","title":"GlobusAuthenticator","text":"<pre><code>GlobusAuthenticator(\n    client_id: str | None = None,\n    client_secret: str | None = None,\n    *,\n    audience: str = resource_server,\n    auth_client: ConfidentialAppAuthClient | None = None\n)\n</code></pre> <p>Globus Auth authorizer.</p> <p>Parameters:</p> <ul> <li> <code>client_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Globus application client ID. If either <code>client_id</code> or <code>client_secret</code> is <code>None</code>, the values will be read from the environment variables as described in <code>get_confidential_app_auth_client</code>. Ignored if <code>auth_client</code> is provided.</p> </li> <li> <code>client_secret</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Globus application client secret. See <code>client_id</code> for details. Ignored if <code>auth_client</code> is provided.</p> </li> <li> <code>audience</code>               (<code>str</code>, default:                   <code>resource_server</code> )           \u2013            <p>Intended audience of the token. This should typically be the resource server of the the token was issued for. E.g., the UUID of the ProxyStore Relay Server application.</p> </li> <li> <code>auth_client</code>               (<code>ConfidentialAppAuthClient | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional confidential application authentication client which is used for introspecting client tokens.</p> </li> </ul> Source code in <code>academy/exchange/cloud/authenticate.py</code> <pre><code>def __init__(\n    self,\n    client_id: str | None = None,\n    client_secret: str | None = None,\n    *,\n    audience: str = AcademyExchangeScopes.resource_server,\n    auth_client: globus_sdk.ConfidentialAppAuthClient | None = None,\n) -&gt; None:\n    self.auth_client = (\n        globus_sdk.ConfidentialAppAuthClient(\n            client_id=str(client_id),\n            client_secret=str(client_secret),\n        )\n        if auth_client is None\n        else auth_client\n    )\n    self.auth_client_lock = Lock()\n    self.audience = audience\n</code></pre>"},{"location":"api/exchange/cloud/authenticate/#academy.exchange.cloud.authenticate.GlobusAuthenticator.authenticate_user","title":"authenticate_user","text":"<pre><code>authenticate_user(headers: Mapping[str, str]) -&gt; UUID\n</code></pre> <p>Authenticate a Globus Auth user from request header.</p> <p>This follows from the Globus Sample Data Portal example.</p> <p>The underlying auth client is not thread safe, but this method is made thread safe using a lock.</p> <p>Parameters:</p> <ul> <li> <code>headers</code>               (<code>Mapping[str, str]</code>)           \u2013            <p>Request headers to extract tokens from.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>UUID</code>           \u2013            <p>Globus Auth identity returned via             token introspection.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>UnauthorizedError</code>             \u2013            <p>if the authorization header is missing or the header is malformed.</p> </li> <li> <code>ForbiddenError</code>             \u2013            <p>if the tokens have expired or been revoked.</p> </li> <li> <code>ForbiddenError</code>             \u2013            <p>if <code>audience</code> is not included in the token's audience.</p> </li> </ul> Source code in <code>academy/exchange/cloud/authenticate.py</code> <pre><code>def authenticate_user(self, headers: Mapping[str, str]) -&gt; uuid.UUID:\n    \"\"\"Authenticate a Globus Auth user from request header.\n\n    This follows from the [Globus Sample Data Portal](https://github.com/globus/globus-sample-data-portal/blob/30e30cd418ee9b103e04916e19deb9902d3aafd8/service/decorators.py)\n    example.\n\n    The underlying auth client is not thread safe, but this method is made\n    thread safe using a lock.\n\n    Args:\n        headers: Request headers to extract tokens from.\n\n    Returns:\n        Globus Auth identity returned via \\\n        [token introspection](https://docs.globus.org/api/auth/reference/#token-introspect).\n\n    Raises:\n        UnauthorizedError: if the authorization header is missing or\n            the header is malformed.\n        ForbiddenError: if the tokens have expired or been revoked.\n        ForbiddenError: if `audience` is not included in the token's\n            audience.\n    \"\"\"\n    token = get_token_from_headers(headers)\n    with self.auth_client_lock:\n        token_meta = self.auth_client.oauth2_token_introspect(token)\n\n    if not token_meta.get('active'):\n        raise ForbiddenError('Token is expired or has been revoked.')\n\n    if self.audience is not None and self.audience not in token_meta.get(\n        'aud',\n        [],\n    ):\n        raise ForbiddenError(\n            f'Token audience does not include \"{self.audience}\". This '\n            'could result in a confused deputy attack. Ensure the correct '\n            'scopes are requested when the token is created.',\n        )\n\n    return uuid.UUID(token_meta.get('client_id'))\n</code></pre>"},{"location":"api/exchange/cloud/authenticate/#academy.exchange.cloud.authenticate.get_authenticator","title":"get_authenticator","text":"<pre><code>get_authenticator(\n    config: ExchangeAuthConfig,\n) -&gt; Authenticator\n</code></pre> <p>Create an authenticator from a configuration.</p> <p>Parameters:</p> <ul> <li> <code>config</code>               (<code>ExchangeAuthConfig</code>)           \u2013            <p>Configuration.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Authenticator</code>           \u2013            <p>Authenticator.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>if the authentication method in the config is unknown.</p> </li> </ul> Source code in <code>academy/exchange/cloud/authenticate.py</code> <pre><code>def get_authenticator(config: ExchangeAuthConfig) -&gt; Authenticator:\n    \"\"\"Create an authenticator from a configuration.\n\n    Args:\n        config: Configuration.\n\n    Returns:\n        Authenticator.\n\n    Raises:\n        ValueError: if the authentication method in the config is unknown.\n    \"\"\"\n    if config.method is None:\n        return NullAuthenticator()\n    elif config.method == 'globus':\n        return GlobusAuthenticator(**config.kwargs)\n    else:\n        raise ValueError(f'Unknown authentication method \"{config.method}.\"')\n</code></pre>"},{"location":"api/exchange/cloud/authenticate/#academy.exchange.cloud.authenticate.get_token_from_headers","title":"get_token_from_headers","text":"<pre><code>get_token_from_headers(headers: Mapping[str, str]) -&gt; str\n</code></pre> <p>Extract token from websockets headers.</p> <p>The header is expected to have the format <code>Authorization: Bearer &lt;TOKEN&gt;</code>.</p> <p>Parameters:</p> <ul> <li> <code>headers</code>               (<code>Mapping[str, str]</code>)           \u2013            <p>Request headers to extract tokens from.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>String token.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>UnauthorizedError</code>             \u2013            <p>if the authorization header is missing.</p> </li> <li> <code>UnauthorizedError</code>             \u2013            <p>if the authorization header is malformed.</p> </li> </ul> Source code in <code>academy/exchange/cloud/authenticate.py</code> <pre><code>def get_token_from_headers(headers: Mapping[str, str]) -&gt; str:\n    \"\"\"Extract token from websockets headers.\n\n    The header is expected to have the format `Authorization: Bearer &lt;TOKEN&gt;`.\n\n    Args:\n         headers: Request headers to extract tokens from.\n\n    Returns:\n        String token.\n\n    Raises:\n        UnauthorizedError: if the authorization header is missing.\n        UnauthorizedError: if the authorization header is malformed.\n    \"\"\"\n    if 'Authorization' not in headers:\n        raise UnauthorizedError(\n            'Request headers are missing authorization header.',\n        )\n\n    auth_header_parts = headers['Authorization'].split(' ')\n\n    if len(auth_header_parts) != 2 or auth_header_parts[0] != 'Bearer':  # noqa: PLR2004\n        raise UnauthorizedError(\n            'Bearer token in authorization header is malformed.',\n        )\n\n    return auth_header_parts[1]\n</code></pre>"},{"location":"api/exchange/cloud/client/","title":"academy.exchange.cloud.client","text":"<code>academy/exchange/cloud/client.py</code>"},{"location":"api/exchange/cloud/client/#academy.exchange.cloud.client.HttpExchangeFactory","title":"HttpExchangeFactory","text":"<pre><code>HttpExchangeFactory(\n    host: str,\n    port: int,\n    additional_headers: dict[str, str] | None = None,\n    scheme: Literal[\"http\", \"https\"] = \"http\",\n    ssl_verify: str | bool | None = None,\n)\n</code></pre> <p>               Bases: <code>ExchangeFactory</code></p> <p>Http exchange client.</p> <p>Parameters:</p> <ul> <li> <code>host</code>               (<code>str</code>)           \u2013            <p>Host name of the exchange server.</p> </li> <li> <code>port</code>               (<code>int</code>)           \u2013            <p>Port of the exchange server.</p> </li> <li> <code>additional_headers</code>               (<code>dict[str, str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Any other information necessary to communicate with the exchange. Used for passing the Globus bearer token</p> </li> <li> <code>scheme</code>               (<code>Literal['http', 'https']</code>, default:                   <code>'http'</code> )           \u2013            <p>HTTP scheme, non-protected \"http\" by default.</p> </li> <li> <code>ssl_verify</code>               (<code>str | bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Same as requests.Session.verify. If the server's TLS certificate should be validated. Should be true if using HTTPS Only set to false for testing or local development.</p> </li> </ul> Source code in <code>academy/exchange/cloud/client.py</code> <pre><code>def __init__(\n    self,\n    host: str,\n    port: int,\n    additional_headers: dict[str, str] | None = None,\n    scheme: Literal['http', 'https'] = 'http',\n    ssl_verify: str | bool | None = None,\n) -&gt; None:\n    self.host = host\n    self.port = port\n    self.additional_headers = additional_headers\n    self.scheme = scheme\n    self.ssl_verify = ssl_verify\n</code></pre>"},{"location":"api/exchange/cloud/client/#academy.exchange.cloud.client.HttpExchangeFactory.bind_as_client","title":"bind_as_client","text":"<pre><code>bind_as_client(\n    *, name: str | None = None, start_listener: bool = True\n) -&gt; ExchangeClient\n</code></pre> <p>Bind exchange to a new client mailbox.</p> <p>This method will create a new mailbox and enable this client to message other entities on the exchange.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Display name of the client on the exchange.</p> </li> <li> <code>start_listener</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Start a thread to receive messages and multiplex to handles.</p> </li> </ul> Source code in <code>academy/exchange/__init__.py</code> <pre><code>def bind_as_client(\n    self,\n    *,\n    name: str | None = None,\n    start_listener: bool = True,\n) -&gt; ExchangeClient:\n    \"\"\"Bind exchange to a new client mailbox.\n\n    This method will create a new mailbox and enable this client to\n    message other entities on the exchange.\n\n    Args:\n        name: Display name of the client on the exchange.\n        start_listener: Start a thread to receive messages and multiplex\n            to handles.\n    \"\"\"\n    return self._bind(\n        mailbox_id=None,\n        name=name,\n        handler=None,\n        start_listener=start_listener,\n    )\n</code></pre>"},{"location":"api/exchange/cloud/client/#academy.exchange.cloud.client.HttpExchangeFactory.bind_as_agent","title":"bind_as_agent","text":"<pre><code>bind_as_agent(\n    agent_id: AgentId[Any],\n    *,\n    name: str | None = None,\n    handler: Callable[[RequestMessage], None] | None = None\n) -&gt; ExchangeClient\n</code></pre> <p>Bind exchange to an agent mailbox.</p> <p>This method creates a exchange client bound to an agent ID. The agent ID must be previously created on the exchange.</p> <p>Parameters:</p> <ul> <li> <code>agent_id</code>               (<code>AgentId[Any]</code>)           \u2013            <p>ID of the mailbox to receive and send messages.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Display name of the client on the exchange.</p> </li> <li> <code>handler</code>               (<code>Callable[[RequestMessage], None] | None</code>, default:                   <code>None</code> )           \u2013            <p>Agent callback to process messages.</p> </li> </ul> Source code in <code>academy/exchange/__init__.py</code> <pre><code>def bind_as_agent(\n    self,\n    agent_id: AgentId[Any],\n    *,\n    name: str | None = None,\n    handler: Callable[[RequestMessage], None] | None = None,\n) -&gt; ExchangeClient:\n    \"\"\"Bind exchange to an agent mailbox.\n\n    This method creates a exchange client bound to an agent ID.\n    The agent ID must be previously created on the exchange.\n\n    Args:\n        agent_id: ID of the mailbox to receive and send messages.\n        name: Display name of the client on the exchange.\n        handler: Agent callback to process messages.\n    \"\"\"\n    return self._bind(\n        mailbox_id=agent_id,\n        name=name,\n        handler=handler,\n        start_listener=False,\n    )\n</code></pre>"},{"location":"api/exchange/cloud/client/#academy.exchange.cloud.client.HttpExchangeClient","title":"HttpExchangeClient","text":"<pre><code>HttpExchangeClient(\n    unbound: HttpExchangeFactory,\n    mailbox_id: EntityId | None = None,\n    *,\n    name: str | None = None,\n    handler: Callable[[RequestMessage], None] | None = None,\n    start_listener: bool\n)\n</code></pre> <p>               Bases: <code>ExchangeClient</code></p> <p>Http exchange client.</p> <p>Parameters:</p> <ul> <li> <code>unbound</code>               (<code>HttpExchangeFactory</code>)           \u2013            <p>Connection information for remote exchange.</p> </li> <li> <code>mailbox_id</code>               (<code>EntityId | None</code>, default:                   <code>None</code> )           \u2013            <p>Identifier of the mailbox on the exchange. If there is not an id provided, the exchange will create a new client mail- box.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Display name of mailbox on exchange.</p> </li> <li> <code>handler</code>               (<code>Callable[[RequestMessage], None] | None</code>, default:                   <code>None</code> )           \u2013            <p>Callback to handler requests to this exchange.</p> </li> <li> <code>start_listener</code>               (<code>bool</code>)           \u2013            <p>Start the listener thread to multiplex messages to handles.</p> </li> </ul> Source code in <code>academy/exchange/cloud/client.py</code> <pre><code>def __init__(\n    self,\n    unbound: HttpExchangeFactory,\n    mailbox_id: EntityId | None = None,\n    *,\n    name: str | None = None,\n    handler: Callable[[RequestMessage], None] | None = None,\n    start_listener: bool,\n) -&gt; None:\n    self.host = unbound.host\n    self.port = unbound.port\n    self.additional_headers = unbound.additional_headers\n    self.scheme = unbound.scheme\n    self.ssl_verify = unbound.ssl_verify\n\n    self._session = requests.Session()\n    if self.additional_headers is not None:\n        self._session.headers.update(self.additional_headers)\n\n    if self.ssl_verify is not None:\n        self._session.verify = self.ssl_verify\n\n    self._mailbox_url = f'{self.scheme}://{self.host}:{self.port}/mailbox'\n    self._message_url = f'{self.scheme}://{self.host}:{self.port}/message'\n    self._discover_url = (\n        f'{self.scheme}://{self.host}:{self.port}/discover'\n    )\n\n    super().__init__(\n        mailbox_id,\n        name=name,\n        handler=handler,\n        start_listener=start_listener,\n    )\n</code></pre>"},{"location":"api/exchange/cloud/client/#academy.exchange.cloud.client.HttpExchangeClient.close","title":"close","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close this exchange client.</p> Source code in <code>academy/exchange/cloud/client.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Close this exchange client.\"\"\"\n    super().close()\n\n    self._session.close()\n    logger.debug('Closed exchange (%s)', self)\n</code></pre>"},{"location":"api/exchange/cloud/client/#academy.exchange.cloud.client.HttpExchangeClient.status","title":"status","text":"<pre><code>status(mailbox_id: EntityId) -&gt; MailboxStatus\n</code></pre> <p>Check status of mailbox on exchange.</p> Source code in <code>academy/exchange/cloud/client.py</code> <pre><code>def status(self, mailbox_id: EntityId) -&gt; MailboxStatus:\n    \"\"\"Check status of mailbox on exchange.\"\"\"\n    # TODO: Do we need to create a new endpoint to check status?\n    try:\n        self.send(\n            mailbox_id,\n            PingRequest(\n                src=self.mailbox_id,\n                dest=mailbox_id,\n            ),\n        )\n    except BadEntityIdError:\n        return MailboxStatus.MISSING\n    except MailboxClosedError:\n        return MailboxStatus.TERMINATED\n\n    return MailboxStatus.ACTIVE\n</code></pre>"},{"location":"api/exchange/cloud/client/#academy.exchange.cloud.client.HttpExchangeClient.register_agent","title":"register_agent","text":"<pre><code>register_agent(\n    behavior: type[BehaviorT],\n    *,\n    agent_id: AgentId[BehaviorT] | None = None,\n    name: str | None = None\n) -&gt; AgentId[BehaviorT]\n</code></pre> <p>Create a new agent identifier and associated mailbox.</p> <p>Parameters:</p> <ul> <li> <code>behavior</code>               (<code>type[BehaviorT]</code>)           \u2013            <p>Type of the behavior this agent will implement.</p> </li> <li> <code>agent_id</code>               (<code>AgentId[BehaviorT] | None</code>, default:                   <code>None</code> )           \u2013            <p>Specify the ID of the agent. Randomly generated default.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional human-readable name for the agent. Ignored if <code>agent_id</code> is provided.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AgentId[BehaviorT]</code>           \u2013            <p>Unique identifier for the agent's mailbox.</p> </li> </ul> Source code in <code>academy/exchange/cloud/client.py</code> <pre><code>def register_agent(\n    self,\n    behavior: type[BehaviorT],\n    *,\n    agent_id: AgentId[BehaviorT] | None = None,\n    name: str | None = None,\n) -&gt; AgentId[BehaviorT]:\n    \"\"\"Create a new agent identifier and associated mailbox.\n\n    Args:\n        behavior: Type of the behavior this agent will implement.\n        agent_id: Specify the ID of the agent. Randomly generated\n            default.\n        name: Optional human-readable name for the agent. Ignored if\n            `agent_id` is provided.\n\n    Returns:\n        Unique identifier for the agent's mailbox.\n    \"\"\"\n    aid = AgentId.new(name=name) if agent_id is None else agent_id\n    response = self._session.post(\n        self._mailbox_url,\n        json={\n            'mailbox': aid.model_dump_json(),\n            'behavior': ','.join(behavior.behavior_mro()),\n        },\n    )\n    response.raise_for_status()\n    logger.debug('Registered %s in %s', aid, self)\n    return aid\n</code></pre>"},{"location":"api/exchange/cloud/client/#academy.exchange.cloud.client.HttpExchangeClient.terminate","title":"terminate","text":"<pre><code>terminate(uid: EntityId) -&gt; None\n</code></pre> <p>Close the mailbox for an entity from the exchange.</p> Note <p>This method is a no-op if the mailbox does not exists.</p> <p>Parameters:</p> <ul> <li> <code>uid</code>               (<code>EntityId</code>)           \u2013            <p>Entity identifier of the mailbox to close.</p> </li> </ul> Source code in <code>academy/exchange/cloud/client.py</code> <pre><code>def terminate(self, uid: EntityId) -&gt; None:\n    \"\"\"Close the mailbox for an entity from the exchange.\n\n    Note:\n        This method is a no-op if the mailbox does not exists.\n\n    Args:\n        uid: Entity identifier of the mailbox to close.\n    \"\"\"\n    response = self._session.delete(\n        self._mailbox_url,\n        json={'mailbox': uid.model_dump_json()},\n    )\n    response.raise_for_status()\n    logger.debug('Closed mailbox for %s (%s)', uid, self)\n</code></pre>"},{"location":"api/exchange/cloud/client/#academy.exchange.cloud.client.HttpExchangeClient.discover","title":"discover","text":"<pre><code>discover(\n    behavior: type[Behavior],\n    *,\n    allow_subclasses: bool = True\n) -&gt; tuple[AgentId[Any], ...]\n</code></pre> <p>Discover peer agents with a given behavior.</p> Warning <p>Discoverability is not implemented on the HTTP exchange.</p> <p>Parameters:</p> <ul> <li> <code>behavior</code>               (<code>type[Behavior]</code>)           \u2013            <p>Behavior type of interest.</p> </li> <li> <code>allow_subclasses</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Return agents implementing subclasses of the behavior.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[AgentId[Any], ...]</code>           \u2013            <p>Tuple of agent IDs implementing the behavior.</p> </li> </ul> Source code in <code>academy/exchange/cloud/client.py</code> <pre><code>def discover(\n    self,\n    behavior: type[Behavior],\n    *,\n    allow_subclasses: bool = True,\n) -&gt; tuple[AgentId[Any], ...]:\n    \"\"\"Discover peer agents with a given behavior.\n\n    Warning:\n        Discoverability is not implemented on the HTTP exchange.\n\n    Args:\n        behavior: Behavior type of interest.\n        allow_subclasses: Return agents implementing subclasses of the\n            behavior.\n\n    Returns:\n        Tuple of agent IDs implementing the behavior.\n    \"\"\"\n    behavior_str = f'{behavior.__module__}.{behavior.__name__}'\n    response = self._session.get(\n        self._discover_url,\n        json={\n            'behavior': behavior_str,\n            'allow_subclasses': allow_subclasses,\n        },\n    )\n    response.raise_for_status()\n    agent_ids = [\n        aid\n        for aid in response.json()['agent_ids'].split(',')\n        if len(aid) &gt; 0\n    ]\n    return tuple(AgentId(uid=uuid.UUID(aid)) for aid in agent_ids)\n</code></pre>"},{"location":"api/exchange/cloud/client/#academy.exchange.cloud.client.HttpExchangeClient.send","title":"send","text":"<pre><code>send(uid: EntityId, message: Message) -&gt; None\n</code></pre> <p>Send a message to a mailbox.</p> <p>Parameters:</p> <ul> <li> <code>uid</code>               (<code>EntityId</code>)           \u2013            <p>Destination address of the message.</p> </li> <li> <code>message</code>               (<code>Message</code>)           \u2013            <p>Message to send.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BadEntityIdError</code>             \u2013            <p>if a mailbox for <code>uid</code> does not exist.</p> </li> <li> <code>MailboxClosedError</code>             \u2013            <p>if the mailbox was closed.</p> </li> </ul> Source code in <code>academy/exchange/cloud/client.py</code> <pre><code>def send(self, uid: EntityId, message: Message) -&gt; None:\n    \"\"\"Send a message to a mailbox.\n\n    Args:\n        uid: Destination address of the message.\n        message: Message to send.\n\n    Raises:\n        BadEntityIdError: if a mailbox for `uid` does not exist.\n        MailboxClosedError: if the mailbox was closed.\n    \"\"\"\n    response = self._session.put(\n        self._message_url,\n        json={'message': message.model_dump_json()},\n    )\n    if response.status_code == _NOT_FOUND_CODE:\n        raise BadEntityIdError(uid)\n    elif response.status_code == _FORBIDDEN_CODE:\n        raise MailboxClosedError(uid)\n    response.raise_for_status()\n    logger.debug('Sent %s to %s', type(message).__name__, uid)\n</code></pre>"},{"location":"api/exchange/cloud/client/#academy.exchange.cloud.client.HttpExchangeClient.recv","title":"recv","text":"<pre><code>recv(timeout: float | None = None) -&gt; Message\n</code></pre> <p>Receive the next message in the mailbox.</p> <p>This blocks until the next message is received or the mailbox is closed.</p> <p>Parameters:</p> <ul> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional timeout in seconds to wait for the next message. If <code>None</code>, the default, block forever until the next message or the mailbox is closed.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>MailboxClosedError</code>             \u2013            <p>if the mailbox was closed.</p> </li> <li> <code>TimeoutError</code>             \u2013            <p>if a <code>timeout</code> was specified and exceeded.</p> </li> </ul> Source code in <code>academy/exchange/cloud/client.py</code> <pre><code>def recv(self, timeout: float | None = None) -&gt; Message:\n    \"\"\"Receive the next message in the mailbox.\n\n    This blocks until the next message is received or the mailbox\n    is closed.\n\n    Args:\n        timeout: Optional timeout in seconds to wait for the next\n            message. If `None`, the default, block forever until the\n            next message or the mailbox is closed.\n\n    Raises:\n        MailboxClosedError: if the mailbox was closed.\n        TimeoutError: if a `timeout` was specified and exceeded.\n    \"\"\"\n    try:\n        response = self._session.get(\n            self._message_url,\n            json={'mailbox': self.mailbox_id.model_dump_json()},\n            timeout=timeout,\n        )\n    except requests.exceptions.Timeout as e:\n        raise TimeoutError(\n            f'Failed to receive response in {timeout} seconds.',\n        ) from e\n    if response.status_code == _FORBIDDEN_CODE:\n        raise MailboxClosedError(self.mailbox_id)\n    response.raise_for_status()\n\n    message = BaseMessage.model_from_json(response.json().get('message'))\n    logger.debug(\n        'Received %s to %s',\n        type(response).__name__,\n        self.mailbox_id,\n    )\n    return message\n</code></pre>"},{"location":"api/exchange/cloud/client/#academy.exchange.cloud.client.HttpExchangeClient.clone","title":"clone","text":"<pre><code>clone() -&gt; HttpExchangeFactory\n</code></pre> <p>Shallow copy exchange to new, unbound version.</p> Source code in <code>academy/exchange/cloud/client.py</code> <pre><code>def clone(self) -&gt; HttpExchangeFactory:\n    \"\"\"Shallow copy exchange to new, unbound version.\"\"\"\n    return HttpExchangeFactory(\n        self.host,\n        self.port,\n        self.additional_headers,\n        self.scheme,\n        self.ssl_verify,\n    )\n</code></pre>"},{"location":"api/exchange/cloud/client/#academy.exchange.cloud.client.HttpExchangeClient.get_handle","title":"get_handle","text":"<pre><code>get_handle(\n    aid: AgentId[BehaviorT],\n) -&gt; BoundRemoteHandle[BehaviorT]\n</code></pre> <p>Create a new handle to an agent.</p> <p>A handle enables a client to invoke actions on the agent.</p> Note <p>It is not possible to create a handle to a client since a handle is essentially a new client of a specific agent.</p> <p>Parameters:</p> <ul> <li> <code>aid</code>               (<code>AgentId[BehaviorT]</code>)           \u2013            <p>EntityId of the agent to create an handle to.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>BoundRemoteHandle[BehaviorT]</code>           \u2013            <p>Handle to the agent.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>if <code>aid</code> is not an instance of <code>AgentId</code>.</p> </li> </ul> Source code in <code>academy/exchange/__init__.py</code> <pre><code>def get_handle(\n    self,\n    aid: AgentId[BehaviorT],\n) -&gt; BoundRemoteHandle[BehaviorT]:\n    \"\"\"Create a new handle to an agent.\n\n    A handle enables a client to invoke actions on the agent.\n\n    Note:\n        It is not possible to create a handle to a client since a handle\n        is essentially a new client of a specific agent.\n\n    Args:\n        aid: EntityId of the agent to create an handle to.\n\n    Returns:\n        Handle to the agent.\n\n    Raises:\n        TypeError: if `aid` is not an instance of\n            [`AgentId`][academy.identifier.AgentId].\n    \"\"\"\n    if not isinstance(aid, AgentId):\n        raise TypeError(\n            f'Handle must be created from an {AgentId.__name__} '\n            f'but got identifier with type {type(aid).__name__}.',\n        )\n\n    hdl = BoundRemoteHandle(self, aid, self.mailbox_id)\n    self.bound_handles[hdl.handle_id] = hdl\n    return hdl\n</code></pre>"},{"location":"api/exchange/cloud/client/#academy.exchange.cloud.client.HttpExchangeClient.close_bound_handles","title":"close_bound_handles","text":"<pre><code>close_bound_handles() -&gt; None\n</code></pre> <p>Close all handles bound to this mailbox.</p> Source code in <code>academy/exchange/__init__.py</code> <pre><code>def close_bound_handles(self) -&gt; None:\n    \"\"\"Close all handles bound to this mailbox.\"\"\"\n    for key in tuple(self.bound_handles):\n        handle = self.bound_handles.pop(key)\n        handle.close(wait_futures=False)\n</code></pre>"},{"location":"api/exchange/cloud/client/#academy.exchange.cloud.client.HttpExchangeClient.listen","title":"listen","text":"<pre><code>listen() -&gt; None\n</code></pre> <p>Listen for new messages in the mailbox and process them.</p> <p>Request messages are processed via the <code>request_handler</code>, and response messages are dispatched to the handle that created the corresponding request.</p> Warning <p>This method loops forever, until the mailbox is closed. Thus this method is typically run inside of a thread.</p> Note <p>Response messages intended for a handle that does not exist will be logged and discarded.</p> Source code in <code>academy/exchange/__init__.py</code> <pre><code>def listen(self) -&gt; None:\n    \"\"\"Listen for new messages in the mailbox and process them.\n\n    Request messages are processed via the `request_handler`, and response\n    messages are dispatched to the handle that created the corresponding\n    request.\n\n    Warning:\n        This method loops forever, until the mailbox is closed. Thus this\n        method is typically run inside of a thread.\n\n    Note:\n        Response messages intended for a handle that does not exist\n        will be logged and discarded.\n    \"\"\"\n    try:\n        while True:\n            message = self.recv()\n            self._message_handler(message)\n    except MailboxClosedError:\n        pass\n</code></pre>"},{"location":"api/exchange/cloud/client/#academy.exchange.cloud.client.spawn_http_exchange","title":"spawn_http_exchange","text":"<pre><code>spawn_http_exchange(\n    host: str = \"0.0.0.0\",\n    port: int = 5463,\n    *,\n    level: int | str = WARNING,\n    timeout: float | None = None\n) -&gt; Generator[HttpExchangeFactory]\n</code></pre> <p>Context manager that spawns an HTTP exchange in a subprocess.</p> <p>This function spawns a new process (rather than forking) and wait to return until a connection with the exchange has been established. When exiting the context manager, <code>SIGINT</code> will be sent to the exchange process. If the process does not exit within 5 seconds, it will be killed.</p> Warning <p>The exclusion of authentication and ssl configuration is intentional. This method should only be used for temporary exchanges in trusted environments (i.e. the login node of a cluster).</p> <p>Parameters:</p> <ul> <li> <code>host</code>               (<code>str</code>, default:                   <code>'0.0.0.0'</code> )           \u2013            <p>Host the exchange should listen on.</p> </li> <li> <code>port</code>               (<code>int</code>, default:                   <code>5463</code> )           \u2013            <p>Port the exchange should listen on.</p> </li> <li> <code>level</code>               (<code>int | str</code>, default:                   <code>WARNING</code> )           \u2013            <p>Logging level.</p> </li> <li> <code>timeout</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Connection timeout when waiting for exchange to start.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Generator[HttpExchangeFactory]</code>           \u2013            <p>Exchange interface connected to the spawned exchange.</p> </li> </ul> Source code in <code>academy/exchange/cloud/client.py</code> <pre><code>@contextlib.contextmanager\ndef spawn_http_exchange(\n    host: str = '0.0.0.0',\n    port: int = 5463,\n    *,\n    level: int | str = logging.WARNING,\n    timeout: float | None = None,\n) -&gt; Generator[HttpExchangeFactory]:\n    \"\"\"Context manager that spawns an HTTP exchange in a subprocess.\n\n    This function spawns a new process (rather than forking) and wait to\n    return until a connection with the exchange has been established.\n    When exiting the context manager, `SIGINT` will be sent to the exchange\n    process. If the process does not exit within 5 seconds, it will be\n    killed.\n\n    Warning:\n        The exclusion of authentication and ssl configuration is\n        intentional. This method should only be used for temporary exchanges\n        in trusted environments (i.e. the login node of a cluster).\n\n    Args:\n        host: Host the exchange should listen on.\n        port: Port the exchange should listen on.\n        level: Logging level.\n        timeout: Connection timeout when waiting for exchange to start.\n\n    Returns:\n        Exchange interface connected to the spawned exchange.\n    \"\"\"\n    # Fork is not safe in multi-threaded context.\n    multiprocessing.set_start_method('spawn')\n\n    config = ExchangeServingConfig(host=host, port=port, log_level=level)\n    exchange_process = multiprocessing.Process(\n        target=_run,\n        args=(config,),\n    )\n    exchange_process.start()\n\n    logger.info('Starting exchange server...')\n    wait_connection(host, port, timeout=timeout)\n    logger.info('Started exchange server!')\n\n    exchange = HttpExchangeFactory(\n        host,\n        port,\n    )\n    try:\n        yield exchange\n    finally:\n        logger.info('Terminating exchange server...')\n        wait = 5\n        exchange_process.terminate()\n        exchange_process.join(timeout=wait)\n        if exchange_process.exitcode is None:  # pragma: no cover\n            logger.info(\n                'Killing exchange server after waiting %s seconds',\n                wait,\n            )\n            exchange_process.kill()\n        else:\n            logger.info('Terminated exchange server!')\n        exchange_process.close()\n</code></pre>"},{"location":"api/exchange/cloud/config/","title":"academy.exchange.cloud.config","text":"<code>academy/exchange/cloud/config.py</code> <p>Cloud exchange configuration file parsing.</p>"},{"location":"api/exchange/cloud/config/#academy.exchange.cloud.config.ExchangeAuthConfig","title":"ExchangeAuthConfig  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Exchange authentication configuration.</p> <p>Attributes:</p> <ul> <li> <code>method</code>               (<code>Optional[Literal['globus']]</code>)           \u2013            <p>Authentication method.</p> </li> <li> <code>kwargs</code>               (<code>Dict[str, Any]</code>)           \u2013            <p>Arbitrary keyword arguments to pass to the authenticator. The kwargs are excluded from the <code>repr()</code> of this class because they often contain secrets.</p> </li> </ul> <p>Config:</p> <ul> <li><code>extra</code>: <code>forbid</code></li> </ul> <p>Fields:</p> <ul> <li> <code>method</code>                 (<code>Optional[Literal['globus']]</code>)             </li> <li> <code>kwargs</code>                 (<code>Dict[str, Any]</code>)             </li> </ul>"},{"location":"api/exchange/cloud/config/#academy.exchange.cloud.config.ExchangeServingConfig","title":"ExchangeServingConfig  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Exchange serving configuration.</p> <p>Attributes:</p> <ul> <li> <code>host</code>               (<code>str</code>)           \u2013            <p>Network interface the server binds to.</p> </li> <li> <code>port</code>               (<code>int</code>)           \u2013            <p>Network port the server binds to.</p> </li> <li> <code>certfile</code>               (<code>Optional[str]</code>)           \u2013            <p>Certificate file (PEM format) use to enable TLS.</p> </li> <li> <code>keyfile</code>               (<code>Optional[str]</code>)           \u2013            <p>Private key file. If not specified, the key will be taken from the certfile.</p> </li> <li> <code>auth</code>               (<code>ExchangeAuthConfig</code>)           \u2013            <p>Authentication configuration.</p> </li> <li> <code>log_file</code>               (<code>Optional[str]</code>)           \u2013            <p>Location to write logs.</p> </li> <li> <code>log_level</code>               (<code>Union[int, str]</code>)           \u2013            <p>Verbosity of logs.</p> </li> </ul> <p>Fields:</p> <ul> <li> <code>host</code>                 (<code>str</code>)             </li> <li> <code>port</code>                 (<code>int</code>)             </li> <li> <code>certfile</code>                 (<code>Optional[str]</code>)             </li> <li> <code>keyfile</code>                 (<code>Optional[str]</code>)             </li> <li> <code>auth</code>                 (<code>ExchangeAuthConfig</code>)             </li> <li> <code>log_file</code>                 (<code>Optional[str]</code>)             </li> <li> <code>log_level</code>                 (<code>Union[int, str]</code>)             </li> </ul>"},{"location":"api/exchange/cloud/config/#academy.exchange.cloud.config.ExchangeServingConfig.from_toml","title":"from_toml  <code>classmethod</code>","text":"<pre><code>from_toml(filepath: str | Path) -&gt; Self\n</code></pre> <p>Parse an TOML config file.</p> Example <p>Minimal config without SSL and without authentication. exchange.toml<pre><code>port = 8700\n</code></pre></p> <pre><code>from academy.exchange.cloud.config import ExchangeServingConfig\n\nconfig = ExchangeServingConfig.from_toml('exchange.toml')\n</code></pre> Example <p>Serve with SSL and Globus Auth. relay.toml<pre><code>host = \"0.0.0.0\"\nport = 8700\ncertfile = \"/path/to/cert.pem\"\nkeyfile = \"/path/to/privkey.pem\"\n\n[auth]\nmethod = \"globus\"\n\n[auth.kwargs]\nclient_id = \"...\"\nclient_secret = \"...\"\n</code></pre></p> Note <p>Omitted values will be set to their defaults (if they are an optional value with a default). relay.toml<pre><code>[serving]\ncertfile = \"/path/to/cert.pem\"\n</code></pre></p> <pre><code>from academy.exchange.cloud.config import ExchangeServingConfig\n\nconfig = ExchangeServingConfig.from_config('relay.toml')\nassert config.certfile == '/path/to/cert.pem'\nassert config.keyfile is None\n</code></pre> Source code in <code>academy/exchange/cloud/config.py</code> <pre><code>@classmethod\ndef from_toml(cls, filepath: str | pathlib.Path) -&gt; Self:\n    \"\"\"Parse an TOML config file.\n\n    Example:\n        Minimal config without SSL and without authentication.\n        ```toml title=\"exchange.toml\"\n        port = 8700\n        ```\n\n        ```python\n        from academy.exchange.cloud.config import ExchangeServingConfig\n\n        config = ExchangeServingConfig.from_toml('exchange.toml')\n        ```\n\n    Example:\n        Serve with SSL and Globus Auth.\n        ```toml title=\"relay.toml\"\n        host = \"0.0.0.0\"\n        port = 8700\n        certfile = \"/path/to/cert.pem\"\n        keyfile = \"/path/to/privkey.pem\"\n\n        [auth]\n        method = \"globus\"\n\n        [auth.kwargs]\n        client_id = \"...\"\n        client_secret = \"...\"\n        ```\n\n    Note:\n        Omitted values will be set to their defaults (if they are an\n        optional value with a default).\n        ```toml title=\"relay.toml\"\n        [serving]\n        certfile = \"/path/to/cert.pem\"\n        ```\n\n        ```python\n        from academy.exchange.cloud.config import ExchangeServingConfig\n\n        config = ExchangeServingConfig.from_config('relay.toml')\n        assert config.certfile == '/path/to/cert.pem'\n        assert config.keyfile is None\n        ```\n    \"\"\"\n    with open(filepath, 'rb') as f:\n        return load(cls, f)\n</code></pre>"},{"location":"api/exchange/cloud/config/#academy.exchange.cloud.config.load","title":"load","text":"<pre><code>load(model: type[BaseModelT], fp: BinaryIO) -&gt; BaseModelT\n</code></pre> <p>Parse TOML from a binary file to a data class.</p> <p>Parameters:</p> <ul> <li> <code>model</code>               (<code>type[BaseModelT]</code>)           \u2013            <p>Config model type to parse TOML using.</p> </li> <li> <code>fp</code>               (<code>BinaryIO</code>)           \u2013            <p>File-like bytes stream to read in.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>BaseModelT</code>           \u2013            <p>Model initialized from TOML file.</p> </li> </ul> Source code in <code>academy/exchange/cloud/config.py</code> <pre><code>def load(model: type[BaseModelT], fp: BinaryIO) -&gt; BaseModelT:\n    \"\"\"Parse TOML from a binary file to a data class.\n\n    Args:\n        model: Config model type to parse TOML using.\n        fp: File-like bytes stream to read in.\n\n    Returns:\n        Model initialized from TOML file.\n    \"\"\"\n    return loads(model, fp.read().decode())\n</code></pre>"},{"location":"api/exchange/cloud/config/#academy.exchange.cloud.config.loads","title":"loads","text":"<pre><code>loads(model: type[BaseModelT], data: str) -&gt; BaseModelT\n</code></pre> <p>Parse TOML string to data class.</p> <p>Parameters:</p> <ul> <li> <code>model</code>               (<code>type[BaseModelT]</code>)           \u2013            <p>Config model type to parse TOML using.</p> </li> <li> <code>data</code>               (<code>str</code>)           \u2013            <p>TOML string to parse.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>BaseModelT</code>           \u2013            <p>Model initialized from TOML file.</p> </li> </ul> Source code in <code>academy/exchange/cloud/config.py</code> <pre><code>def loads(model: type[BaseModelT], data: str) -&gt; BaseModelT:\n    \"\"\"Parse TOML string to data class.\n\n    Args:\n        model: Config model type to parse TOML using.\n        data: TOML string to parse.\n\n    Returns:\n        Model initialized from TOML file.\n    \"\"\"\n    data_dict = tomllib.loads(data)\n    return model.model_validate(data_dict, strict=True)\n</code></pre>"},{"location":"api/exchange/cloud/exceptions/","title":"academy.exchange.cloud.exceptions","text":"<code>academy/exchange/cloud/exceptions.py</code> <p>Exception types raised by exchange clients and servers.</p>"},{"location":"api/exchange/cloud/exceptions/#academy.exchange.cloud.exceptions.ExchangeServerError","title":"ExchangeServerError","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception type for exceptions raised by relay clients.</p>"},{"location":"api/exchange/cloud/exceptions/#academy.exchange.cloud.exceptions.ForbiddenError","title":"ForbiddenError","text":"<p>               Bases: <code>ExchangeServerError</code></p> <p>Client does not have correct permissions after authentication.</p>"},{"location":"api/exchange/cloud/exceptions/#academy.exchange.cloud.exceptions.UnauthorizedError","title":"UnauthorizedError","text":"<p>               Bases: <code>ExchangeServerError</code></p> <p>Client is missing authentication tokens.</p>"},{"location":"api/exchange/cloud/login/","title":"academy.exchange.cloud.login","text":"<code>academy/exchange/cloud/login.py</code> <p>Create <code>GlobusApp</code> instances.</p> <p>Taken from: https://github.com/proxystore/proxystore/blob/e296f937d913cae02f87ab35112fd4c8351860b0/proxystore/globus/app.py</p>"},{"location":"api/exchange/cloud/login/#academy.exchange.cloud.login.get_token_storage","title":"get_token_storage","text":"<pre><code>get_token_storage(\n    filepath: str | Path | None = None,\n    *,\n    namespace: str = \"DEFAULT\"\n) -&gt; SQLiteTokenStorage\n</code></pre> <p>Create token storage adapter.</p> <p>Parameters:</p> <ul> <li> <code>filepath</code>               (<code>str | Path | None</code>, default:                   <code>None</code> )           \u2013            <p>Name of the database file. If not provided, defaults to a file in the Academy home directory specified by ACADEMY_HOME.</p> </li> <li> <code>namespace</code>               (<code>str</code>, default:                   <code>'DEFAULT'</code> )           \u2013            <p>Optional namespace to use within the database for partitioning token data.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>SQLiteTokenStorage</code>           \u2013            <p>Token storage.</p> </li> </ul> Source code in <code>academy/exchange/cloud/login.py</code> <pre><code>def get_token_storage(\n    filepath: str | pathlib.Path | None = None,\n    *,\n    namespace: str = 'DEFAULT',\n) -&gt; SQLiteTokenStorage:\n    \"\"\"Create token storage adapter.\n\n    Args:\n        filepath: Name of the database file. If not provided, defaults to a\n            file in the Academy home directory specified by ACADEMY_HOME.\n        namespace: Optional namespace to use within the database for\n            partitioning token data.\n\n    Returns:\n        Token storage.\n    \"\"\"\n    if filepath is None:\n        default = os.path.join(\n            os.path.expanduser('~/local/share'),\n            _APP_NAME,\n        )\n        basepath = os.environ.get('ACADEMY_HOME', default=default)\n        filepath = os.path.join(basepath, _TOKENS_FILE)\n\n    print(filepath)\n    filepath = pathlib.Path(filepath)\n    filepath.parent.mkdir(parents=True, exist_ok=True)\n    return SQLiteTokenStorage(filepath, namespace=namespace)\n</code></pre>"},{"location":"api/exchange/cloud/login/#academy.exchange.cloud.login.get_client_credentials_from_env","title":"get_client_credentials_from_env","text":"<pre><code>get_client_credentials_from_env() -&gt; tuple[str, str]\n</code></pre> <p>Read the Globus Client ID and secret from the environment.</p> <p>The Client ID should be set to <code>ACADEMY_GLOBUS_CLIENT_ID</code> and the secret to <code>ACADEMY_GLOBUS_CLIENT_SECRET</code>.</p> Note <p>This function performs no validation on the values of the variables.</p> <p>Returns:</p> <ul> <li> <code>tuple[str, str]</code>           \u2013            <p>Tuple containing the client ID and secret.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>if one of the environment variables is set.</p> </li> </ul> Source code in <code>academy/exchange/cloud/login.py</code> <pre><code>def get_client_credentials_from_env() -&gt; tuple[str, str]:\n    \"\"\"Read the Globus Client ID and secret from the environment.\n\n    The Client ID should be set to `ACADEMY_GLOBUS_CLIENT_ID` and\n    the secret to `ACADEMY_GLOBUS_CLIENT_SECRET`.\n\n    Note:\n        This function performs no validation on the values of the variables.\n\n    Returns:\n        Tuple containing the client ID and secret.\n\n    Raises:\n        ValueError: if one of the environment variables is set.\n    \"\"\"\n    try:\n        client_id = os.environ[ACADEMY_GLOBUS_CLIENT_ID_ENV_NAME]\n        client_secret = os.environ[ACADEMY_GLOBUS_CLIENT_SECRET_ENV_NAME]\n    except KeyError as e:\n        raise ValueError(\n            f'Both {ACADEMY_GLOBUS_CLIENT_ID_ENV_NAME} and '\n            f'{ACADEMY_GLOBUS_CLIENT_SECRET_ENV_NAME} must be set to '\n            'use a client identity. Either set both environment variables '\n            'or unset both to use the normal login flow.',\n        ) from e\n\n    return client_id, client_secret\n</code></pre>"},{"location":"api/exchange/cloud/login/#academy.exchange.cloud.login.get_globus_app","title":"get_globus_app","text":"<pre><code>get_globus_app() -&gt; GlobusApp\n</code></pre> <p>Get a Globus App based on the environment.</p> <p>If a client ID and secret are set in the environment, returns a <code>ClientApp</code> using <code>get_client_app()</code>. Otherwise returns a <code>UserApp</code> using <code>get_user_app()</code>.</p> <p>Returns:</p> <ul> <li> <code>GlobusApp</code>           \u2013            <p>Initialized app.</p> </li> </ul> Source code in <code>academy/exchange/cloud/login.py</code> <pre><code>def get_globus_app() -&gt; GlobusApp:\n    \"\"\"Get a Globus App based on the environment.\n\n    If a client ID and secret are set in the environment, returns a\n    [`ClientApp`][globus_sdk.ClientApp] using\n    [`get_client_app()`][academy.exchange.cloud.login.get_client_app].\n    Otherwise returns a [`UserApp`][globus_sdk.UserApp] using\n    [`get_user_app()`][academy.exchange.cloud.login.get_user_app].\n\n    Returns:\n        Initialized app.\n    \"\"\"\n    if is_client_login():\n        return get_client_app()\n    return get_user_app()\n</code></pre>"},{"location":"api/exchange/cloud/login/#academy.exchange.cloud.login.get_client_app","title":"get_client_app","text":"<pre><code>get_client_app(\n    client_id: str | None = None,\n    client_secret: str | None = None,\n) -&gt; ClientApp\n</code></pre> <p>Get a Client Globus App.</p> <p>Parameters:</p> <ul> <li> <code>client_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Client ID. If one or both of the <code>client_id</code> and <code>client_secret</code> are not provided, the values will be read from the environment using <code>get_client_credentials_from_env()</code>.</p> </li> <li> <code>client_secret</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Client secret. See above.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ClientApp</code>           \u2013            <p>Initialized app.</p> </li> </ul> Source code in <code>academy/exchange/cloud/login.py</code> <pre><code>def get_client_app(\n    client_id: str | None = None,\n    client_secret: str | None = None,\n) -&gt; ClientApp:\n    \"\"\"Get a Client Globus App.\n\n    Args:\n        client_id: Client ID. If one or both of the `client_id` and\n            `client_secret` are not provided, the values will be read from\n            the environment using\n            [`get_client_credentials_from_env()`][academy.exchange.cloud.login.get_client_credentials_from_env].\n        client_secret: Client secret. See above.\n\n    Returns:\n        Initialized app.\n    \"\"\"\n    if client_id is None or client_secret is None:\n        client_id, client_secret = get_client_credentials_from_env()\n\n    config = GlobusAppConfig(\n        token_storage=get_token_storage(),\n        request_refresh_tokens=True,\n    )\n\n    return ClientApp(\n        app_name=_APP_NAME,\n        client_id=client_id,\n        client_secret=client_secret,\n        config=config,\n    )\n</code></pre>"},{"location":"api/exchange/cloud/login/#academy.exchange.cloud.login.get_user_app","title":"get_user_app","text":"<pre><code>get_user_app() -&gt; UserApp\n</code></pre> <p>Get a User Globus App.</p> <p>The <code>UserApp</code> will automatically perform an interactive flow with the user as needed.</p> <p>Returns:</p> <ul> <li> <code>UserApp</code>           \u2013            <p>Initialized app.</p> </li> </ul> Source code in <code>academy/exchange/cloud/login.py</code> <pre><code>def get_user_app() -&gt; UserApp:\n    \"\"\"Get a User Globus App.\n\n    The [`UserApp`][globus_sdk.UserApp] will\n    automatically perform an interactive flow with the user as needed.\n\n    Returns:\n        Initialized app.\n    \"\"\"\n    config = GlobusAppConfig(\n        login_flow_manager=_CustomLoginFlowManager,\n        token_storage=get_token_storage(),\n        request_refresh_tokens=True,\n    )\n\n    return UserApp(\n        app_name=_APP_NAME,\n        client_id=ACADEMY_GLOBUS_CLIENT_ID,\n        config=config,\n    )\n</code></pre>"},{"location":"api/exchange/cloud/login/#academy.exchange.cloud.login.is_client_login","title":"is_client_login","text":"<pre><code>is_client_login() -&gt; bool\n</code></pre> <p>Check if Globus client identity environment variables are set.</p> <p>Based on the Globus Compute SDK's <code>is_client_login()</code>.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p><code>True</code> if <code>ACADEMY_GLOBUS_CLIENT_ID</code> and         <code>ACADEMY_GLOBUS_CLIENT_SECRET</code> are set.</p> </li> </ul> Source code in <code>academy/exchange/cloud/login.py</code> <pre><code>def is_client_login() -&gt; bool:\n    \"\"\"Check if Globus client identity environment variables are set.\n\n    Based on the Globus Compute SDK's\n    [`is_client_login()`](https://github.com/funcx-faas/funcX/blob/8f5b59075ae6f8e8b8b13fe1b91430271f4e0c3c/compute_sdk/globus_compute_sdk/sdk/login_manager/client_login.py#L24-L38){target=_blank}.\n\n    Returns:\n        `True` if `ACADEMY_GLOBUS_CLIENT_ID` and \\\n        `ACADEMY_GLOBUS_CLIENT_SECRET` are set.\n    \"\"\"\n    try:\n        get_client_credentials_from_env()\n    except ValueError:\n        return False\n    else:\n        return True\n</code></pre>"},{"location":"api/exchange/cloud/login/#academy.exchange.cloud.login.get_auth_headers","title":"get_auth_headers","text":"<pre><code>get_auth_headers(\n    method: Literal[\"globus\"] | None, **kwargs: Any\n) -&gt; dict[str, str]\n</code></pre> <p>Client utility method to perform authentication and get headers.</p> Source code in <code>academy/exchange/cloud/login.py</code> <pre><code>def get_auth_headers(\n    method: Literal['globus'] | None,\n    **kwargs: Any,\n) -&gt; dict[str, str]:\n    \"\"\"Client utility method to perform authentication and get headers.\"\"\"\n    if method is None:\n        return {}\n    elif method == 'globus':\n        app = get_globus_app()\n        app.add_scope_requirements(\n            {\n                AcademyExchangeScopes.resource_server: [\n                    AcademyExchangeScopes.academy_exchange,\n                ],\n            },\n        )\n        try:\n            authorizer = app.get_authorizer(\n                AcademyExchangeScopes.resource_server,\n            )\n        except TokenValidationError:\n            raise SystemExit(1) from None\n\n        bearer = authorizer.get_authorization_header()\n        assert bearer is not None\n        return {'Authorization': bearer}\n    else:\n        raise AssertionError('Unreachable.')\n</code></pre>"},{"location":"api/exchange/cloud/server/","title":"academy.exchange.cloud.server","text":"<code>academy/exchange/cloud/server.py</code> <p>HTTP message exchange client and server.</p> <p>To start the exchange: <pre><code>python -m academy.exchange.cloud --config exchange.yaml\n</code></pre></p> <p>Connect to the exchange through the client. <pre><code>from academy.exchange.cloud.client import HttpExchange\n\nwith HttpExchange('localhost', 1234) as exchange:\n    aid = exchange.register_agent()\n    mailbox = exchange.get_mailbox(aid)\n    ...\n    mailbox.close()\n</code></pre></p>"},{"location":"api/exchange/cloud/server/#academy.exchange.cloud.server.authenticate_factory","title":"authenticate_factory","text":"<pre><code>authenticate_factory(authenticator: Authenticator) -&gt; Any\n</code></pre> <p>Create an authentication middleware for a given authenticator.</p> <p>Parameters:</p> <ul> <li> <code>authenticator</code>               (<code>Authenticator</code>)           \u2013            <p>Used to validate client id and transform token into id.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any</code>           \u2013            <p>A aiohttp.web.middleware function that will only allow authenticated requests.</p> </li> </ul> Source code in <code>academy/exchange/cloud/server.py</code> <pre><code>def authenticate_factory(\n    authenticator: Authenticator,\n) -&gt; Any:\n    \"\"\"Create an authentication middleware for a given authenticator.\n\n    Args:\n        authenticator: Used to validate client id and transform token into id.\n\n    Returns:\n        A aiohttp.web.middleware function that will only allow authenticated\n            requests.\n    \"\"\"\n\n    @middleware\n    async def authenticate(\n        request: Request,\n        handler: Callable[[Request], Awaitable[Response]],\n    ) -&gt; Response:\n        loop = asyncio.get_running_loop()\n        try:\n            # Needs to be run in executor because globus client is blocking\n            client_uuid: uuid.UUID = await loop.run_in_executor(\n                None,\n                authenticator.authenticate_user,\n                request.headers,\n            )\n        except ForbiddenError:\n            return Response(\n                status=_FORBIDDEN_CODE,\n                text='Token expired or revoked.',\n            )\n        except UnauthorizedError:\n            return Response(\n                status=_UNAUTHORIZED_CODE,\n                text='Missing required headers.',\n            )\n\n        headers = request.headers.copy()\n        headers['client_id'] = str(client_uuid)\n        request = request.clone(headers=headers)\n        return await handler(request)\n\n    return authenticate\n</code></pre>"},{"location":"api/exchange/cloud/server/#academy.exchange.cloud.server.create_app","title":"create_app","text":"<pre><code>create_app(\n    auth_config: ExchangeAuthConfig | None = None,\n) -&gt; Application\n</code></pre> <p>Create a new server application.</p> Source code in <code>academy/exchange/cloud/server.py</code> <pre><code>def create_app(\n    auth_config: ExchangeAuthConfig | None = None,\n) -&gt; Application:\n    \"\"\"Create a new server application.\"\"\"\n    middlewares = []\n    if auth_config is not None:\n        authenticator = get_authenticator(auth_config)\n        middlewares.append(authenticate_factory(authenticator))\n\n    manager = _MailboxManager()\n    app = Application(middlewares=middlewares)\n    app[MANAGER_KEY] = manager\n\n    app.router.add_post('/mailbox', _create_mailbox_route)\n    app.router.add_delete('/mailbox', _terminate_route)\n    app.router.add_get('/mailbox', _check_mailbox_route)\n    app.router.add_put('/message', _send_message_route)\n    app.router.add_get('/message', _recv_message_route)\n    app.router.add_get('/discover', _discover_route)\n\n    return app\n</code></pre>"},{"location":"api/exchange/cloud/server/#academy.exchange.cloud.server.serve_app","title":"serve_app  <code>async</code>","text":"<pre><code>serve_app(\n    app: Application, host: str, port: int\n) -&gt; AsyncGenerator[None]\n</code></pre> <p>Serve an application as a context manager.</p> <p>Parameters:</p> <ul> <li> <code>app</code>               (<code>Application</code>)           \u2013            <p>Application to run.</p> </li> <li> <code>host</code>               (<code>str</code>)           \u2013            <p>Host to bind to.</p> </li> <li> <code>port</code>               (<code>int</code>)           \u2013            <p>Port to bind to.</p> </li> </ul> Source code in <code>academy/exchange/cloud/server.py</code> <pre><code>@contextlib.asynccontextmanager\nasync def serve_app(\n    app: Application,\n    host: str,\n    port: int,\n) -&gt; AsyncGenerator[None]:\n    \"\"\"Serve an application as a context manager.\n\n    Args:\n        app: Application to run.\n        host: Host to bind to.\n        port: Port to bind to.\n    \"\"\"\n    runner = AppRunner(app)\n    try:\n        await runner.setup()\n        site = TCPSite(runner, host, port)\n        await site.start()\n        logger.info('Exchange listening on %s:%s', host, port)\n        yield\n    finally:\n        await runner.cleanup()\n        logger.info('Exchange closed!')\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#getting-started-for-local-development","title":"Getting Started for Local Development","text":"<p>We recommend using Tox to setup the development environment. This will create a new virtual environment with all of the required packages installed and TaPS installed in editable mode with the necessary extras options.</p> <pre><code>$ git clone https://github.com/proxystore/academy\n$ cd academy\n$ tox --devenv venv -e py311\n$ . venv/bin/activate\n</code></pre> <p>Warning</p> <p>Running Tox in a Conda environment is possible but it may conflict with Tox's ability to find the correct Python versions. E.g., if your Conda environment is Python 3.11, running <code>$ tox -e p310</code> may still use Python 3.11.</p> <p>To install manually: <pre><code>$ git clone https://github.com/proxystore/academy\n$ cd academy\n$ python -m venv venv\n$ . venv/bin/activate\n$ pip install -e .[dev,docs]\n</code></pre></p>"},{"location":"contributing/#continuous-integration","title":"Continuous Integration","text":"<p>Academy uses pre-commit and Tox for continuous integration (test, linting, etc.).</p>"},{"location":"contributing/#linting-and-type-checking-pre-commit","title":"Linting and Type Checking (pre-commit)","text":"<p>To use pre-commit, install the hook and then run against files.</p> <pre><code>$ pre-commit install\n$ pre-commit run --all-files\n</code></pre>"},{"location":"contributing/#tests-tox","title":"Tests (tox)","text":"<p>The entire CI workflow can be run with <code>$ tox</code>. This will test against multiple versions of Python and can be slow.</p> <p>Module-level unit-test are located in the <code>tests/</code> directory and its structure is intended to match that of <code>academy/</code>. E.g. the tests for <code>academy/x/y.py</code> are located in <code>tests/x/y_test.py</code>; however, additional test files can be added as needed. Tests should be narrowly focused and target a single aspect of the code's functionality, tests should not test internal implementation details of the code, and tests should not be dependent on the order in which they are run.</p> <p>Code that is useful for building tests but is not a test itself belongs in the <code>testing/</code> directory.</p> <pre><code># Run all tests in tests/\n$ tox -e py311\n# Run a specific test\n$ tox -e py311 -- tests/x/y_test.py::test_z\n</code></pre>"},{"location":"contributing/#docs","title":"Docs","text":"<p>If code changes require an update to the documentation (e.g., for function signature changes, new modules, etc.), the documentation can be built using MKDocs.</p> <pre><code># Manually\n$ pip install -e .[docs] # If you skipped this step earlier\n$ mkdocs build --strict  # Build only to site/index.html\n$ mkdocs serve           # Serve locally\n\n# With tox (will only build, does not serve)\n$ tox -e docs\n</code></pre> <p>Docstrings are automatically generated, but it is recommended to check the generated docstrings to make sure details/links/etc. are correct.</p>"},{"location":"contributing/issues-pull-requests/","title":"Issues and Pull Requests","text":""},{"location":"contributing/issues-pull-requests/#issues","title":"Issues","text":"<p>Issue Tracker</p> <p>We use GitHub issues to report problems, request and track changes, and discuss future ideas. If you open an issue for a specific problem, please follow the template guides.</p>"},{"location":"contributing/issues-pull-requests/#pull-requests","title":"Pull Requests","text":"<p>We use the standard GitHub contribution cycle where all contributions are made via pull requests (including code owners!).</p> <ol> <li>Fork the repository and clone to your local machine.</li> <li> <p>Create local changes.</p> <ul> <li>Changes should conform to the style and testing guidelines, referenced above.</li> <li>Preferred commit message format (source):<ul> <li>separate subject from body with a blank line,</li> <li>limit subject line to 50 characters,</li> <li>capitalize first word of subject line,</li> <li>do not end the subject line with a period,</li> <li>use the imperative mood for subject lines,</li> <li>include related issue numbers at end of subject line,</li> <li>wrap body at 72 characters, and</li> <li>use the body to explain what/why rather than how.</li> <li>Example: <code>Fix concurrency bug in Store (#42)</code></li> </ul> </li> </ul> </li> <li> <p>Push commits to your fork.</p> <ul> <li>Please squash commits fixing mistakes to keep the git history clean.   For example, if commit \"b\" follows commit \"a\" and only fixes a small typo from \"a\", please squash \"a\" and \"b\" into a single, correct commit.   This keeps the commit history readable and easier to search through when debugging (e.g., git blame/bisect).</li> </ul> </li> <li>Open a pull request in this repository.<ul> <li>The pull request should include a description of the motivation for the PR and included changes.   A PR template is provided to guide this process.</li> </ul> </li> </ol>"},{"location":"contributing/releases/","title":"Releases","text":""},{"location":"contributing/releases/#release-timeline","title":"Release Timeline","text":"<p>Releases are created on an as-needed basis. Milestones in the Issue Tracker are used to track features to be included in upcoming releases.</p>"},{"location":"contributing/releases/#versioning","title":"Versioning","text":"<p>Academy uses semver as its versioning system. Rather, changes are only considered breaking if they change the way an application is run. For example, the command from a prior release no longer works in the following release. While Academy is in major version zero (0.y.z), breaking changes will be released in minor version updates.</p>"},{"location":"contributing/releases/#creating-releases","title":"Creating Releases","text":"<ol> <li>Choose the next version number, referred to as <code>{VERSION}</code> for the    rest of the instructions. Versioning follows semver    (<code>major.minor.patch</code>) with optional PEP-440    pre-release/post-release/dev-release segments. Major/minor/patch numbers    start at 0 and pre-release/post-release/dev-release segments start at 1.</li> <li>Update the version in <code>pyproject.toml</code> to <code>{VERSION}</code>.</li> <li>Commit and merge the version updates/changelogs into main.</li> <li>Tag the release commit and push (typically this is the commit updating the    version numbers).    <pre><code>$ git tag -s v{VERSION} -m \"Academy v{VERSION}\"\n$ git push origin v{VERSION}\n</code></pre>    Note the version number is prepended by \"v\" for the tags so we can    distinguish release tags from non-release tags.</li> <li>Create a new release on GitHub using the tag. The title should be    <code>Academy v{VERSION}</code>.</li> <li>Official release:<ol> <li>Use the \"Generate release notes\" option and set the previous tag as the previous official release tag. E.g., for <code>v0.4.1</code>, the previous release tag should be <code>v0.4.0</code> and NOT <code>v0.4.1a1</code>.</li> <li>Add an \"Upgrade Steps\" section at the top (see previous releases for examples).</li> <li>Review the generated notes and edit as needed. PRs are organized by tag, but some PRs will be missing tags and need to be moved from the \"Other Changes\" section to the correct section.</li> <li>Select \"Set as the latest release.\"</li> </ol> </li> <li>Unofficial release: (alpha/dev builds)<ol> <li>Do NOT generate release notes. The body can be along the lines of \"Development pre-prelease for <code>v{VERSION}</code>.\"</li> <li>Leave the previous tag as \"auto.\"</li> <li>Select \"Set as a pre-release.\"</li> </ol> </li> </ol>"},{"location":"contributing/style-guide/","title":"Style Guide","text":"<p>The Python code and docstring format mostly follows Google's Python Style Guide, but the pre-commit config is the authoritative source for code format compliance.</p> <p>Nits:</p> <ul> <li>Avoid imports in <code>__init__.py</code> (reduces the likelihood of circular imports).</li> <li>Prefer pure functions where possible.</li> <li>Define all class attributes inside <code>__init__</code> so all attributes are visible in one place.   Attributes that are defined later can be set as <code>None</code> as a placeholder.</li> <li>Prefer f-strings (<code>f'name: {name}</code>) over string format (<code>'name: {}'.format(name)</code>).   Never use the <code>%</code> operator.</li> <li>Prefer typing.NamedTuple over collections.namedtuple.</li> <li>Use lower-case and no punctuation for log messages, but use upper-case and punctuation for exception values.   <pre><code>logger.info(f'new connection opened to {address}')\nraise ValueError('Name must contain alphanumeric characters only.')\n</code></pre></li> <li>Document all exceptions that may be raised by a function in the docstring.</li> </ul>"},{"location":"guides/","title":"Guides","text":"<p>Warning</p> <p>Guides are under development!</p> <ul> <li>Example</li> </ul>"},{"location":"guides/example/","title":"Example","text":""},{"location":"publications/","title":"Publications","text":""},{"location":"publications/#citing-academy","title":"Citing Academy","text":"<p>!!!+ info</p> <pre><code>Check back later.\n</code></pre>"},{"location":"publications/#featured-publications","title":"Featured Publications","text":"<p>!!!+ info</p> <pre><code>Check back later.\n</code></pre>"}]}